<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of oxcarxierra</title>
  
  <subtitle>oxcarxierra</subtitle>
  <link href="https://oxcarxierra.github.io/feed.xml" rel="self"/>
  
  <link href="https://oxcarxierra.github.io/"/>
  <updated>2023-02-05T15:23:37.000Z</updated>
  <id>https://oxcarxierra.github.io/</id>
  
  <author>
    <name>oxcarxierra | 오승석</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023년 1월 회고</title>
    <link href="https://oxcarxierra.github.io/Review/2023/january-2023-review/"/>
    <id>https://oxcarxierra.github.io/Review/2023/january-2023-review/</id>
    <published>2023-02-05T15:23:37.000Z</published>
    <updated>2023-02-05T15:23:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>2월 회고를 일주일이나 지나서 쓰는… 귀찮음 + 바쁨을 핑계로 대겠다.</p><p>2023년의 첫 한 달은 넘치는 포데이 덕분에 부대에서 일한 시간보다 밖에서 코딩한 시간이 더 많았던 것 같다. 매일 알차게 살긴 했는데, 국방부 시계가 멈춘다는 상말이라 그런건지 단순히 번아웃 때문인지 최근들어 알 수 없는 답답함과 찝찝함이 자꾸 든다.</p><p>ADDIT 팀에서 NextJs 기반의 웹을 제작해서, 배포까지 완료했다. 궁극적으로 만들고자 하는 아이템의 프로토타입으로서 테마를 축구로 Lean하게 좁힌 에디터를 구현해보기로 했다. 오랜만에 NextJs를 써보니 예전에 이해도가 부족한 상태로 사용할 때 보다 그 진가를 좀 알게 된 느낌이다. 그리고 지금까지 쌓인 노하우와 컨벤션을 최대한 적용해보면서, 옛날에 내가 썼던 코드들보다 훨씬 깔끔해진 걸 느낄 수 있었다.</p><p>작년에 앱스토어에 출시했던 USFK Bus 앱을 사실상 손 놓고 방치해두고 있었는데, 어떤 미군이 잘 쓰고 있다면서 셔틀버스 시간표가 바뀌는데 업데이트 좀 해달라는 메일을 보내왔다. 순간 이 시장(?)을 독점할 수 있는 절호의 기회라는 생각에 급하게 데이터를 모으고 DB를 새로 팠다. Django랑 MySQL 지식을 많이 까먹어서 좀 헤멨지만 생각보다 빨리 감을 잡아서 업데이트 후 일단 배포까지 마무리했다. 역시 서비스는 유저가 있어야 그 의미가 생기고, 개발자는 동기부여를 얻는다. 앞으로 여러 부가기능 추가를 포함해서 유지보수를 꾸준히 해야겠다. 캠프 케이시 시간표도 추가할 예정이다.</p><p>부스트코스 코칭스터디 9기 &lt;인공지능 기초 다지기&gt; 프로그램에 리드부스터로 참여하는 중이다. 강의를 들을 시간이 많지 않기도 하고, 지금까지는 알고 있던 내용이라 대충 넘기고 있는데 앞으로 남은 강의는 챙기면서 본격 딥러닝 복습을 시작해봐야겠다.</p><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><ul><li><strong>&lt;위험한 숫자들 The Number Bias&gt;</strong>, 사너 블라우 (진중문고)</li></ul><p><del>책을.. 많이 .. 읽자.. 제발..</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2월 회고를 일주일이나 지나서 쓰는… 귀찮음 + 바쁨을 핑계로 대겠다.&lt;/p&gt;
&lt;p&gt;2023년의 첫 한 달은 넘치는 포데이 덕분에 부대에서 일한 시간보다 밖에서 코딩한 시간이 더 많았던 것 같다. 매일 알차게 살긴 했는데, 국방부 시계가 멈춘다는</summary>
      
    
    
    
    <category term="Review" scheme="https://oxcarxierra.github.io/categories/Review/"/>
    
    
  </entry>
  
  <entry>
    <title>[React Native] React Native 프로젝트 생성시 Ruby 버전 오류와 해결</title>
    <link href="https://oxcarxierra.github.io/Development/react-native-init-ruby-version-error/"/>
    <id>https://oxcarxierra.github.io/Development/react-native-init-ruby-version-error/</id>
    <published>2023-01-29T15:37:13.000Z</published>
    <updated>2023-01-29T15:37:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="React-Native-프로젝트-생성시-발생한-에러"><a href="#React-Native-프로젝트-생성시-발생한-에러" class="headerlink" title="React Native 프로젝트 생성시 발생한 에러"></a>React Native 프로젝트 생성시 발생한 에러</h2><p>오랜만에 설레는 마음으로 터미널을 켜고 React Native 프로젝트를 생성하는 순간</p><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/XzgKlos.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/XzgKlos.png" alt=""></a></div><div style="clear:both;"></div><p><code>Installing Bundler</code>단계에서 펑!하고 터져버렸다. <del>머선129</del></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ignoring digest-crc-0.6.3 because its extensions are not built. Try: gem pristine digest-crc --version 0.6.3</span><br><span class="line">Ignoring unf_ext-crc-0.0.7.7 because its extensions are not built. Try: gem pristine unf_ext --version 0.0.7.7</span><br><span class="line"></span><br><span class="line">Error: Looks like your iOS environment is not properly set. ~~</span><br></pre></td></tr></table></figure><p>Try해보라는 커맨드를 입력해봤지만 같은 에러가 뜨기는 마찬가지였다. 약간의 구글링과 삽질을 통해 ruby 버전의 문제임을 알았다. 내 mac에 설치된 Ruby의 버전이 낮아서, 업데이트하니 말끔히 해결되었다.</p><h2 id="Ruby-버전-업데이트"><a href="#Ruby-버전-업데이트" class="headerlink" title="Ruby 버전 업데이트"></a>Ruby 버전 업데이트</h2><p>현재 작업중인 폴더에 설치된 Ruby의 버전은 아래 커맨드로 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br></pre></td></tr></table></figure><p>Ruby의 버전을 선택해서 설치하거나 업그레이드하려면, Ruby 버전 관리 툴인 <code>rbenv</code>를 설치해야한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew update</span><br><span class="line"></span><br><span class="line">$ brew install rbenv</span><br></pre></td></tr></table></figure><p>이후 React Native에서 요구하는 버전으로 Ruby를 새로 설치하자. 필요한 Ruby의 버전은 <a href="https://github.com/facebook/react-native/blob/main/.ruby-version">여기</a>에서 확인할 수 있다. 글을 작성하는 시점에는 2.7.6으로 되어있었다. 참고로 상위 버전의 Ruby를 설치했을 때에도 오류가 나서, 정확히 일치하는 버전을 설치해야 하는 것 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rbenv install 2.7.6</span><br></pre></td></tr></table></figure><p>이후 아래 커맨드를 통해 rbenv에 설치된 Ruby를 사용하도록 설정해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ rbenv global 2.7.6</span><br><span class="line"></span><br><span class="line">$ ruby --version</span><br><span class="line">* 2.7.6</span><br></pre></td></tr></table></figure><p>만약 <code>rbenv global</code> 커맨드 이후에도 <code>ruby --version</code>이 바뀌지 않는다면, 환경변수 설정이 필요하다. <code>eval &quot;$(rbenv init - zsh)&quot;</code>를 <code>~/.zshrc</code>파일에 추가해주면, Ruby 버전이 정상적으로 반영된 것을 확인할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 마지막줄에 eval &quot;$(rbenv init - zsh)&quot; 추가</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line">$ ruby --version</span><br><span class="line">* 2.7.6</span><br></pre></td></tr></table></figure><p>이제 다시 설레는 마음으로 새로운 프로젝트를 시작해보자!</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx react-native init myProject --template react-native-template-typescript</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;h2 id=&quot;React-Native-프로젝트-생성시-발생한-에러&quot;&gt;&lt;a href=&quot;#React-Native-프로젝트-생성시-발생한-에러&quot; class=&quot;headerlink&quot; title=&quot;React Native 프로젝트 </summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>[국방 AI 부문 MINI 경진대회] 공정 프로세스 최종 품질값 예측 대회</title>
    <link href="https://oxcarxierra.github.io/ML/multi-stage-continuous-flow-manufacturing-process-competition/"/>
    <id>https://oxcarxierra.github.io/ML/multi-stage-continuous-flow-manufacturing-process-competition/</id>
    <published>2023-01-02T11:36:15.000Z</published>
    <updated>2023-01-02T11:36:15.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><br><div class="figure " style="width:;"><a class="fancybox" href="https://i.imgur.com/Ua5sYEA.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/Ua5sYEA.png" alt=""></a></div><p>Elice 장병 역량강화 플랫폼에서 12&#x2F;24 ~ 27 4일간 진행된 <a href="https://military22.elice.io/courses/33714/info">[국방 AI 부문 MINI 경진대회] 공정 프로세스 최종 품질값 예측 대회</a>에 참여해서, 7등으로 장려상을 수상하게 되었다.</p><br><div class="figure fig-50" style="width:;"><a class="fancybox" href="https://i.imgur.com/fzv4vA3.jpg" title="갤럭시 버즈2 게또!" data-caption="갤럭시 버즈2 게또!" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/fzv4vA3.jpg" alt="갤럭시 버즈2 게또!"></a><span class="caption">갤럭시 버즈2 게또!</span></div><div style="clear:both;"></div><hr><h1 id="대회-개요"><a href="#대회-개요" class="headerlink" title="대회 개요"></a>대회 개요</h1><p>이 대회는 여러 단계가 있는 연속 생산 공정에서 특정 단계의 품질값을 예측하는 것이 목표다. 공정은 두 개의 Stage로 분리되며, Stage 1과 Stage 2의 작동 방식은 각각 아래와 같다.<br><br></p><ol><li>Stage 1</li></ol><ul><li>Machine 1, 2, 3은 병렬적으로 작업하며, 각 기계의 Output들은 Combiner로 전달된다.</li><li>Combiner의 output은 15개의 특정 위치에서 품질값이 측정된다.</li></ul><ol start="2"><li>Stage 2</li></ol><ul><li>Stage 1의 Output은 Machine 4, 5를 직렬적으로 통과한다.</li><li>Machine 5의 Output 또한 15개의 특정 위치에서 품질값이 측정된다.</li></ul><p>시간(time_stamp)에 따른 Machine 1 ~ 5의 상태 데이터와 Stage 1, 2 output의 품질값이 데이터로 주어지며, 대회의 목표는 주어진 시간과 상태 데이터를 통해 30개의 품질값을 예측하는 것이었다. 각 스테이지에서 모델을 하나씩 사용하도록 하고, 각각의 예측값과 실제값의 <strong>R2</strong>를 계산하여 두 값을 평균낸 100점 만점의 성적으로 채점이 이루어졌다.</p><hr><h1 id="코드-리뷰"><a href="#코드-리뷰" class="headerlink" title="코드 리뷰"></a>코드 리뷰</h1><h2 id="데이터-분석-및-전처리"><a href="#데이터-분석-및-전처리" class="headerlink" title="데이터 분석 및 전처리"></a>데이터 분석 및 전처리</h2><p>이번 데이터는 feature의 의미를 알려주지 않아서, 다른 대회와 다르게 어떤 feature를 남겨야 할지 감을 잡기가 불가능했다. 그래서 지시사항에서 삭제하라고 했던 feature만 제거하고 Stage 1, Stage 2의 데이터를 독립적으로 분리시켜 사용하기로 했다.</p><p>또한 시간대별로 데이터가 있어서 시계열로 볼 수도 있겠으나, test data 시간대가 train data 시간대의 과거&#x2F;미래가 아니라, train data 시간대 중간중간의 빈칸이었기 때문에 시계열로 풀지 않았다. 차라리 <code>time_stamp</code>에서 연, 월, 일을 버리고 시, 분, 초만 추출해서 <code>hour</code>, <code>min</code>, <code>sec</code> 세 개의 feature들로 분리했다.</p><figure class="highlight python"><figcaption><span>시간 데이터 분리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_data[<span class="string">&#x27;hour&#x27;</span>] = train_data[<span class="string">&#x27;time_stamp&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">slice</span>(start=<span class="number">11</span>, stop=<span class="number">13</span>)</span><br><span class="line">train_data[<span class="string">&#x27;min&#x27;</span>] = train_data[<span class="string">&#x27;time_stamp&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">slice</span>(start=<span class="number">14</span>, stop=<span class="number">16</span>)</span><br><span class="line">train_data[<span class="string">&#x27;sec&#x27;</span>] = train_data[<span class="string">&#x27;time_stamp&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">slice</span>(start=<span class="number">17</span>, stop=<span class="number">19</span>)</span><br><span class="line">train_data = train_data.drop(columns=[<span class="string">&#x27;time_stamp&#x27;</span>])</span><br></pre></td></tr></table></figure><div class="figure " style="width:;"><a class="fancybox" href="https://i.imgur.com/WqQ8Q0L.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/WqQ8Q0L.png" alt=""></a></div><figure class="highlight py"><figcaption><span>Stage 1, 2 데이터 분리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stage1_data = train_data[train_data.columns.drop(<span class="built_in">list</span>(train_data.<span class="built_in">filter</span>(regex=<span class="string">&#x27;Machine4|Machine5|Stage2&#x27;</span>)))]</span><br><span class="line">stage2_data = train_data[train_data.columns.drop(<span class="built_in">list</span>(train_data.<span class="built_in">filter</span>(regex=<span class="string">&#x27;Machine1|Machine2|Machine3|Stage1&#x27;</span>)))]</span><br></pre></td></tr></table></figure><h2 id="모델-학습"><a href="#모델-학습" class="headerlink" title="모델 학습"></a>모델 학습</h2><p>사실 AI&#x2F;ML 대회는 처음이고 예전에 Kaggle 강의 찍먹해본게 다여서, 딱 하나 사용해봤던 <code>RandomForestRegressor</code>를 이번에도 가장 처음으로 시도해볼 수 밖에 없었다.</p><figure class="highlight py"><figcaption><span>RandomForestRegressor를 이용한 Stage 1 모델</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line"></span><br><span class="line">model1 = RandomForestRegressor(n_estimators=<span class="number">600</span>,</span><br><span class="line">                              n_jobs=-<span class="number">1</span>,</span><br><span class="line">                              random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">model1.fit(stage1_train_X, stage1_train_y)</span><br><span class="line"></span><br><span class="line">stage1_predictions = model1.predict(stage1_test_X)</span><br></pre></td></tr></table></figure><p>기대도 안했는데, 첫 점수가 72점이 나오면서 당시 순위로 3등에 올라가는 변수가 생겨버렸다. 뭔가 더 시도해보면 충분히 점수를 더 올릴 수 있을 것 같아서 model1의 output data를 model2의 input feature로 사용해보기도 했는데, 오히려 정확도가 감소한 결과를 얻었다.</p><p>이후에 점수가 더 이상 올라가지 않는 한계에 부딫히자 <code>ExtraTreesRegressor</code> 모델을 시도해보았다.<br>엑스트라 트리 또한 <code>scikit-learn</code>에서 제공하며, 각 트리를 무작위 특성으로 분할하는 식으로 무작위성을 증가시킨 모델이다.</p><figure class="highlight py"><figcaption><span>ExtraTreesRegressor를 이용한 Stage 2 모델</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> ExtraTreesRegressor</span><br><span class="line"></span><br><span class="line">model2 = ExtraTreesRegressor(</span><br><span class="line">  n_jobs=-<span class="number">1</span>,</span><br><span class="line">  random_state=<span class="number">0</span>,</span><br><span class="line">  max_features=<span class="string">&#x27;sqrt&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Stage 1 model은 <code>RandomForestRegressor</code>, Stage 2 model은 <code>ExtraTreesRegressor</code>를 이용했을 때 가장 결과가 좋았다.<br>이후 GridSearchCV를 이용하여 각 모델의 최적의 파라미터를 탐색했다.</p><figure class="highlight py"><figcaption><span>GridSearchCV를 이용한 하이퍼파라미터 튜닝</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"></span><br><span class="line">grid = &#123;</span><br><span class="line">  <span class="string">&#x27;n_estimators&#x27;</span> : [<span class="number">600</span>,<span class="number">800</span>,<span class="number">1000</span>],</span><br><span class="line">  <span class="string">&#x27;max_depth&#x27;</span> : [<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,],</span><br><span class="line">  <span class="string">&#x27;min_samples_leaf&#x27;</span> : [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  <span class="string">&#x27;min_samples_split&#x27;</span> : [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">model2_grid = GridSearchCV(model2, param_grid = grid, scoring=<span class="string">&quot;r2&quot;</span>, n_jobs=-<span class="number">1</span>, verbose =<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model2_grid.fit(stage2_train_X, stage2_train_y)</span><br><span class="line"></span><br><span class="line">model2_grid.best_params_</span><br></pre></td></tr></table></figure><figure class="highlight py"><figcaption><span>최적의 hyperparameter로 구성한 Stage 2 모델로 예측값 도출</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">best_model2 = ExtraTreesRegressor(</span><br><span class="line">  n_estimators=<span class="number">750</span>,</span><br><span class="line">  n_jobs=-<span class="number">1</span>,</span><br><span class="line">  random_state=<span class="number">0</span>,</span><br><span class="line">  max_depth=<span class="number">40</span>,</span><br><span class="line">  min_samples_split=<span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">best_model2.fit(stage2_train_X, stage2_train_y)</span><br><span class="line"></span><br><span class="line">stage2_predictions = best_model2.predict(stage2_test_X)</span><br></pre></td></tr></table></figure><p>최종 결과는 <strong>79.3932</strong>점이었는데, 1등 82.3점과 고작 3점 차이어서 1등의 코드가 더욱 궁금해진다. 그래도 첫 대회치고 정말 운 좋게 좋은 결과를 얻은 것 같아서 아주 만족스러웠다.</p><h2 id="Extra-Trees-Model"><a href="#Extra-Trees-Model" class="headerlink" title="Extra Trees Model"></a>Extra Trees Model</h2><p><strong>Random Forest Model</strong>과 그 변종인 <strong>Extra Trees Model</strong>을 이번 기회에 다시 공부해볼 수 있었다.</p><p>두 모델은 기본적으로 <strong>결정트리</strong>Decision Tree 기반이지만, 트리를 생성할 feature을 고르는 방식에서 차이점이 있다. 랜덤 포레스트는 트리 하나를 생성할 때 모든 feature에서 임의로 몇 개를 선택하고 그 중 정보획득량을 기준으로 분할을 생성한다. 그러나 고려해야 할 feature의 개수가 많아지면 최적의 분할을 찾는 데 시간을 많이 소모한다.</p><p>엑스트라트리는 여기서 분할하는 feature을 무작위로 나누어서, 트리를 훨씬 빠르게 구성한다. 만약 하나의 결정 트리에서 이렇게 한다면 성능이 낮아지겠지만, 빨라진 계산 속도를 바탕으로 더 많은 트리를 앙상블 하기 때문에 Overfitting을 막고 검증 세트의 점수를 높이는 효과가 있다.</p><p>두 모델의 하이퍼파라미터는 거의 동일한데, <code>ExtraTreesRegressor</code>의 주요 하이퍼파라미터는 다음과 같다.</p><br><ul><li><code>n_estimators</code> (default &#x3D; 100) : 엑스트라 트리 안의 결정 트리 갯수<br>결정 트리가 많을수록 더 깔끔한 Decision Boundary가 나오므로 n_estimators는 클수록 좋으나, 과해지면 overfitting의 우려가 있으며 메모리와 훈련 시간이 증가한다.</li><li><code>max_depth</code> : 트리의 최대 깊이</li><li><code>min_samples_split</code> (default &#x3D; 2) : 노드를 분할하기 위한 최소한의 샘플 데이터 수</li><li><code>min_samples_leaf</code> (default &#x3D; 1) : 리프노드가 되기 위한 최소한의 샘플 데이터 수</li><li><code>max_features</code>: 무작위로 선택할 Feature의 개수<br><code>sqrt</code>이면 <code>max_features = sqrt(n_features)</code><br><code>log2</code>이면 <code>max_features = log2(n_features)</code><br><code>default</code>값은 <code>max_features = n_features</code> - feature 모두에서 비복원 추출로 선택해 결정 트리를 만든다.<br>max_features 값이 크면 랜덤 포레스트의 트리들이 매우 비슷해지고, 가장 두드러진 특성에 맞게 예측을 할 것이다.<br>max_features 값이 작으면 랜덤 포레스트의 트리들이 서로 상이해져 Overfitting이 줄어들 것이다다.</li></ul><blockquote><p><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.ExtraTreesRegressor.html">sklearn.ensemble.ExtraTreesRegressor Official Docs</a></p></blockquote><hr><h1 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h1><p>실제 제출했던 코드로 리뷰를 했다면 더 좋았겠지만, 대회 종료 후 컨테이너에 접근이 막혀서 기억에 의존해서 복기하며 리뷰를 했던게 아쉽다. ML 전문가 친구가 추천해준 LightGBM도 사용해보고 싶었으나, 파이썬 역량과 제출 기한의 문제로 다음에 사용해보기로 했다.</p><blockquote><p>본 자료는 SSDC-KATUSA ML&#x2F;DL팀 Weekly Scrum 자료로 사용되었습니다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;
&lt;!-- toc --&gt;

&lt;br&gt;
&lt;div class=&quot;figure &quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://i.imgur.com/Ua5sYEA.png&quot; title=&quot;&quot;</summary>
      
    
    
    
    <category term="Machine Learning" scheme="https://oxcarxierra.github.io/categories/Machine-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 12월 회고</title>
    <link href="https://oxcarxierra.github.io/Review/2022/december-2022-review/"/>
    <id>https://oxcarxierra.github.io/Review/2022/december-2022-review/</id>
    <published>2022-12-31T01:24:08.000Z</published>
    <updated>2022-12-31T01:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>2022년의 마지막 한 달, 그리고 내일이면 전역의 해 2023년이 온다.</p><p>크리스마스 주간에 Elice에서 AI MINI 경진대회를 진행하길래, 참여에 의미를 두려고 시작했는데 결국 7등까지 올라가버렸다. 예전에 Kaggle 자전거 수요 예측 실습에서 사용했던 RandomForestRegressor를 그대로 사용했더니 예상치 못하게 높은 점수가 한 번에 떠준 덕분이었다. 거기다가 약간의 하이퍼파라미터 튜닝을 통해서 결과값을 2.0정도 높일 수 있었다.<br>솔직히 운이 좋았던 것도 있지만, 초보적인 모델을 사용하거나 사용하는 모델에 대한 완벽한 이해가 선행되지 않아도 ML 대회에서 나름 고득점이 가능하겠다는 자신감을 얻은 좋은 경험이었던 것 같다. Dacon, Kaggle 찍먹을 (드디어) 본격적으로 시작할수 있으려나?</p><p>MVP로써 구상한 크롬 익스텐션 하나를 Chrome Web Store에 배포했다. 항상 누군가 만든 프레임워크(특히 React)만 사용하다가, 브라우저와 직접적으로 통신해야 하는 익스텐션을 javascript로 개발하니 생각만큼 쉬운 일은 아니었다. 이제 유저층 확보하고 시장의 반응을 살펴봐야 하는데, 우리 팀의 노력만큼 사람들이 관심을 가져주지 않을까봐 걱정이다.</p><p>&lt;아이디어 불패의 법칙&gt;에서는 아이템을 보는 시각을 냉정하게 유지하라고 말한다. 머릿속의 “생각랜드”에서는 그 어떤 아이디어도 “시장 불패의 법칙”을 뚫고 성공할 수 있을 것처럼 보이기 때문이다. 수 많은 “안 될 놈”들 중 “될 놈”을 구분해내는 건 내가 직접 조사해서 수집한 시장의 “데이터” 뿐이다.</p><p>그놈의 연말이 뭔지 자꾸 사람을 무기력하게 만든다… 운동도 꾸준히 못하고, 매주 한 주차씩 들으려던 Coursera DeepLearning Specialization 코스도 조금씩 밀렸다. 새해 의미부여하는건 더 싫은데, 다음 달부턴 새로운 마음으로 낭비되는 시간을 줄여봐야겠다.</p><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><ul><li><strong>&lt;비전공자도 이해할 수 있는 AI지식&gt;</strong>, 박상길 (진중문고)</li><li><strong>&lt;아이디어 불패의 법칙&gt;</strong>, 알베르트 사보이아</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2022년의 마지막 한 달, 그리고 내일이면 전역의 해 2023년이 온다.&lt;/p&gt;
&lt;p&gt;크리스마스 주간에 Elice에서 AI MINI 경진대회를 진행하길래, 참여에 의미를 두려고 시작했는데 결국 7등까지 올라가버렸다. 예전에 Kaggle 자전거 </summary>
      
    
    
    
    <category term="Review" scheme="https://oxcarxierra.github.io/categories/Review/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 11월 회고</title>
    <link href="https://oxcarxierra.github.io/Review/2022/november-2022-review/"/>
    <id>https://oxcarxierra.github.io/Review/2022/november-2022-review/</id>
    <published>2022-11-30T11:37:11.000Z</published>
    <updated>2022-11-30T11:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>OSAM 해커톤에서 <strong>과학기술정보통신부 장관상</strong>을 받으며 잘 마무리했다. 내년 대회에 참여할 다른 사람이 참고할 수 있도록 후기도 작성해보았다.</p><p>Coursera에 올라와 있는 <strong>Deep Learning Specialization Course</strong>에 Financial Aid를 신청하고, 5개의 코스 중 첫 번째인 <strong>Neural Networks and Deep Learning</strong>을 모두 수강했다. 인공 신경망의 구조와 기초적인 수학 이론이 주를 이뤘고, submission 과제를 통해 numpy, pandas 사용법을 복습할 수 있었다.</p><p>시니어 카투사 달고 배럭 이사도 한 이후로 시간 효율성이 급격하게 떨어진 느낌이다. 퇴근을 3-4시에 하니까, 저녁 먹는 시간을 빼고도 밤에 잠드는 12시, 1시까지 시간이 정말 많은데 왜 이렇게 의미 없이 흘러가는지 모르겠다. 과제를 급하다고 생각하지 않다 보니까 목표의식이 많이 떨어지는 것 같고, 새로운 task에 마주하면서 스스로 해결하는게 귀찮아진 것 같다. 운동도 좀 꾸준히 해보고, 어디에서라도 동기부여를 좀 받아와야 할 것 같다.</p><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><ul><li><strong>&lt;부의 추월차선&gt;</strong>, 엠제이 드마코<br>… 읽다 말았다. 뒤로 갈수록 대부분 동어 반복이며 자기모순적인 내용이 많다.</li><li><strong>&lt;경제기사 궁금증 300문 300답&gt;</strong> - 곽해신 (진중문고)</li><li><strong>&lt;존리의 금융문맹 탈출&gt;</strong> - 존리 (진중문고)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OSAM 해커톤에서 &lt;strong&gt;과학기술정보통신부 장관상&lt;/strong&gt;을 받으며 잘 마무리했다. 내년 대회에 참여할 다른 사람이 참고할 수 있도록 후기도 작성해보았다.&lt;/p&gt;
&lt;p&gt;Coursera에 올라와 있는 &lt;strong&gt;Deep Lear</summary>
      
    
    
    
    <category term="Review" scheme="https://oxcarxierra.github.io/categories/Review/"/>
    
    
  </entry>
  
  <entry>
    <title>[React] Library not loaded: @rpath/hermes.framework/hermes 에러</title>
    <link href="https://oxcarxierra.github.io/Development/react-build-hermes-error/"/>
    <id>https://oxcarxierra.github.io/Development/react-build-hermes-error/</id>
    <published>2022-11-21T12:29:08.000Z</published>
    <updated>2022-11-21T12:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>React Native 0.70.0 이상으로 업데이트 하면서 새로운 프로젝트 빌드 시에 build success 후 시뮬레이터에서 튕기는 오류를 겪었다. 해결 방법은 아래와 같다.</p><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/zwdiQV5.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/zwdiQV5.png" alt=""></a></div><div style="clear:both;"></div><p>xcode &gt; build phases &gt; Link binary with Libraries 메뉴에 hermes.xcframework 추가</p><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/ksgRFIN.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/ksgRFIN.png" alt=""></a></div><div style="clear:both;"></div><p>xcode &gt; General &gt; Frameworks, Libraries, and Embedded Content 에 hermes.xcframework 추가 후 Embed &amp; Sign</p><blockquote><p><a href="'https://github.com/facebook/react-native/issues/34601'">Github - Library not loaded: @rpath&#x2F;hermes.framework&#x2F;hermes on iOS #34601</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;p&gt;React Native 0.70.0 이상으로 업데이트 하면서 새로운 프로젝트 빌드 시에 build success 후 시뮬레이터에서 튕기는 오류를 겪었다. 해결 방법은 아래와 같다.&lt;/p&gt;
&lt;br /&gt;

&lt;div c</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[2022 군장병 공개 SW 온라인 해커톤] 과학기술정보통신부 장관상 수상 후기</title>
    <link href="https://oxcarxierra.github.io/Review/2022/army-hackathon-review/"/>
    <id>https://oxcarxierra.github.io/Review/2022/army-hackathon-review/</id>
    <published>2022-11-14T10:41:15.000Z</published>
    <updated>2022-11-14T10:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/65y7cjS.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/65y7cjS.png" alt=""></a></div><div style="clear:both;"></div><h2 id="해커톤-참가"><a href="#해커톤-참가" class="headerlink" title="해커톤 참가"></a>해커톤 참가</h2><p><a href="https://osam.kr/">국방오픈소스아카데미(OSAM) 홈페이지</a>를 해커톤 이전에 발견을 해서, 2022년 해커톤도 열리기를 기대하고 있던 중에 대회 공고가 올라왔고 자연스럽게 참여하게 되었다.</p><h2 id="참가자-선발-과정"><a href="#참가자-선발-과정" class="headerlink" title="참가자 선발 과정"></a>참가자 선발 과정</h2><p>해커톤에 참여하려면 <strong>온라인 평가</strong>, <strong>코딩 테스트</strong>, <strong>개발 계획서</strong> 이렇게 세 가지의 과제를 제출해야 했고, 각각 성적이 <code>50%</code>,<code>25%</code>,<code>25%</code>씩 반영된 선발 점수로 최종 해커톤 참여자 150명 내외를 선정하는 방식이었다.</p><h3 id="1-온라인-평가"><a href="#1-온라인-평가" class="headerlink" title="1. 온라인 평가"></a>1. 온라인 평가</h3><p>온라인 평가는 각 분야별 필수 강의를 듣고 그 강의에 관련된 시험을 보는 형태였다. 제한시간은 1시간, 총 40문제가 출제되었었다. 선택할 수 있는 분야는 <code>WEB</code>,<code>APP</code>,<code>IoT</code>,<code>Cloud</code> 총 4개가 잇었다. 내가 선택했던 APP 분야는 Dart 언어를 사용하는 Front-end 라이브러리 Flutter를 중점으로 했고, 플러터 초급∙중급∙고급 강좌를 필수적으로 이수해야 했다. 평가는 강의에서 나온 자료가 거의 그대로 나왔던 것 같다. 다만 막상 풀 때는 다 아는 내용이라고 생각했지만 결과를 확인해보니 95점이었다. 두 문제를 어디서 틀렸는지 아직도 모르겠다.<br>(<em>사실 문제를 풀면서 구글링도 가능하기 때문에 1시간을 적당히 잘 분배해서 검색의 기회를 적당히 활용하는것도 좋다고 생각한다.</em>)</p><h3 id="2-코딩-테스트"><a href="#2-코딩-테스트" class="headerlink" title="2. 코딩 테스트"></a>2. 코딩 테스트</h3><p>사실상 이 코딩테스트를 준비하기 위해 알고리즘 공부를 한 달 넘게 했다. <a href="https://programmers.co.kr/">프로그래머스</a>의 코딩테스트 환경으로 2시간 동안 총 4문제를 풀게 되는데, 이쪽으론 비전공자였던 내가 다 풀기에는 조금 어려운 난이도였다. 백준으로 따지면 1번은 <code>실버 4</code>, 2번은 <code>실버 1</code>, 3~4번은 <code>골드 1</code>정도의 난이도였던 것 같다. 사실 그렇게 어려운 알고리즘이 나온 건 아닌데, 문제 자체가 너무 더럽고 생각치 못한 예외 케이스들이 있어서 코드 양이 많이 길어질 수 밖에 없었던 것 같다. 난 결과적으로 1,2번 모두 풀고 3번은 패스, 4번을 절반 정도 점수를 받아서 최종 점수는 400점 만점에 254점이었다. 사실 알고리즘을 이번에 처음 입문을 하고 짧은 시간동안 압축해서 공부를 하자니 이론적인 부분은 많이 배웠어도, 실전 코딩테스트에서 좋은 성적이 나오려면 문제를 많이 풀어보는게 가장 좋은 것 같다.<br>참고로, 해커톤과 별개인 <strong>코딩경진대회</strong>는 이 코딩 테스트의 점수가 가장 높은 6명에게 시상과 상품을 준다. 이번 1등 상품은 iPad Air정도였으니, 부상이 꽤 쏠쏠하다. 다만 상위 3명은 모두 만점이라 해결 시간이 짧았던 순서로 순위가 정해졌고, 6등 커트라인이 322점이었으니 수상하려면 최소 백준 플레티넘 정도는 되야하지 않을까 싶다.</p><h3 id="3-개발-계획서"><a href="#3-개발-계획서" class="headerlink" title="3. 개발 계획서"></a>3. 개발 계획서</h3><p><strong>병영생활 및 국방에서 활용 가능한 창의적인 아이디어</strong>라는 대주제 안에서 본인이 해커톤에 진출했을 때 진행할 프로젝트의 구체적인 개발 계획서를 작성하는 과제였다. 물론 나중에 본인의 주제를 포기하고 다른 사람의 주제에 모여서 팀 빌딩을 할 수 있다는 걸 알고있었어서, 많은 노력을 들이지는 않았다.</p><h3 id="4-선발-결과"><a href="#4-선발-결과" class="headerlink" title="4. 선발 결과"></a>4. 선발 결과</h3><p>생각만큼 대회 경쟁률이 그렇게 빡세지 않아서 코딩테스트 점수가 기대에 못 미쳤던 나도 안정권으로 본선에 진출할 수 있었던 것 같다. 해커톤 참가자로 선발된 이후에는 별도의 탭에서 팀 빌딩 기능과 커뮤니티 게시판을 이용할 수 있게된다. 그래서 다른 참가자들의 개발 계획서도 볼 수 있었는데, 개발계획서가 빈칸인데도 선발된 사람도 있었다. 참가자 수가 그만큼 적어서 개발계획서를 완성하지 못해도 선발했던 것 같은데, 그럼 굳이 코딩테스트 준비나 개발계획서를 열심히 할 필요가 없었을 수도 있겠다는 생각도 들었다.</p><h2 id="팀-빌딩-과정"><a href="#팀-빌딩-과정" class="headerlink" title="팀 빌딩 과정"></a>팀 빌딩 과정</h2><p>팀 빌딩 기간이 시작되면 내 프로젝트에 필요한 구체적인 포지션과 인원수를 설정할 수 있게 된다. 그래서 다른 사람들의 개발 계획서를 보면서 참여하고 싶은 주제가 생기면 본인의 것을 포기하고, 비어있는 포지션에 참여 신청을 넣으면 되는 방식으로 진행된다. 나는 고등학교 동기가 팀장을 맡은 <strong>군 법규 도우미</strong> 프로젝트에 Frontend 파트로 참여하기로 했다. 실제로 육군 규정과 국방부 규정으로 정해진 사항임에도 불구하고 군인들이 잘 몰라서 억울한 일을 당해도 항의나 보상 요구를 하지 못하는 경우가 많다는데 공감했기 때문이다.<br>팀빌딩으로 실력 있는 분들이 들어오셔서 총 7명의 팀이 꾸려졌고, 현업에서 일하시는 능력있는 멘토분도 배정받게 되었다. 그 이후로 우리 팀이 목표한 아이디어를 구현하고 본격적으로 개발할 수 있는 1달이라는 시간이 주어졌다.</p><h2 id="온라인-해커톤-및-프로젝트-진행"><a href="#온라인-해커톤-및-프로젝트-진행" class="headerlink" title="온라인 해커톤 및 프로젝트 진행"></a>온라인 해커톤 및 프로젝트 진행</h2><p>팀원 모두가 현역 병사다 보니 훈련 일정도 있고, 남는 개인정비 시간을 쪼개가며 참여했던 해커톤이라 협업하기가 쉽지만은 않았다. 또, 싸지방 컴퓨터로 온라인 IDE를 사용해야 하는 등 열악한 개발환경의 문제도 있었다. 나도 외박 나가있는 동안은 거의 모든 시간을 개발에 쏟아부었던 것 같다.<br>멘토님으로부터 전해받은 몇 가지 팁을 남겨놓자면,</p><ol><li><strong>최종 평가는 발표자료(프레젠테이션)과 시연영상으로만 진행된다.</strong><br>데모에 자잘한 오류가 있더라도, 시간이 없으면 영상에 드러나지 않을 정도로만 수정하는 것도 좋다. 또한 발표는 멘토가 진행하셨기 때문에, 팀이 전하고자 하는 메세지를 프레젠테이션에 최대한 많이 담아야 한다.</li><li><strong>병사 개개인을 타겟으로 한 주제보다, 전체적인 ‘군’에 도움을 줄 수 있는 주제가 좋다.</strong><br>이 프로젝트로써 군의 어떤 문제를 긍정적으로 해결할 수 있는지가 강조되어야 한다.</li><li><strong>개발문서 (Github <code>README.md</code> 포함) 를 구체적으로 쓰고, 이미지를 많이 첨부하면 좋다.</strong><br>우리 팀의 경우에는 <code>GitBook</code>도 활용해서, 미처 시연영상에 담지 못한 내용까지 상세히 설명해 두었다.</li></ol><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><ol><li><p>군 생활동안 대회에서 의미있는 상을 하나 정도는 받고 싶었는데, 육군창업경진대회마저 광탈하면서 아쉬웠던 터라 과기부 장관상(1등상)은 믿기 어려울 정도로 뿌듯한 소식이었다. 또 처음으로 참여해본 해커톤 형식의 대회였는데(사실 무박2일, 2박3일로 진행되는 대부분의 해커톤과는 조금 다르지만) 좋게 끝나서 다행이다. Expo, React-Query같은 새로운 기술 스택도 배울 수 있었고, 인사이트를 공유할 좋은 팀원들도 만날 수 있었다. 이런 분들과 협업하면서 완성이라는 하나의 목표를 위해 다 같이 고민하고 해결해나갔던 과정 자체가 참 재미있어서, 대회를 준비하는 한 달 남짓 시간동안 행복했던 것 같다.</p></li><li><p>요즘 군대가 많이 좋아졌다고들 하지만, 아직도 여러 군인이 부대 내 선임 ∙ 상관으로부터의 부조리, 성추행, 괴롭힘으로 정신적 피해를 호소하고 극단적인 선택을 한다. 몇몇 지휘관은 본인의 출세를 위해 덮고 숨기기 급급하며, 수사는 물론 배상조차 제대로 진행되지 못하는 경우가 다반수다. 이런 이슈가 터지고 뉴스를 볼 때마다, 원했던 원하지 않았던 국방의 의무를 다하기 위해 입대한 사람들이 대체 왜 이런 비극을 겪어야 했는지 분노하지 않을 수 없었다. 그리고 모두가 가만히 있으면 아무것도 바뀌지 않기에, 여느 ‘냄비근성’처럼 외면하면서 넘어가고 싶지 않았다. 해커톤에 제출한 하나의 데모 앱에 불과하겠지만, 나는 나만의 방식으로 이 문제를 해결하기 위해 고민했고 노력했다는 사실에 의미를 두고 싶다. 그리고 작은 변화의 바람이라도 함께하는 사람들이 많아지고 군 수뇌부부터 노력한다면, 조준우 일병, 이예람 중사같은 사고가 이제는 다시 일어나지 않을 수 있을 것이다.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;!-- toc --&gt;

&lt;br /&gt;
&lt;div class=&quot;figure center fig-100&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://i.imgur.com/65y7</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>[React] Axios를 React Hook으로 사용하기</title>
    <link href="https://oxcarxierra.github.io/Development/use_axios_as_react_hook/"/>
    <id>https://oxcarxierra.github.io/Development/use_axios_as_react_hook/</id>
    <published>2022-11-05T13:03:24.000Z</published>
    <updated>2022-11-05T13:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><p>그동안은 axios를 그냥 import해서 사용했는데, 이렇게 <code>useAxios()</code> 커스텀 훅을 만들어서 사용하면 에러 처리나 baseUrl에 대한 전처리를 쉽게 해줄 수 있다.</p><figure class="highlight ts"><figcaption><span>useAxios.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> extra <span class="keyword">from</span> <span class="string">&#x27;@utils/extra&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosError</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useAtomValue &#125; <span class="keyword">from</span> <span class="string">&#x27;jotai&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useAxios</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useAtomValue</span>(userAtom);</span><br><span class="line">  <span class="keyword">const</span> axiosInstance = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">      <span class="attr">baseURL</span>: yourBackendBaseURL,</span><br><span class="line">    &#125;); <span class="comment">// Axios Instance 생성</span></span><br><span class="line">    instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">async</span> (config) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">await</span> yourToken; <span class="comment">// header에 들어갈 token 받아오기</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">          ...(config.<span class="property">headers</span> ?? &#123;&#125;),</span><br><span class="line">          <span class="title class_">Authorization</span>: token,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="literal">undefined</span>, <span class="keyword">async</span> (value) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">AxiosError</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">          <span class="string">`AxiosError(<span class="subst">$&#123;value.response?.status&#125;</span>/<span class="subst">$&#123;value.code&#125;</span>): <span class="subst">$&#123;value.message&#125;</span>\n<span class="subst">$&#123;value.response?.data&#125;</span>`</span></span><br><span class="line">        ); <span class="comment">// 에러 출력</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">response</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;, [user]);</span><br><span class="line">  <span class="keyword">return</span> axiosInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useAxios;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;useAxios()&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>2022년 10월 회고</title>
    <link href="https://oxcarxierra.github.io/Review/2022/october-2022-review/"/>
    <id>https://oxcarxierra.github.io/Review/2022/october-2022-review/</id>
    <published>2022-11-03T07:18:39.000Z</published>
    <updated>2022-11-03T07:18:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>육군창업경진대회는 본선 탈락했다. 나름 열심히 준비해서 본선은 갈 줄 알았는데, 아쉬움이 좀 남는다. 아이템이 대회의 컨셉과 안맞는 부분도 있었던 것 같고, 처음으로 준비해 본 창업 경진대회라서 노하우가 부족했던 것 같다.</p><p>10월 한 달 내내 국방 해커톤 프로젝트에 집중한 결과 데모 앱을 기획대로 다 개발했고, 출품까지 잘 마무리했다. 팀원이 7명으로 꽤 많은 데다 다들 역량이 뛰어나셔서, 처음에 불가능해 보일 정도로 많았던 태스크를 모두 끝낼 수 있었던 것 같았다. 그치만 그만큼 협업에서의 어려움이 조금 느껴졌다. 아무래도 다들 열악한 환경에서 개인정비 시간 쪼개가며 참여하는 프로젝트이다 보니까 소통이나 진행 순서에서 꼬이는게 좀 있었다.<br>별개로, 우리 팀의 프로젝트가 군 내 인명피해와 사건사고를 막기 위한 솔루션이라는 점에서 큰 의미가 있었던 것 같다. 종종 군인이 자살했다는 뉴스를 들으면 안타까웠었는데, 그저 연민으로 끝내지 않고 내가 할 수 있는 방법으로 행동에 옮겼다는 뿌듯함이 남았다. 수상까지 하면 완벽할 것 같다.</p><p>책은 많이 못 읽었다. &lt;데미안&gt;이랑 경제 관련 책을 읽는 중인데, 11월에 다 읽어야겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;p&gt;육군창업경진대회는 본선 탈락했다. 나름 열심히 준비해서 본선은 갈 줄 알았는데, 아쉬움이 좀 남는다. 아이템이 대회의 컨셉과 안맞는 부분도 있었던 것 같고, 처음으로 준비해 본 창업 경진대회라서 노하우가 부족했던 </summary>
      
    
    
    
    <category term="Review" scheme="https://oxcarxierra.github.io/categories/Review/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>[React] Luxon.js 라이브러리로 날짜/시간 포맷팅하기</title>
    <link href="https://oxcarxierra.github.io/Development/using-luxon-js/"/>
    <id>https://oxcarxierra.github.io/Development/using-luxon-js/</id>
    <published>2022-10-23T14:35:03.000Z</published>
    <updated>2022-10-23T14:35:03.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>Backend에서 시간에 대한 정보가 담긴 데이터를 보내주는 유형은 다양하다. 일반적으로 js, ts에 존재하는 <code>Date</code> type으로 오거나, 한 번 처리해서 <code>202310232335</code>처럼 <code>string</code> type으로 오기도 한다. 또는 <code>10343904</code>같은 <code>number</code> type으로 오기도 하는데, 이 경우는 <code>1970.01.01 00:00:00 UTC</code>를 기준으로 지난 시간을 millisec의 단위로 표시한 것이다. (참고: <a href="https://currentmillis.com/">여기</a>에서는 현재 시간을 millisec 단위로 알려준다.)</p><p>Frontend 단에서 이 데이터를 <code>OOOO년 OO월 OO일 OO:OO</code> 같은 형식으로 바꿔줄 때, 지금까지는 <code>Date.getDate()</code>같은 함수를 이용해서 새로운 함수를 정의해서 썼었다. 그러나 luxon.js의 <code>DateTime</code>을 이용하면 포맷팅을 아주 쉽게 할 수 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DateTime</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;luxon&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DateTime</span>.<span class="title function_">fromMillis</span>(time * <span class="number">1000</span>).<span class="title function_">toFormat</span>(<span class="string">&#x27;yyyy.MM.dd  hh:mm&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `toFormat()`함수를 이용해 내가 원하는 string 형식으로 변환할 수 있다.</span></span><br></pre></td></tr></table></figure><p>아래 공식문서를 참고해보면 이 외에도 유용한 기능이 많다.</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><a href="https://www.npmjs.com/package/luxon">npmjs</a></li><li><a href="https://moment.github.io/luxon/api-docs/index.html">Github Docs</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;p&gt;Backend에서 시간에 대한 정보가 담긴 데이터를 보내주는 유형은 다양하다. 일반적으로 js, ts에 존재하는 &lt;code&gt;Date&lt;/code&gt; type으로 오거나, 한 번 처리해서 &lt;code&gt;20231023233</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Dart 기초 문법</title>
    <link href="https://oxcarxierra.github.io/Development/basics-of-dart/"/>
    <id>https://oxcarxierra.github.io/Development/basics-of-dart/</id>
    <published>2022-10-07T13:13:45.000Z</published>
    <updated>2022-10-07T13:13:45.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="변수형"><a href="#변수형" class="headerlink" title="변수형"></a>변수형</h2><ul><li><p>정수형 Number</p></li><li><p>문자열 String<br>문자열 내 변수 value - ‘$value’</p></li><li><p>불리안 bool</p></li><li><p>true, false (소문자임에 주의!)</p></li><li><p>타입 미지정 var, dynamic</p></li></ul><p>dynamic 타입으로 선언되면 할당되는 변수에 따라 타입이 바뀐다.</p><h2 id="리스트-List-lt-type-gt"><a href="#리스트-List-lt-type-gt" class="headerlink" title="리스트 List &lt;type&gt;"></a>리스트 List &lt;type&gt;</h2><ul><li>growable list : 길이가 무한히 늘어날 수 있다.</li><li>ungrowable list의 선언 :<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new</span> <span class="built_in">List</span>(n);</span><br><span class="line"><span class="built_in">List</span> list_2 = <span class="keyword">new</span> <span class="built_in">List</span>.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li>길이는 list.length</li></ul><h2 id="Map-해쉬"><a href="#Map-해쉬" class="headerlink" title="Map 해쉬"></a>Map 해쉬</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, type&gt; dictionary = &#123;</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">dictionary.keys.toList()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>final, const - 한 번만 선언하도록 설정, 차이점은 const는 compile time에 할당이 되어있어야 하고, final은 runtime에 지정</li><li>Enum - 커스텀 변수형</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status = &#123;approved, rejected, pending&#125;</span><br></pre></td></tr></table></figure><ul><li>typedef 함수를 변수처럼 사용가능하게 함.</li></ul><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><p>??&#x3D; : null인 경우 할당</p><p>&#x2F; 계산하면 double형으로 할당</p><p>is <type> , !is <type></p><h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>class변수는 instance라고 부른다.</p><p>constructor의 이름은 변수이름과 같다.</p><ul><li><p>Constructor의 선언</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">String</span> id;</span><br><span class="line"></span><br><span class="line">    ClassName(&#123;</span><br><span class="line">        <span class="built_in">String</span> name, <span class="built_in">String</span> id,</span><br><span class="line">    &#125;) : <span class="keyword">this</span>.name = name, <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Named Constructor</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//선언방법</span></span><br><span class="line">ClassName.constructorName() :</span><br></pre></td></tr></table></figure></li><li><p>class의 Getter와 setter<br>class 내에서 선언하는 변수들은 _name 언더스코어로 시작. private variable이라고 부른다.<br>private variable은 외부에서 접근 불가. 그래서 getter, setter을 선언해준다</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Idol</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> _name;</span><br><span class="line">    <span class="built_in">String</span> _group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(<span class="built_in">String</span> newname)&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = newname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="클래스의-상속"><a href="#클래스의-상속" class="headerlink" title="클래스의 상속"></a>클래스의 상속</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span></span>&#123;</span><br><span class="line">    ChildClass(</span><br><span class="line"></span><br><span class="line">    ): <span class="keyword">super</span>( <span class="comment">// super은 부모클래스의 인스턴스를 지칭.</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>부모 클래스의 인스턴스, 메소드 모두를 상속받음. 부모는 자식의 인스턴스와 자식을 상속받지 않음.</p><p>부모 클래스는 두개 이상이 될 수 없다. 하나의 클래스의 자식 클래스는 여러개가 될 수 있다.</p><h3 id="메소드-오버라이딩"><a href="#메소드-오버라이딩" class="headerlink" title="메소드 오버라이딩"></a>메소드 오버라이딩</h3><p>자식클래스에서 메소드를 다시 작성</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span> <span class="comment">// decorator</span></span><br><span class="line"><span class="comment">//이름은 같으면서 새로 쓴 메소드</span></span><br></pre></td></tr></table></figure><h3 id="static-키워드"><a href="#static-키워드" class="headerlink" title="static 키워드"></a>static 키워드</h3><p>하나의 클래스 내에 공유되는 변수가 있다면 <code>static</code>으로 선언해준다.</p><h3 id="Interface-키워드"><a href="#Interface-키워드" class="headerlink" title="Interface 키워드"></a>Interface 키워드</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdolInterface</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">void</span> sayName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoyGroup</span> <span class="keyword">implements</span> <span class="title">IdolInterface</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">void</span> sayName()&#123;</span><br><span class="line">        <span class="comment">//something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스의 형식을 지정해주는 인터페이스</p><h3 id="Cascade-Operator"><a href="#Cascade-Operator" class="headerlink" title="Cascade Operator"></a>Cascade Operator</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Idol</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">String</span> group;</span><br><span class="line">    <span class="keyword">void</span> sayName()&#123;&#125;;</span><br><span class="line">    <span class="keyword">void</span> sayGroup()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Idol idol = <span class="keyword">new</span> Idol(<span class="string">&#x27;이름&#x27;</span>,<span class="string">&#x27;그룹&#x27;</span>);</span><br><span class="line">idol.sayName();</span><br><span class="line">idol.sayGroup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Idol(<span class="string">&#x27;이름&#x27;</span>,<span class="string">&#x27;그룹&#x27;</span>)</span><br><span class="line">    ..sayname()</span><br><span class="line">    ..sayGroup();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;!-- toc --&gt;

&lt;h2 id=&quot;변수형&quot;&gt;&lt;a href=&quot;#변수형&quot; class=&quot;headerlink&quot; title=&quot;변수형&quot;&gt;&lt;/a&gt;변수형&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;정수형 Number&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 4분기 OKR</title>
    <link href="https://oxcarxierra.github.io/Review/2022/2022-4q-okr/"/>
    <id>https://oxcarxierra.github.io/Review/2022/2022-4q-okr/</id>
    <published>2022-10-02T01:50:18.000Z</published>
    <updated>2022-10-02T01:50:18.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><ol><li><strong>경진대회 준비</strong></li><li><strong>꾸준한 자기개발</strong></li><li><strong>사이드 프로젝트</strong></li></ol><h2 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h2><ol><li><strong>경진대회 준비</strong></li></ol><ul><li>2022 OSAM 국방 해커톤 입상</li><li><del>제 8회 육군창업경진대회 본선 진출 및 수상</del> (탈락)</li></ul><ol start="2"><li><strong>꾸준한 자기개발</strong></li></ol><ul><li>책 7권 읽기 (경제∙금융 분야 포함)</li><li>운동(농구 헬스 포함) 일주일에 3번 이상 하기</li></ul><ol start="3"><li><strong>사이드 프로젝트</strong></li></ol><ul><li>USFK Bus 앱 업데이트 및 Playstore 배포</li><li>신규 사이드프로젝트 시작하기?</li></ul><blockquote><p>목표가 생기거나 바뀔 때 마다 OKR은 유연하게 수정해도 됨!</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;Objectives&quot;&gt;&lt;a href=&quot;#Objectives&quot; class=&quot;headerlink&quot; title=&quot;Objectives&quot;&gt;&lt;/a&gt;Objectives&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;경진대회 준비&lt;/s</summary>
      
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 9월 회고</title>
    <link href="https://oxcarxierra.github.io/Review/2022/september-2022-review/"/>
    <id>https://oxcarxierra.github.io/Review/2022/september-2022-review/</id>
    <published>2022-09-29T17:17:42.000Z</published>
    <updated>2022-09-29T17:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>9월엔 포데이 3번에, 2박 3일 휴가까지 써서 부대보다 사회에 있었던 시간이 더 많았다. <del>이게 군인이 맞냐?</del> 그치만 시간을 효율적으로 잘 보냈냐고 물어보면 잘 모르겠다.. 사람도 많이 만나고 개인적으로 재충전하느라 공부는 많이 못했다. 이럴 때 쉬어줘야지 느낌으로 자기합리화하는중.</p><br><ul><li><strong>군장병 공개SW 온라인 해커톤 본선</strong>에 진출했다. 9&#x2F;7에 참가자 발표가 났고, 나는 고등학교 친구가 낸 주제에 팀원으로 합류했다. 다른 장병분들도 주제를 보고 지원해 주셔서 총 7명의 거대 팀을 구성할 수 있었다. 모인 분들의 스펙이 대단하셔서 엄청 놀랐다.. 자세한 후기는 <a href="">OSAM 해커톤 후기</a>로 따로 포스팅할 생각이다. 이제 구체적인 기획을 마무리하고 내가 맡은 Front-End 쪽 개발에 집중할 계획이다. 그런데 마지막으로 받았던 피드백에서 주제가 대차게 까여서 어떻게 방향을 틀어야 할지 좀 고민이 돤다 ㅎㅎ..</li></ul><br><ul><li><strong>제 8회 육군창업경진대회</strong>를 2~3주 빡세게 준비해서 접수를 해놓은 상태다. 2주 뒤에 예선 결과발표가 나는데, 본선 진출만 해도 포상휴가라는 말에 시작한 대회였으니 제발 본선만이라도 갔으면 좋겠다. 지금 육군으로 복무중인 고등학교 친구 군바리 둘이랑 팀을 짜서, 몇 주 전부터 여러 아이디어를 내고 서로 피드백도 해주면서 나온 가장 괜찮은 아이템 하나로 develop하고 접수를 했다. 하나 걱정되는 건 아무래도 육군에서 주관하는 경진대회이다 보니 기술성을 많이 보고 특히 군과 관련된 아이템이 좋은 점수를 받는다고 하는데 우리 아이템이 그쪽은 아니라는거… 암튼 이번 기회에 유튜브로 Figma를 독학해서 프로토타입을 제작하는 데에 사용해봤다. 컴포넌트를 지정하고 그 variation을 만드는 기능이 아주 유용했고, 전반적으로 Adobe XD보다 사용하기 편했던 것 같다. 이제 UI&#x2F;UX Design + Front-End 개발을 같이 할 수 있다고 어디가서 말할 수 있을 것 같다.</li></ul><br><ul><li><strong>제로 투 원</strong>을 읽으며 인사이트를 얻을 수 있었다. 독점적 스타트업이 되야하는 이유, 기하급수적 성장의 중요성, 20-80 법칙, 작은 시장부터 독점하는 방법, 경쟁과 자본주의의 근본적 차이점.</li></ul><hr><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><ul><li><strong>&lt;제로 투 원&gt;</strong> - 피터 틸</li><li><strong>&lt;1Q84 #3&gt;</strong> - 무라카미 하루키</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;9월엔 포데이 3번에, 2박 3일 휴가까지 써서 부대보다 사회에 있었던 시간이 더 많았다. &lt;del&gt;이게 군</summary>
      
    
    
    
    <category term="Review" scheme="https://oxcarxierra.github.io/categories/Review/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>[React] Expo 이용해서 React Native 앱 시작하기</title>
    <link href="https://oxcarxierra.github.io/Development/starting-expo-app/"/>
    <id>https://oxcarxierra.github.io/Development/starting-expo-app/</id>
    <published>2022-09-27T02:20:51.000Z</published>
    <updated>2022-09-27T02:20:51.000Z</updated>
    
    <content type="html"><![CDATA[<!--excerpt--><h2 id="Expo-CLI-설치"><a href="#Expo-CLI-설치" class="headerlink" title="Expo CLI 설치"></a>Expo CLI 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx expo <span class="built_in">whoami</span> <span class="comment"># 로그인된 계정 확인, Not logged in 이 뜨면 로그인해줘야함</span></span><br><span class="line">npx expo register <span class="comment"># 회원가입</span></span><br><span class="line">npx expo login</span><br></pre></td></tr></table></figure><h2 id="Typescript-Expo-앱-시작"><a href="#Typescript-Expo-앱-시작" class="headerlink" title="Typescript - Expo 앱 시작"></a>Typescript - Expo 앱 시작</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npx create-expo-app app-name</span><br><span class="line"><span class="built_in">cd</span> app-name</span><br><span class="line"><span class="built_in">touch</span> tsconfig.json</span><br><span class="line">npx expo start <span class="comment"># Typescript 필요 번들설치</span></span><br><span class="line"><span class="built_in">mv</span> App.js App.tsx</span><br><span class="line">npx tsc <span class="comment"># 타입체크</span></span><br></pre></td></tr></table></figure><p>또는, 이미 만들어진 Typescript 기반의 expo 템플릿을 설치하여 사용할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-expo-app -t expo-template-blank-typescript</span><br></pre></td></tr></table></figure><blockquote><p>참고자료 : <a href="'https://docs.expo.dev/guides/typescript/'">Expo Docs</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Starting React Native app with Expo&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>2022년 8월 회고</title>
    <link href="https://oxcarxierra.github.io/Review/2022/august-2022-review/"/>
    <id>https://oxcarxierra.github.io/Review/2022/august-2022-review/</id>
    <published>2022-09-01T10:59:02.000Z</published>
    <updated>2022-09-01T10:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li><strong>군장병 공개SW 온라인 해커톤</strong> 준비로 바빴다. 코딩테스트 준비를 위해 BOJ 문제들을 난이도순으로 풀었고, 도중에 모르는 자료구조나 알고리즘은 종만북과 친절하게 설명해 놓은 블로그들을 참고하며 배울 수 있었다. 새로 알게된 내용은 블로그에 나만의 언어로 정리해서 포스팅하며 복습도 했다. 실제로 코딩테스트에 DP와 BFS문제가 나와서 공부했던 내용을 잘 써먹을 수 있었다. Dart 언어와 Flutter도 제공하는 강의를 모두 수강했더니 이론평가도 어렵지 않게 풀 수 있었다.</li></ul><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://imgur.com/dzRvkOI.png" title="알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!" data-caption="알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!" data-fancybox="default"><img class="fig-img" src="https://imgur.com/dzRvkOI.png" alt="알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!"></a><span class="caption">알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!</span></div><div style="clear:both;"></div><br ><ul><li>본선에서 실제로 구현할 아이디어를 담은 개발계획서를 제출해야 하는데, 아무래도 내가 있는 부대는 일반적인 육군과 근무 환경이 다르다보니 문제점을 찾고 솔루션을 제안하는게 쉽지 않다. 괜찮은 주제를 찾을 때까지 노션을 스케치북삼아 브레인스토밍을 해나가고 있는데 하나 꽂히는 것이 없어서 고민이 되고 있다.</li></ul><br ><ul><li>이번 후반기에 열리는 <a href="https://www.army-startup.co.kr/">제 8회 육군창업경진대회</a>에 도전해보고 싶어서 팀빌딩을 하고 아이디어를 같이 구상해보기로 했다. 군에 복무하면서 스타트업을 준비하고 경험해볼 수 있는 좋은 기회가 될 것 같다. 본선만 진출해도 포상휴가가 나온다고 해서 더더욱 열심히 해볼 생각이다.</li></ul><br ><ul><li>넷플릭스의 기업 문화를 담은 &lt;규칙 없음&gt;을 읽었다. 나는 극한의 인재 밀도를 추구하는 기업에 어울릴수 있는가? 나는 기업이 업계 최고의 대우를 해주어서라도 가지고 있을만한 인재인가? 나는 직설적이고 솔직한 피드백을 주고, 또 받을 준비가 되어있는가?</li></ul><br ><div class="figure center" style="width:;"><img class="fig-img" src="https://i.imgur.com/vhgtCzI.jpg" alt="PFC Oh promoted to CPL Oh!🫡"><span class="caption">PFC Oh promoted to CPL Oh!🫡</span></div><hr><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><p><strong>&lt;1Q84 #2&gt;</strong> - 무라카미 하루키<br><strong>&lt;규칙 없음&gt;</strong> - 리드 헤이스팅스 ∙ 에린 마이어 (진중문고)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;군장병 공개SW 온라인 해커톤&lt;/strong&gt; 준비로 바빴다. 코딩테스트 준비를 위해 BOJ 문제들을 난이도순으로 </summary>
      
    
    
    
    <category term="Review" scheme="https://oxcarxierra.github.io/categories/Review/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>비트마스킹 Bitmask</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-bitmask-1052/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-bitmask-1052/</id>
    <published>2022-08-22T13:03:21.000Z</published>
    <updated>2022-08-22T13:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!--toc--><h2 id="비트마스킹이란"><a href="#비트마스킹이란" class="headerlink" title="비트마스킹이란?"></a>비트마스킹이란?</h2><p><strong>이진법 숫자의 각 자리(비트)에</strong> <code>true</code>&#x2F;<code>false</code> <strong>혹은 0&#x2F;1의 데이터를 저장</strong>하는 자료구조 혹은 테크닉이다.<br>예를 들어, 0,1,2,3중 두 숫자를 뽑는 모든 경우의 수를 생각하자. <code>[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]</code>처럼 행렬로 묶는 방법이 있다.<br>비트마스킹을 이용하여 i의 포함 여부를 2^i자리에 저장한다면, <code>0011 0101 0110 1001 1010 1100</code>로 여섯 가지 방법을 나타낼 수 있다. 이 숫자들을 십진법으로 바꾸면 각각 <code>3,5,6,9,11,13</code>이 된다.<br>즉, 리스트형 데이터를 정수형으로 간단하게 표현할 수 있게 된 것이다. 이렇게 비트마스킹은 원소들의 집합을 표현할 때 유용하다.</p><h3 id="비트-연산자"><a href="#비트-연산자" class="headerlink" title="비트 연산자"></a>비트 연산자</h3><p>이렇게 만들어진 이진수(혹은 정수)는 아래 5가지의 연산이 가능하다.</p><ul><li><strong>AND</strong><br>입력받은 두 이진수의 각 자리수가 모두 1일 때만 결과에도 1을 반환<br><code>1100 ^ 1010 = 1000</code></li><li><strong>OR</strong><br>입력받은 두 이진수의 각 자리수 중 하나라도 1일 때 결과에도 1을 반환<br><code>1100 ^ 1010 = 1110</code></li><li><strong>XOR</strong><br>입력받은 두 이진수의 각 자리수 중 하나만 1일 때 결과에도 1을 반환<br><code>1100 ^ 1010 = 0110</code></li><li><strong>NOT</strong><br>입력받은 이진수의 비트가 0일 때 1, 1일 때 0을 반환<br><code>~1100 = 0011</code></li><li><strong>shift</strong><br>이진수의 비트를 왼쪽, 오른쪽으로 원하는 만큼 움직인 값을 반환<br><code>11 &lt;&lt; 2 = 1100</code><br><code>1100 &gt;&gt; 2 = 11</code></li></ul><h3 id="비트-연산자를-이용한-데이터-제어"><a href="#비트-연산자를-이용한-데이터-제어" class="headerlink" title="비트 연산자를 이용한 데이터 제어"></a>비트 연산자를 이용한 데이터 제어</h3><ul><li><strong>비트 삽입</strong><br>p번 비트 추가 : <code>x = x | (1&lt;&lt;p)</code><br><code>1010 | (1&lt;&lt;2) = 1010 | 100 = 1110</code></li><li><strong>비트 삭제</strong><br>p번 비트 삭제 : <code>x = x &amp; ~(1&lt;&lt;p)</code><br><code>1110 &amp; ~ (1&lt;&lt;2) = 1110 &amp; 1011 = 1010</code></li><li><strong>비트 조회</strong><br>p번 비트 조회 : <code>x &amp; (1&lt;&lt;p)</code>의 p번 비트<br><code>1110 &amp; (1&lt;&lt;2) = 1110 &amp; 0100 = 0100</code></li><li><strong>비트 토글</strong><br>p번 비트 토글 : <code>x = x ^ (1&lt;&lt;p)</code><br><code>1110 ^ (1&lt;&lt;2) = 1110 ^ 0100 = 1010</code></li></ul><h2 id="BOJ-1052번-물병"><a href="#BOJ-1052번-물병" class="headerlink" title="BOJ 1052번 물병"></a>BOJ 1052번 물병</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p><a href="'https://www.acmicpc.net/problem/1052'">BOJ 1052번 물병</a></p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>문제를 수기로 조금 풀어보면, 물병의 물을 합치다 보면 <code>2^i</code>리터들의 합으로 분리됨을 알 수 있다. 즉 총 물의 양인 <code>N</code>을 이진수로 표현했을 때 1의 개수만큼의 비지 않은 병이 생긴다. 결국, <code>N+cnt</code>를 이진수로 표현했을 때 1의 개수가 k보다 작거나 같도록 하는 최소의 <code>cnt</code>를 구하는 문제가 된다.<br><code>cnt</code>를 1씩 증가시키면서 계산하면 최악의 경우 복잡도가 <code>O(NlogN)</code>이라서 시간초과가 난다. 1이 있는 가장 작은 자리수부터 1을 추가해주면 계산이 간단해진다.</p><blockquote><p>int형 자료 N의 이진법 표현은 <code>bin(N)</code>으로 구할 수 있으며, <code>0b</code>로 시작하기 때문에 <code>bin(N)[2:]</code>를 사용하기도 한다.</p></blockquote><figure class="highlight py"><figcaption><span>BOJ 1052번 물병</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>) &gt; k:</span><br><span class="line">  b = <span class="built_in">bin</span>(n)</span><br><span class="line">  idx = <span class="built_in">len</span>(b)-b.rfind(<span class="string">&#x27;1&#x27;</span>)-<span class="number">1</span></span><br><span class="line">  n += (<span class="number">1</span> &lt;&lt; idx)</span><br><span class="line">  cnt += (<span class="number">1</span> &lt;&lt; idx)</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 16장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1052번 물병&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 15686번 치킨 배달</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-15686/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-15686/</id>
    <published>2022-08-16T11:20:38.000Z</published>
    <updated>2022-08-16T11:20:38.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="'https://www.acmicpc.net/problem/15686'">BOJ 15686번 치킨 배달</a></p><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><ul><li><p>집 하나의 치킨거리를 구하기 위해 처음에는 BFS를 이용하여, 해당 집(1)에서 출발해 가장 가까운 직선거리에 있는 치킨집(2)을 발견하면 그 거리를 구했다. 결과는 당연히 시간초과. 치킨집들의 좌표를 배열로 저장해두고 각각으로의 치킨거리를 계산해서 최소값을 찾는 게 훨씬 빠르다.</p></li><li><p>itertools를 몰라서 치킨 가게들 중 m개를 임의로 선택하는 함수를 직접 백트래킹으로 구현했었다. 알고리즘은 동일했겠지만 시간초과가 나왔다.</p></li></ul><h3 id="그리디-알고리즘을-사용하면-안되는-이유"><a href="#그리디-알고리즘을-사용하면-안되는-이유" class="headerlink" title="그리디 알고리즘을 사용하면 안되는 이유"></a>그리디 알고리즘을 사용하면 안되는 이유</h3><p>도시의 치킨거리를 가장 많이 줄여주는 치킨집부터 m개를 고르는 방법도 생각해보았지만, 이 문제는 그리디 알고리즘을 사용하면 안된다. m에 따라 고르는 치킨집의 조합이 전혀 달라질 수 있기 때문이다.</p><h3 id="완전탐색-시간복잡도-계산"><a href="#완전탐색-시간복잡도-계산" class="headerlink" title="완전탐색 시간복잡도 계산"></a>완전탐색 시간복잡도 계산</h3><p>치킨집의 최대 개수는 13, 집의 최대 개수는 2N &#x3D; 100개이다. 치킨집의 조합의 가짓수가 가장 많으려면 m&#x3D;6일때, 13C6으로 약 1700이다. 그럼 이 조합마다 도시의 치킨거리를 계산하는데 <code>100*13=1300</code>의 계산이 필요하다고 해도 <code>1700*1300 &lt; 10^8</code>로 주어진 1초 내에 해결 가능하다.<br>컴퓨터는 1초에 약 1억번의 연산이 가능한 것을 이용해, 문제를 풀기 전 복잡도를 구해서 가능한 알고리즘인지 확인해보는 습관을 들여야겠다.</p><h3 id="Itertools-combinations-함수-이용"><a href="#Itertools-combinations-함수-이용" class="headerlink" title="Itertools combinations() 함수 이용"></a>Itertools combinations() 함수 이용</h3><p>Python 내장 모듈 <code>Itertools</code>내에 주어진 집합의 부분집합을 반환해주는 함수 <code>combinations()</code>가 있다는 걸 알게되었다. 이를 이용하면 굳이 백트래킹으로 조합을 일일히 반환하지 않아도 된다.</p><ul><li><code>permutations(p,r)</code>: p의 부분집합 중 <strong>중복된 원소 없이</strong> 길이가 r인 부분집합의 배열을 반환</li><li><code>combinations(p,r)</code> : p의 부분집합 중 <strong>중복된 원소 없이</strong> 길이가 r이고 <strong>사전순으로 정렬</strong>된 부분집합의 배열을 반환</li><li><code>combinations_with_replactment(p,r)</code> : p의 부분집합 중 <strong>원소의 중복을 허용</strong>하는 길이가 r이고 <strong>사전순으로 정렬된</strong> 부분집합의 배열을 반환</li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight py"><figcaption><span>BOJ 15686 치킨 배달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"></span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">home = []</span><br><span class="line">store =[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">  row = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> row[y] == <span class="number">2</span>:</span><br><span class="line">      store.append([x,y])</span><br><span class="line">    <span class="keyword">elif</span> row[y] == <span class="number">1</span>:</span><br><span class="line">      home.append([x,y])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nearest</span>(<span class="params">i,j</span>):</span><br><span class="line">  d = <span class="number">999999</span></span><br><span class="line">  <span class="keyword">for</span> [x,y] <span class="keyword">in</span> selected:</span><br><span class="line">    d = <span class="built_in">min</span>(d, <span class="built_in">abs</span>(i-x)+<span class="built_in">abs</span>(j-y))</span><br><span class="line">  <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chicken</span>():</span><br><span class="line">  chicken = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> [x,y] <span class="keyword">in</span> home:</span><br><span class="line">    chicken += nearest(x,y)</span><br><span class="line">  <span class="keyword">return</span> chicken</span><br><span class="line"></span><br><span class="line">min_chicken = <span class="number">999999</span></span><br><span class="line"><span class="keyword">for</span> selected <span class="keyword">in</span> combinations(store, m):</span><br><span class="line">  min_chicken = <span class="built_in">min</span>(min_chicken, chicken())</span><br><span class="line"><span class="built_in">print</span>(min_chicken)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br><a href="https://docs.python.org/3/library/itertools.html">itertools 공식 문서</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&#39;https://www.acmicpc.net/problem/15686&#39;&quot;&gt;BOJ 15</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="itertools" scheme="https://oxcarxierra.github.io/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 9935번 문자열 폭발</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-9935/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-9935/</id>
    <published>2022-08-16T06:52:39.000Z</published>
    <updated>2022-08-16T06:52:39.000Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="'https://www.acmicpc.net/problem/9935'">BOJ 9935번 문자열 폭발</a></p><hr><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><p>문자열 문제를 아직 많이 다뤄보지 못해서 처음 접근할 때 어려움이 있었다.<br>주어진 문자열에서 폭발 문자열을 찾고 모두 지우면 되는데, 문자열을 지우고 난 후 연쇄적으로 생성되는 폭발 문자열도 지워야 하는 게 어려운 점이었다.<br>예를 들어, 문자열이 <code>ACC44</code>, 폭발 문자열이 <code>C4</code>인 경우 앞에서부터 폭발문자열의 검사를 시작하면 끝마쳤을 때 <code>AC4</code>가 남게된다. 이후 한번 더 검사를 해야 최종문자열 <code>A</code>만 남는다.<br>그래서 처음에는 앞에서부터 폭발 문자열을 찾는 알고리즘을 함수로 만들고, 폭발 문자열을 검색할 수 없을 때 까지 재귀적으로 실행하려 했다.<br>몇 번 실패하고 다른 사람들의 풀이를 참고해보니, 문자열을 뒤에서부터 검색하면 굳이 재귀를 하지 않아도 되는 방법이 있었다.</p><ol><li>입력 문자열의 앞에서부터 한 문자씩 stack에 추가한다.</li><li>추가한 문자가 폭발 문자열의 마지막 문자와 일치하면, 문자의 앞쪽으로 폭발 문자열과 일치하는지 검사한다. 일치한다면 stack에서 폭발 문자열을 제거한다.</li><li>입력 문자열의 모든 문자를 검사하고, stack에 원소가 남아있다면 원소를 string으로 바꿔 출력한다. 없다면, <code>&#39;FRULA&#39;</code>를 출력한다.</li></ol><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><figcaption><span>BOJ 9935 문자열 폭발</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s = sys.stdin.readline().strip()</span><br><span class="line">bomb = sys.stdin.readline().strip()</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    stack.append(s[i])</span><br><span class="line">    <span class="keyword">if</span> stack[-<span class="number">1</span>] == bomb[-<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>.join(stack[-<span class="built_in">len</span>(bomb):]) == bomb:</span><br><span class="line">        <span class="keyword">del</span> stack[-<span class="built_in">len</span>(bomb):]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;FRULA&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>.join(stack))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&#39;https://www.acmicpc.net/problem/9935&#39;&quot;&gt;BOJ 993</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="string" scheme="https://oxcarxierra.github.io/tags/string/"/>
    
    <category term="search" scheme="https://oxcarxierra.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>위상 정렬 알고리즘 Topological Sort</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-topological-sort/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-topological-sort/</id>
    <published>2022-08-09T06:03:19.000Z</published>
    <updated>2022-08-09T06:03:19.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="위상-정렬-Topological-Sort"><a href="#위상-정렬-Topological-Sort" class="headerlink" title="위상 정렬 Topological Sort"></a>위상 정렬 <em>Topological Sort</em></h2><p>그래프 중 비순환 방향 그래프(DAG)에 대해, 간선 (u,v)가 있으면 u가 v보다 먼저 오도록 <strong>모든 정점을 선형으로 정렬하는 알고리즘</strong>이다. 대부분의 문제에서, 원소들 사이에 <strong>우선순위가 있는 데이터의 순서를 정하는 데에 사용</strong>될 수 있다.<br>한편 그래프에 순환이 존재한다면, 당연하게도 그 순환을 선형으로 표현할 수 없기 때문에 위상 정렬 알고리즘을 적용할 수 없다. 또한 하나의 그래프에서 다수의 위상 순서 <em>Topological Order</em>가 나올 수 있다.</p><h2 id="BFS를-이용한-in-degree-방법"><a href="#BFS를-이용한-in-degree-방법" class="headerlink" title="BFS를 이용한 in-degree 방법"></a>BFS를 이용한 in-degree 방법</h2><ol><li>정점 N개에 대해 방문했는지 여부를 표시할 배열 <strong>visited</strong>, 출력배열 <strong>t</strong>, <strong>deque</strong>를 초기화한다.</li><li>정점 N개에 대해 해당 정점으로 들어오는 간선의 개수를 <strong>in_degree</strong> 배열에 저장한다.</li><li>in_degree가 0인 원소들부터 deque에 넣는다. 없다면 반드시 사이클이 존재하므로 위상 정렬을 실핼할 수 없다.</li><li>deque의 왼쪽에서 원소 하나를 pop해서, 출력 배열 t에 추가한다. 또, 해당 정점과 연결된 정점들의 in_degree를 1 감소시킨다. 만약 그 값이 0이 되었다면 deque의 오른쪽에 추가한다. 또한 그 노드의 visited값을 True로 저장한다.</li><li>3~4의 과정을 deque가 빌 때까지 반복한다.</li></ol><p>만약 출력배열에 모든 정점이 출력되지 않았다면, DAG가 아니었던 것으로 판단할 수 있다. 이 사실을 이용해 <a href="'https://www.acmicpc.net/problem/2623'">BOJ 2623 음악 프로그램</a>을 해결할 수 있다.</p><h3 id="BOJ-2252-줄세우기"><a href="#BOJ-2252-줄세우기" class="headerlink" title="BOJ 2252 줄세우기"></a>BOJ 2252 줄세우기</h3><figure class="highlight python"><figcaption><span>BOJ 2252 줄세우기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">deg = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[a].append(b)</span><br><span class="line">  deg[b] +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">visited = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">t = []</span><br><span class="line">q = deque([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> deg[i] == <span class="number">0</span>:</span><br><span class="line">    deque.append(q,i)</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">  node = deque.popleft(q)</span><br><span class="line">  t.append(node)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph[node]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[<span class="built_in">next</span>]:</span><br><span class="line">      deg[<span class="built_in">next</span>] -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> deg[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">        visited[<span class="built_in">next</span>] = <span class="literal">True</span></span><br><span class="line">        deque.append(q, <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*t)</span><br></pre></td></tr></table></figure><h3 id="우선순위-힙을-접목한-in-degree-방법-BOJ-1766-문제집"><a href="#우선순위-힙을-접목한-in-degree-방법-BOJ-1766-문제집" class="headerlink" title="우선순위 힙을 접목한 in-degree 방법 (BOJ 1766 문제집)"></a>우선순위 힙을 접목한 in-degree 방법 (BOJ 1766 문제집)</h3><p><a href="'https://www.acmicpc.net/problem/1766'">BOJ 1766 문제집</a> 문제는 한 정점 뒤로 올 수 있는 모든 정점 중 <strong>최솟값</strong>이 그 다음에 와야만 하는 조건이 추가되어 있다. 이 경우엔 간단하게 deque를 heapq클래스로 바꿔주면 쉽게 해결할 수 있다. in-degree가 0이 되면 대기열에서 크기 순서대로 정렬되어 가장 크기가 작은 원소부터 출력 배열에 저장되게 된다.</p><figure class="highlight py"><figcaption><span>BOJ 1766 문제집</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">indeg = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a, b= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[a].append(b)</span><br><span class="line">  indeg[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">visited = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">t , q =[], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> indeg[i] == <span class="number">0</span>:</span><br><span class="line">    heapq.heappush(q,i)</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">  node = heapq.heappop(q)</span><br><span class="line">  t.append(node)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph[node]:</span><br><span class="line">    indeg[<span class="built_in">next</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> indeg[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">      visited[<span class="built_in">next</span>] = <span class="literal">True</span></span><br><span class="line">      heapq.heappush(q, <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*t)</span><br></pre></td></tr></table></figure><!-- ## DFS를 이용한 방법 --><blockquote><p>참고자료<br><a href="https://yoongrammer.tistory.com/86">https://yoongrammer.tistory.com/86</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 2252 줄세우기&lt;/strong&gt;, &lt;strong&gt;BOJ 1766 문제집&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="sort" scheme="https://oxcarxierra.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal 알고리즘 (최소 스패닝 트리 문제)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-kruskal/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-kruskal/</id>
    <published>2022-08-07T07:37:56.000Z</published>
    <updated>2022-08-07T07:37:56.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="최소-스패닝-트리-Minimum-Spanning-Tree-MST"><a href="#최소-스패닝-트리-Minimum-Spanning-Tree-MST" class="headerlink" title="최소 스패닝 트리 (Minimum Spanning Tree, MST)"></a>최소 스패닝 트리 (Minimum Spanning Tree, MST)</h2><p><strong>스패닝 트리 Spanning tree</strong>는 무향 그래프의 정점 전부와 간선의 부분집합으로 구성되어 있으면서, 모든 정점이 연결된 부분 그래프로 정의한다. 연결되기만 하면 되는 점에서 당연히 스패닝 트리는 하나가 아니다. 이 중 간선에 가중치가 부여된 경우 <strong>가중치의 합이 가장 작은 스패닝 트리</strong>를 찾는 문제가 <strong>최소 스패닝 트리 Minimum Spanning Tree</strong> 문제이다.<br>한마디로, 그래프의 연결성을 그대로 유지하는 가장 ‘저렴한’ 그래프를 찾는 문제라고 할 수 있다.</p><p>최소 스패닝 트리를 찾는 두 가지 유명한 알고리즘이 있는데, <strong>Kruskal 알고리즘</strong>과 <strong>Prim 알고리즘</strong>이 그것이다. 둘 다 비용이 적은 간선을 우선적으로 선택하는 <strong>탐욕법</strong>의 본질을 가지고 있다.</p><h2 id="Kruskal-알고리즘"><a href="#Kruskal-알고리즘" class="headerlink" title="Kruskal 알고리즘"></a>Kruskal 알고리즘</h2><p>Kruskal 알고리즘은 가중치가 낮은 간선부터 하나씩 추가해가면서 스패닝 트리를 만들어간다. 하나의 간선을 추가했을 때 최소 스패닝 트리의 조건을 만족하는지 검사해야 하는데, 이 때 <a href="#">Post not found: boj-disjoint-set Union-Find 자료구조</a>가 유용하게 쓰인다. 해당 간선을 추가했을 때 그래프에 사이클이 생긴다면, 불필요한 간선이므로 추가할 필요가 없기 때문이다.<br><br></p><ol><li>그래프의 모든 정점을 Union-Find 자료구조로 구현한다. 처음에는 원소 각각이 상호 배타적 부분집합이 된다.</li><li>가중치가 가장 낮은 간선부터 검사한다. 두 정점이 A,B라고 가정하면 <strong>Find(A)와 Find(B)가 다른 경우에만 Union(A, B)를 실행</strong>한다. 그리고 해당 간선의 가중치를 더한다.</li><li>2번 과정을 모든 간선에 대해 반복한다.</li></ol><h2 id="Kruskal-알고리즘의-시간-복잡도"><a href="#Kruskal-알고리즘의-시간-복잡도" class="headerlink" title="Kruskal 알고리즘의 시간 복잡도"></a>Kruskal 알고리즘의 시간 복잡도</h2><p>우선 Union, Find연산의 시간 복잡도는 <strong>상수 시간으로 수렴</strong>하므로 전체 알고리즘의 복잡도에 영향을 미치지 못한다. 따라서 정렬된 (<code>O(log E)</code>) 모든 간선에 대해(<code>O(E)</code>) 검사를 진행해야 하므로, 전체 시간 복잡도는 <code>O(ElogE)</code>가 된다.</p><h2 id="BOJ-1197번-최소-스패닝-트리"><a href="#BOJ-1197번-최소-스패닝-트리" class="headerlink" title="BOJ 1197번 최소 스패닝 트리"></a>BOJ 1197번 최소 스패닝 트리</h2><figure class="highlight py"><figcaption><span>BOJ 1197번 최소 스패닝 트리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  s,e,w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph.append([w,s,e])</span><br><span class="line">parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line">rank = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a])</span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]:</span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]:</span><br><span class="line">    rank[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kruskal</span>():</span><br><span class="line">  tot_weight = <span class="number">0</span></span><br><span class="line">  graph.sort()</span><br><span class="line">  <span class="keyword">for</span> w,s,e <span class="keyword">in</span> graph:</span><br><span class="line">    <span class="keyword">if</span> find(s) != find(e):</span><br><span class="line">      union(s,e)</span><br><span class="line">      tot_weight += w</span><br><span class="line">  <span class="keyword">return</span> tot_weight</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kruskal())</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 31장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1197번 최소 스패닝 트리&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="mst" scheme="https://oxcarxierra.github.io/tags/mst/"/>
    
  </entry>
  
</feed>
