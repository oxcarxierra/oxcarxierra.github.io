<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Seungseok Oh</title>
  
  <subtitle>OXcarXierra</subtitle>
  <link href="https://oxcarxierra.github.io/feed.xml" rel="self"/>
  
  <link href="https://oxcarxierra.github.io/"/>
  <updated>2022-11-30T14:56:02.051Z</updated>
  <id>https://oxcarxierra.github.io/</id>
  
  <author>
    <name>Seungseok Oh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022년 11월 회고</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/november-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/november-2022-review/</id>
    <published>2022-11-30T11:37:11.000Z</published>
    <updated>2022-11-30T14:56:02.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li><p>OSAM 해커톤에서 <strong>과학기술정보통신부 장관상</strong>을 받으며 잘 마무리했다. 내년 대회에 참여할 다른 사람이 참고할 수 있도록 후기도 작성해보았다.</p></li><li><p>Coursera에 올라와 있는 <strong>Deep Learning Specialization Course</strong>에 Financial Aid를 신청하고, 5개의 코스 중 첫 번째인 <strong>Neural Networks and Deep Learning</strong>을 모두 수강했다. 인공 신경망의 구조와 기초적인 수학 이론이 주를 이뤘고, submission 과제를 통해 numpy, pandas 사용법을 복습할 수 있었다.</p></li><li><p>시니어 카투사 달고 배럭 이사도 한 이후로 시간 효율성이 급격하게 떨어진 느낌이다. 퇴근을 3-4시에 하니까, 저녁 먹는 시간을 빼고도 밤에 잠드는 12시, 1시까지 시간이 정말 많은데 왜 이렇게 의미 없이 흘러가는지 모르겠다. 과제를 급하다고 생각하지 않다 보니까 목표의식이 많이 떨어지는 것 같고, 새로운 task에 마주하면서 스스로 해결하는게 귀찮아진 것 같다. 운동도 좀 꾸준히 해보고, 어디에서라도 동기부여를 좀 받아와야 할 것 같다.</p></li></ul><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><ul><li><strong>&lt;부의 추월차선&gt;</strong>, 엠제이 드마코<br>… 읽다 말았다. 뒤로 갈수록 대부분 동어 반복이며 자기모순적인 내용이 많다.</li><li><strong>&lt;경제기사 궁금증 300문 300답&gt;</strong> - 곽해신 (진중문고)</li><li><strong>&lt;존리의 금융문맹 탈출&gt;</strong> - 존리 (진중문고)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;OSAM 해커톤에서 &lt;strong&gt;과학기술정보통신부 장관상&lt;/strong&gt;을 받으며 잘 마무리했다. 내년 대회에 참여할 다른</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
  </entry>
  
  <entry>
    <title>[React] Library not loaded: @rpath/hermes.framework/hermes 에러</title>
    <link href="https://oxcarxierra.github.io/Development/development/react-build-hermes-error/"/>
    <id>https://oxcarxierra.github.io/Development/development/react-build-hermes-error/</id>
    <published>2022-11-21T12:29:08.000Z</published>
    <updated>2022-11-21T13:12:23.816Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>React Native 0.70.0 이상으로 업데이트 하면서 새로운 프로젝트 빌드 시에 build success 후 시뮬레이터에서 튕기는 오류를 겪었다. 해결 방법은 아래와 같다.</p><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/zwdiQV5.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/zwdiQV5.png" alt=""></a></div><div style="clear:both;"></div><p>xcode &gt; build phases &gt; Link binary with Libraries 메뉴에 hermes.xcframework 추가</p><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/ksgRFIN.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/ksgRFIN.png" alt=""></a></div><div style="clear:both;"></div><p>xcode &gt; General &gt; Frameworks, Libraries, and Embedded Content 에 hermes.xcframework 추가 후 Embed &amp; Sign</p><blockquote><p><a href="'https://github.com/facebook/react-native/issues/34601'">Github - Library not loaded: @rpath&#x2F;hermes.framework&#x2F;hermes on iOS #34601</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;p&gt;React Native 0.70.0 이상으로 업데이트 하면서 새로운 프로젝트 빌드 시에 build success 후 시뮬레이터에서 튕기는 오류를 겪었다. 해결 방법은 아래와 같다.&lt;/p&gt;
&lt;br /&gt;

&lt;div c</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>[2022 군장병 공개 SW 온라인 해커톤] 과학기술정보통신부 장관상 수상 후기</title>
    <link href="https://oxcarxierra.github.io/Development/2022/army-hackathon-review/"/>
    <id>https://oxcarxierra.github.io/Development/2022/army-hackathon-review/</id>
    <published>2022-11-14T10:41:15.000Z</published>
    <updated>2022-11-24T09:38:13.112Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><br /><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://i.imgur.com/65y7cjS.png" title="" data-caption="" data-fancybox="default"><img class="fig-img" src="https://i.imgur.com/65y7cjS.png" alt=""></a></div><div style="clear:both;"></div><h2 id="해커톤-참가"><a href="#해커톤-참가" class="headerlink" title="해커톤 참가"></a>해커톤 참가</h2><p><a href="https://osam.kr/">국방오픈소스아카데미(OSAM) 홈페이지</a>를 해커톤 이전에 발견을 해서, 2022년 해커톤도 열리기를 기대하고 있던 중에 대회 공고가 올라왔고 자연스럽게 참여하게 되었다.</p><h2 id="참가자-선발-과정"><a href="#참가자-선발-과정" class="headerlink" title="참가자 선발 과정"></a>참가자 선발 과정</h2><p>해커톤에 참여하려면 <strong>온라인 평가</strong>, <strong>코딩 테스트</strong>, <strong>개발 계획서</strong> 이렇게 세 가지의 과제를 제출해야 했고, 각각 성적이 <code>50%</code>,<code>25%</code>,<code>25%</code>씩 반영된 선발 점수로 최종 해커톤 참여자 150명 내외를 선정하는 방식이었다.</p><h3 id="1-온라인-평가"><a href="#1-온라인-평가" class="headerlink" title="1. 온라인 평가"></a>1. 온라인 평가</h3><p>온라인 평가는 각 분야별 필수 강의를 듣고 그 강의에 관련된 시험을 보는 형태였다. 제한시간은 1시간, 총 40문제가 출제되었었다. 선택할 수 있는 분야는 <code>WEB</code>,<code>APP</code>,<code>IoT</code>,<code>Cloud</code> 총 4개가 잇었다. 내가 선택했던 APP 분야는 Dart 언어를 사용하는 Front-end 라이브러리 Flutter를 중점으로 했고, 플러터 초급∙중급∙고급 강좌를 필수적으로 이수해야 했다. 평가는 강의에서 나온 자료가 거의 그대로 나왔던 것 같다. 다만 막상 풀 때는 다 아는 내용이라고 생각했지만 결과를 확인해보니 95점이었다. 두 문제를 어디서 틀렸는지 아직도 모르겠다.<br>(<em>사실 문제를 풀면서 구글링도 가능하기 때문에 1시간을 적당히 잘 분배해서 검색의 기회를 적당히 활용하는것도 좋다고 생각한다.</em>)</p><h3 id="2-코딩-테스트"><a href="#2-코딩-테스트" class="headerlink" title="2. 코딩 테스트"></a>2. 코딩 테스트</h3><p>사실상 이 코딩테스트를 준비하기 위해 알고리즘 공부를 한 달 넘게 했다. <a href="https://programmers.co.kr/">프로그래머스</a>의 코딩테스트 환경으로 2시간 동안 총 4문제를 풀게 되는데, 이쪽으론 비전공자였던 내가 다 풀기에는 조금 어려운 난이도였다. 백준으로 따지면 1번은 <code>실버 4</code>, 2번은 <code>실버 1</code>, 3~4번은 <code>골드 1</code>정도의 난이도였던 것 같다. 사실 그렇게 어려운 알고리즘이 나온 건 아닌데, 문제 자체가 너무 더럽고 생각치 못한 예외 케이스들이 있어서 코드 양이 많이 길어질 수 밖에 없었던 것 같다. 난 결과적으로 1,2번 모두 풀고 3번은 패스, 4번을 절반 정도 점수를 받아서 최종 점수는 400점 만점에 254점이었다. 사실 알고리즘을 이번에 처음 입문을 하고 짧은 시간동안 압축해서 공부를 하자니 이론적인 부분은 많이 배웠어도, 실전 코딩테스트에서 좋은 성적이 나오려면 문제를 많이 풀어보는게 가장 좋은 것 같다.<br>참고로, 해커톤과 별개인 <strong>코딩경진대회</strong>는 이 코딩 테스트의 점수가 가장 높은 6명에게 시상과 상품을 준다. 이번 1등 상품은 iPad Air정도였으니, 부상이 꽤 쏠쏠하다. 다만 상위 3명은 모두 만점이라 해결 시간이 짧았던 순서로 순위가 정해졌고, 6등 커트라인이 322점이었으니 수상하려면 최소 백준 플레티넘 정도는 되야하지 않을까 싶다.</p><h3 id="3-개발-계획서"><a href="#3-개발-계획서" class="headerlink" title="3. 개발 계획서"></a>3. 개발 계획서</h3><p><strong>병영생활 및 국방에서 활용 가능한 창의적인 아이디어</strong>라는 대주제 안에서 본인이 해커톤에 진출했을 때 진행할 프로젝트의 구체적인 개발 계획서를 작성하는 과제였다. 물론 나중에 본인의 주제를 포기하고 다른 사람의 주제에 모여서 팀 빌딩을 할 수 있다는 걸 알고있었어서, 많은 노력을 들이지는 않았다.</p><h3 id="4-선발-결과"><a href="#4-선발-결과" class="headerlink" title="4. 선발 결과"></a>4. 선발 결과</h3><p>생각만큼 대회 경쟁률이 그렇게 빡세지 않아서 코딩테스트 점수가 기대에 못 미쳤던 나도 안정권으로 본선에 진출할 수 있었던 것 같다. 해커톤 참가자로 선발된 이후에는 별도의 탭에서 팀 빌딩 기능과 커뮤니티 게시판을 이용할 수 있게된다. 그래서 다른 참가자들의 개발 계획서도 볼 수 있었는데, 개발계획서가 빈칸인데도 선발된 사람도 있었다. 참가자 수가 그만큼 적어서 개발계획서를 완성하지 못해도 선발했던 것 같은데, 그럼 굳이 코딩테스트 준비나 개발계획서를 열심히 할 필요가 없었을 수도 있겠다는 생각도 들었다.</p><h2 id="팀-빌딩-과정"><a href="#팀-빌딩-과정" class="headerlink" title="팀 빌딩 과정"></a>팀 빌딩 과정</h2><p>팀 빌딩 기간이 시작되면 내 프로젝트에 필요한 구체적인 포지션과 인원수를 설정할 수 있게 된다. 그래서 다른 사람들의 개발 계획서를 보면서 참여하고 싶은 주제가 생기면 본인의 것을 포기하고, 비어있는 포지션에 참여 신청을 넣으면 되는 방식으로 진행된다. 나는 고등학교 동기가 팀장을 맡은 <strong>군 법규 도우미</strong> 프로젝트에 Frontend 파트로 참여하기로 했다. 실제로 육군 규정과 국방부 규정으로 정해진 사항임에도 불구하고 군인들이 잘 몰라서 억울한 일을 당해도 항의나 보상 요구를 하지 못하는 경우가 많다는데 공감했기 때문이다.<br>팀빌딩으로 실력 있는 분들이 들어오셔서 총 7명의 팀이 꾸려졌고, 현업에서 일하시는 능력있는 멘토분도 배정받게 되었다. 그 이후로 우리 팀이 목표한 아이디어를 구현하고 본격적으로 개발할 수 있는 1달이라는 시간이 주어졌다.</p><h2 id="온라인-해커톤-및-프로젝트-진행"><a href="#온라인-해커톤-및-프로젝트-진행" class="headerlink" title="온라인 해커톤 및 프로젝트 진행"></a>온라인 해커톤 및 프로젝트 진행</h2><p>팀원 모두가 현역 병사다 보니 훈련 일정도 있고, 남는 개인정비 시간을 쪼개가며 참여했던 해커톤이라 협업하기가 쉽지만은 않았다. 또, 싸지방 컴퓨터로 온라인 IDE를 사용해야 하는 등 열악한 개발환경의 문제도 있었다. 나도 외박 나가있는 동안은 거의 모든 시간을 개발에 쏟아부었던 것 같다.<br>멘토님으로부터 전해받은 몇 가지 팁을 남겨놓자면,</p><ol><li><strong>최종 평가는 발표자료(프레젠테이션)과 시연영상으로만 진행된다.</strong><br>데모에 자잘한 오류가 있더라도, 시간이 없으면 영상에 드러나지 않을 정도로만 수정하는 것도 좋다. 또한 발표는 멘토가 진행하셨기 때문에, 팀이 전하고자 하는 메세지를 프레젠테이션에 최대한 많이 담아야 한다.</li><li><strong>병사 개개인을 타겟으로 한 주제보다, 전체적인 ‘군’에 도움을 줄 수 있는 주제가 좋다.</strong><br>이 프로젝트로써 군의 어떤 문제를 긍정적으로 해결할 수 있는지가 강조되어야 한다.</li><li><strong>개발문서 (Github <code>README.md</code> 포함) 를 구체적으로 쓰고, 이미지를 많이 첨부하면 좋다.</strong><br>우리 팀의 경우에는 <code>GitBook</code>도 활용해서, 미처 시연영상에 담지 못한 내용까지 상세히 설명해 두었다.</li></ol><h2 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h2><ol><li><p>군 생활동안 대회에서 의미있는 상을 하나 정도는 받고 싶었는데, 육군창업경진대회마저 광탈하면서 아쉬웠던 터라 과기부 장관상(1등상)은 믿기 어려울 정도로 뿌듯한 소식이었다. 또 처음으로 참여해본 해커톤 형식의 대회였는데(사실 무박2일, 2박3일로 진행되는 대부분의 해커톤과는 조금 다르지만) 좋게 끝나서 다행이다. Expo, React-Query같은 새로운 기술 스택도 배울 수 있었고, 인사이트를 공유할 좋은 팀원들도 만날 수 있었다. 이런 분들과 협업하면서 완성이라는 하나의 목표를 위해 다 같이 고민하고 해결해나갔던 과정 자체가 참 재미있어서, 대회를 준비하는 한 달 남짓 시간동안 행복했던 것 같다.</p></li><li><p>요즘 군대가 많이 좋아졌다고들 하지만, 아직도 여러 군인이 부대 내 선임 ∙ 상관으로부터의 부조리, 성추행, 괴롭힘으로 정신적 피해를 호소하고 극단적인 선택을 한다. 몇몇 지휘관은 본인의 출세를 위해 덮고 숨기기 급급하며, 수사는 물론 배상조차 제대로 진행되지 못하는 경우가 다반수다. 이런 이슈가 터지고 뉴스를 볼 때마다, 원했던 원하지 않았던 국방의 의무를 다하기 위해 입대한 사람들이 대체 왜 이런 비극을 겪어야 했는지 분노하지 않을 수 없었다. 그리고 모두가 가만히 있으면 아무것도 바뀌지 않기에, 여느 ‘냄비근성’처럼 외면하면서 넘어가고 싶지 않았다. 해커톤에 제출한 하나의 데모 앱에 불과하겠지만, 나는 나만의 방식으로 이 문제를 해결하기 위해 고민했고 노력했다는 사실에 의미를 두고 싶다. 그리고 작은 변화의 바람이라도 함께하는 사람들이 많아지고 군 수뇌부부터 노력한다면, 조준우 일병, 이예람 중사같은 사고가 이제는 다시 일어나지 않을 수 있을 것이다.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;!-- toc --&gt;

&lt;br /&gt;
&lt;div class=&quot;figure center fig-100&quot; style=&quot;width:;&quot;&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://i.imgur.com/65y7</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>[React] Axios를 React Hook으로 사용하기</title>
    <link href="https://oxcarxierra.github.io/Development/development/use_axios_as_react_hook/"/>
    <id>https://oxcarxierra.github.io/Development/development/use_axios_as_react_hook/</id>
    <published>2022-11-05T13:03:24.000Z</published>
    <updated>2022-11-15T13:33:17.450Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><p>그동안은 axios를 그냥 import해서 사용했는데, 이렇게 <code>useAxios()</code> 커스텀 훅을 만들어서 사용하면 에러 처리나 baseUrl에 대한 전처리를 쉽게 해줄 수 있다.</p><figure class="highlight ts"><figcaption><span>useAxios.ts</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> extra <span class="keyword">from</span> <span class="string">&#x27;@utils/extra&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios, &#123; <span class="title class_">AxiosError</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useAtomValue &#125; <span class="keyword">from</span> <span class="string">&#x27;jotai&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useAxios</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="title function_">useAtomValue</span>(userAtom);</span><br><span class="line">  <span class="keyword">const</span> axiosInstance = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">      <span class="attr">baseURL</span>: yourBackendBaseURL,</span><br><span class="line">    &#125;); <span class="comment">// Axios Instance 생성</span></span><br><span class="line">    instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">async</span> (config) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> token = <span class="keyword">await</span> yourToken; <span class="comment">// header에 들어갈 token 받아오기</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...config,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">          ...(config.<span class="property">headers</span> ?? &#123;&#125;),</span><br><span class="line">          <span class="title class_">Authorization</span>: token,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">    instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="literal">undefined</span>, <span class="keyword">async</span> (value) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">AxiosError</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(</span><br><span class="line">          <span class="string">`AxiosError(<span class="subst">$&#123;value.response?.status&#125;</span>/<span class="subst">$&#123;value.code&#125;</span>): <span class="subst">$&#123;value.message&#125;</span>\n<span class="subst">$&#123;value.response?.data&#125;</span>`</span></span><br><span class="line">        ); <span class="comment">// 에러 출력</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="property">response</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;, [user]);</span><br><span class="line">  <span class="keyword">return</span> axiosInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useAxios;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;useAxios()&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>2022년 10월 회고</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/october-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/october-2022-review/</id>
    <published>2022-11-03T07:18:39.000Z</published>
    <updated>2022-11-30T12:20:56.463Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li>육군창업경진대회는 본선 탈락했다. 나름 열심히 준비해서 본선은 갈 줄 알았는데, 아쉬움이 좀 남는다. 아이템이 대회의 컨셉과 안맞는 부분도 있었던 것 같고, 처음으로 준비해 본 창업 경진대회라서 노하우가 부족했던 것 같다.</li></ul><br/><ul><li>10월 한 달 내내 국방 해커톤 프로젝트에 집중한 결과 데모 앱을 기획대로 다 개발했고, 출품까지 잘 마무리했다. 팀원이 7명으로 꽤 많은 데다 다들 역량이 뛰어나셔서, 처음에 불가능해 보일 정도로 많았던 태스크를 모두 끝낼 수 있었던 것 같았다. 그치만 그만큼 협업에서의 어려움이 조금 느껴졌다. 아무래도 다들 열악한 환경에서 개인정비 시간 쪼개가며 참여하는 프로젝트이다 보니까 소통이나 진행 순서에서 꼬이는게 좀 있었다.<br>별개로, 우리 팀의 프로젝트가 군 내 인명피해와 사건사고를 막기 위한 솔루션이라는 점에서 큰 의미가 있었던 것 같다. 종종 군인이 자살했다는 뉴스를 들으면 안타까웠었는데, 그저 연민으로 끝내지 않고 내가 할 수 있는 방법으로 행동에 옮겼다는 뿌듯함이 남았다. 수상까지 하면 완벽할 것 같다.</li></ul><br/><ul><li>책은 많이 못 읽었다. &lt;데미안&gt;과 경제 관련 책을 읽는 중인데, 11월에 다 읽어야겠다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;육군창업경진대회는 본선 탈락했다. 나름 열심히 준비해서 본선은 갈 줄 알았는데, 아쉬움이 좀 남는</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>[React] Luxon.js 라이브러리로 날짜/시간 포맷팅하기</title>
    <link href="https://oxcarxierra.github.io/Development/development/using-luxon-js/"/>
    <id>https://oxcarxierra.github.io/Development/development/using-luxon-js/</id>
    <published>2022-10-23T14:35:03.000Z</published>
    <updated>2022-11-15T13:33:42.106Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>Backend에서 시간에 대한 정보가 담긴 데이터를 보내주는 유형은 다양하다. 일반적으로 js, ts에 존재하는 <code>Date</code> type으로 오거나, 한 번 처리해서 <code>202310232335</code>처럼 <code>string</code> type으로 오기도 한다. 또는 <code>10343904</code>같은 <code>number</code> type으로 오기도 하는데, 이 경우는 <code>1970.01.01 00:00:00 UTC</code>를 기준으로 지난 시간을 millisec의 단위로 표시한 것이다. (참고: <a href="https://currentmillis.com/">여기</a>에서는 현재 시간을 millisec 단위로 알려준다.)</p><p>Frontend 단에서 이 데이터를 <code>OOOO년 OO월 OO일 OO:OO</code> 같은 형식으로 바꿔줄 때, 지금까지는 <code>Date.getDate()</code>같은 함수를 이용해서 새로운 함수를 정의해서 썼었다. 그러나 luxon.js의 <code>DateTime</code>을 이용하면 포맷팅을 아주 쉽게 할 수 있다.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DateTime</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;luxon&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">DateTime</span>.<span class="title function_">fromMillis</span>(time * <span class="number">1000</span>).<span class="title function_">toFormat</span>(<span class="string">&#x27;yyyy.MM.dd  hh:mm&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `toFormat()`함수를 이용해 내가 원하는 string 형식으로 변환할 수 있다.</span></span><br></pre></td></tr></table></figure><p>아래 공식문서를 참고해보면 이 외에도 유용한 기능이 많다.</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><a href="https://www.npmjs.com/package/luxon">npmjs</a></li><li><a href="https://moment.github.io/luxon/api-docs/index.html">Github Docs</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;p&gt;Backend에서 시간에 대한 정보가 담긴 데이터를 보내주는 유형은 다양하다. 일반적으로 js, ts에 존재하는 &lt;code&gt;Date&lt;/code&gt; type으로 오거나, 한 번 처리해서 &lt;code&gt;20231023233</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Dart 기초 문법</title>
    <link href="https://oxcarxierra.github.io/Development/development/basics-of-dart/"/>
    <id>https://oxcarxierra.github.io/Development/development/basics-of-dart/</id>
    <published>2022-10-07T13:13:45.000Z</published>
    <updated>2022-11-15T13:30:07.349Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="변수형"><a href="#변수형" class="headerlink" title="변수형"></a>변수형</h2><ul><li><p>정수형 Number</p></li><li><p>문자열 String<br>문자열 내 변수 value - ‘$value’</p></li><li><p>불리안 bool</p></li><li><p>true, false (소문자임에 주의!)</p></li><li><p>타입 미지정 var, dynamic</p></li></ul><p>dynamic 타입으로 선언되면 할당되는 변수에 따라 타입이 바뀐다.</p><h2 id="리스트-List-lt-type-gt"><a href="#리스트-List-lt-type-gt" class="headerlink" title="리스트 List &lt;type&gt;"></a>리스트 List &lt;type&gt;</h2><ul><li>growable list : 길이가 무한히 늘어날 수 있다.</li><li>ungrowable list의 선언 :<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list = <span class="keyword">new</span> <span class="built_in">List</span>(n);</span><br><span class="line"><span class="built_in">List</span> list_2 = <span class="keyword">new</span> <span class="built_in">List</span>.from([<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>])</span><br></pre></td></tr></table></figure></li><li>길이는 list.length</li></ul><h2 id="Map-해쉬"><a href="#Map-해쉬" class="headerlink" title="Map 해쉬"></a>Map 해쉬</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, type&gt; dictionary = &#123;</span><br><span class="line">    <span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">dictionary.keys.toList()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>final, const - 한 번만 선언하도록 설정, 차이점은 const는 compile time에 할당이 되어있어야 하고, final은 runtime에 지정</li><li>Enum - 커스텀 변수형</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status = &#123;approved, rejected, pending&#125;</span><br></pre></td></tr></table></figure><ul><li>typedef 함수를 변수처럼 사용가능하게 함.</li></ul><h2 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h2><p>??&#x3D; : null인 경우 할당</p><p>&#x2F; 계산하면 double형으로 할당</p><p>is <type> , !is <type></p><h2 id="클래스"><a href="#클래스" class="headerlink" title="클래스"></a>클래스</h2><p>class변수는 instance라고 부른다.</p><p>constructor의 이름은 변수이름과 같다.</p><ul><li><p>Constructor의 선언</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">String</span> id;</span><br><span class="line"></span><br><span class="line">    ClassName(&#123;</span><br><span class="line">        <span class="built_in">String</span> name, <span class="built_in">String</span> id,</span><br><span class="line">    &#125;) : <span class="keyword">this</span>.name = name, <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Named Constructor</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//선언방법</span></span><br><span class="line">ClassName.constructorName() :</span><br></pre></td></tr></table></figure></li><li><p>class의 Getter와 setter<br>class 내에서 선언하는 변수들은 _name 언더스코어로 시작. private variable이라고 부른다.<br>private variable은 외부에서 접근 불가. 그래서 getter, setter을 선언해준다</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Idol</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> _name;</span><br><span class="line">    <span class="built_in">String</span> _group;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> name&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> name(<span class="built_in">String</span> newname)&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = newname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="클래스의-상속"><a href="#클래스의-상속" class="headerlink" title="클래스의 상속"></a>클래스의 상속</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span></span>&#123;</span><br><span class="line">    ChildClass(</span><br><span class="line"></span><br><span class="line">    ): <span class="keyword">super</span>( <span class="comment">// super은 부모클래스의 인스턴스를 지칭.</span></span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>부모 클래스의 인스턴스, 메소드 모두를 상속받음. 부모는 자식의 인스턴스와 자식을 상속받지 않음.</p><p>부모 클래스는 두개 이상이 될 수 없다. 하나의 클래스의 자식 클래스는 여러개가 될 수 있다.</p><h3 id="메소드-오버라이딩"><a href="#메소드-오버라이딩" class="headerlink" title="메소드 오버라이딩"></a>메소드 오버라이딩</h3><p>자식클래스에서 메소드를 다시 작성</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span> <span class="comment">// decorator</span></span><br><span class="line"><span class="comment">//이름은 같으면서 새로 쓴 메소드</span></span><br></pre></td></tr></table></figure><h3 id="static-키워드"><a href="#static-키워드" class="headerlink" title="static 키워드"></a>static 키워드</h3><p>하나의 클래스 내에 공유되는 변수가 있다면 <code>static</code>으로 선언해준다.</p><h3 id="Interface-키워드"><a href="#Interface-키워드" class="headerlink" title="Interface 키워드"></a>Interface 키워드</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdolInterface</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">void</span> sayName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoyGroup</span> <span class="keyword">implements</span> <span class="title">IdolInterface</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">void</span> sayName()&#123;</span><br><span class="line">        <span class="comment">//something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스의 형식을 지정해주는 인터페이스</p><h3 id="Cascade-Operator"><a href="#Cascade-Operator" class="headerlink" title="Cascade Operator"></a>Cascade Operator</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Idol</span></span>&#123;</span><br><span class="line">    <span class="built_in">String</span> name;</span><br><span class="line">    <span class="built_in">String</span> group;</span><br><span class="line">    <span class="keyword">void</span> sayName()&#123;&#125;;</span><br><span class="line">    <span class="keyword">void</span> sayGroup()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Idol idol = <span class="keyword">new</span> Idol(<span class="string">&#x27;이름&#x27;</span>,<span class="string">&#x27;그룹&#x27;</span>);</span><br><span class="line">idol.sayName();</span><br><span class="line">idol.sayGroup();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Idol(<span class="string">&#x27;이름&#x27;</span>,<span class="string">&#x27;그룹&#x27;</span>)</span><br><span class="line">    ..sayname()</span><br><span class="line">    ..sayGroup();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;!-- toc --&gt;

&lt;h2 id=&quot;변수형&quot;&gt;&lt;a href=&quot;#변수형&quot; class=&quot;headerlink&quot; title=&quot;변수형&quot;&gt;&lt;/a&gt;변수형&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;정수형 Number&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 4분기 OKR</title>
    <link href="https://oxcarxierra.github.io/OKR/2022/2022-4q-okr/"/>
    <id>https://oxcarxierra.github.io/OKR/2022/2022-4q-okr/</id>
    <published>2022-10-02T01:50:18.000Z</published>
    <updated>2022-11-03T13:10:00.611Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><ol><li><strong>경진대회 준비</strong></li><li><strong>꾸준한 자기개발</strong></li><li><strong>사이드 프로젝트</strong></li></ol><h2 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h2><ol><li><strong>경진대회 준비</strong></li></ol><ul><li>2022 OSAM 국방 해커톤 입상</li><li><del>제 8회 육군창업경진대회 본선 진출 및 수상</del> (탈락)</li></ul><ol start="2"><li><strong>꾸준한 자기개발</strong></li></ol><ul><li>책 7권 읽기 (경제∙금융 분야 포함)</li><li>운동(농구 헬스 포함) 일주일에 3번 이상 하기</li></ul><ol start="3"><li><strong>사이드 프로젝트</strong></li></ol><ul><li>USFK Bus 앱 업데이트 및 Playstore 배포</li><li>신규 사이드프로젝트 시작하기?</li></ul><blockquote><p>목표가 생기거나 바뀔 때 마다 OKR은 유연하게 수정해도 됨!</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;Objectives&quot;&gt;&lt;a href=&quot;#Objectives&quot; class=&quot;headerlink&quot; title=&quot;Objectives&quot;&gt;&lt;/a&gt;Objectives&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;경진대회 준비&lt;/s</summary>
      
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 9월 회고</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/september-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/september-2022-review/</id>
    <published>2022-09-29T17:17:42.000Z</published>
    <updated>2022-11-30T14:54:58.928Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>9월엔 포데이 3번에, 2박 3일 휴가까지 써서 부대보다 사회에 있었던 시간이 더 많았다. <del>이게 군인이 맞냐?</del> 그치만 시간을 효율적으로 잘 보냈냐고 물어보면 잘 모르겠다.. 사람도 많이 만나고 개인적으로 재충전하느라 공부는 많이 못했다. 이럴 때 쉬어줘야지 느낌으로 자기합리화하는중.</p><br><ul><li><strong>군장병 공개SW 온라인 해커톤 본선</strong>에 진출했다. 9&#x2F;7에 참가자 발표가 났고, 나는 고등학교 친구가 낸 주제에 팀원으로 합류했다. 다른 장병분들도 주제를 보고 지원해 주셔서 총 7명의 거대 팀을 구성할 수 있었다. 모인 분들의 스펙이 대단하셔서 엄청 놀랐다.. 자세한 후기는 <a href="">OSAM 해커톤 후기</a>로 따로 포스팅할 생각이다. 이제 구체적인 기획을 마무리하고 내가 맡은 Front-End 쪽 개발에 집중할 계획이다. 그런데 마지막으로 받았던 피드백에서 주제가 대차게 까여서 어떻게 방향을 틀어야 할지 좀 고민이 돤다 ㅎㅎ..</li></ul><br><ul><li><strong>제 8회 육군창업경진대회</strong>를 2~3주 빡세게 준비해서 접수를 해놓은 상태다. 2주 뒤에 예선 결과발표가 나는데, 본선 진출만 해도 포상휴가라는 말에 시작한 대회였으니 제발 본선만이라도 갔으면 좋겠다. 지금 육군으로 복무중인 고등학교 친구 군바리 둘이랑 팀을 짜서, 몇 주 전부터 여러 아이디어를 내고 서로 피드백도 해주면서 나온 가장 괜찮은 아이템 하나로 develop하고 접수를 했다. 하나 걱정되는 건 아무래도 육군에서 주관하는 경진대회이다 보니 기술성을 많이 보고 특히 군과 관련된 아이템이 좋은 점수를 받는다고 하는데 우리 아이템이 그쪽은 아니라는거… 암튼 이번 기회에 유튜브로 Figma를 독학해서 프로토타입을 제작하는 데에 사용해봤다. 컴포넌트를 지정하고 그 variation을 만드는 기능이 아주 유용했고, 전반적으로 Adobe XD보다 사용하기 편했던 것 같다. 이제 UI&#x2F;UX Design + Front-End 개발을 같이 할 수 있다고 어디가서 말할 수 있을 것 같다.</li></ul><br><ul><li><strong>제로 투 원</strong>을 읽으며 인사이트를 얻을 수 있었다. 독점적 스타트업이 되야하는 이유, 기하급수적 성장의 중요성, 20-80 법칙, 작은 시장부터 독점하는 방법, 경쟁과 자본주의의 근본적 차이점.</li></ul><hr><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><ul><li><strong>&lt;제로 투 원&gt;</strong> - 피터 틸</li><li><strong>&lt;1Q84 #3&gt;</strong> - 무라카미 하루키</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;9월엔 포데이 3번에, 2박 3일 휴가까지 써서 부대보다 사회에 있었던 시간이 더 많았다. &lt;del&gt;이게 군</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>[React] Expo 이용해서 React Native 앱 시작하기</title>
    <link href="https://oxcarxierra.github.io/Development/development/starting-expo-app/"/>
    <id>https://oxcarxierra.github.io/Development/development/starting-expo-app/</id>
    <published>2022-09-27T02:20:51.000Z</published>
    <updated>2022-11-15T13:33:59.659Z</updated>
    
    <content type="html"><![CDATA[<!--excerpt--><h2 id="Expo-CLI-설치"><a href="#Expo-CLI-설치" class="headerlink" title="Expo CLI 설치"></a>Expo CLI 설치</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx expo <span class="built_in">whoami</span> <span class="comment"># 로그인된 계정 확인, Not logged in 이 뜨면 로그인해줘야함</span></span><br><span class="line">npx expo register <span class="comment"># 회원가입</span></span><br><span class="line">npx expo login</span><br></pre></td></tr></table></figure><h2 id="Typescript-Expo-앱-시작"><a href="#Typescript-Expo-앱-시작" class="headerlink" title="Typescript - Expo 앱 시작"></a>Typescript - Expo 앱 시작</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npx create-expo-app app-name</span><br><span class="line"><span class="built_in">cd</span> app-name</span><br><span class="line"><span class="built_in">touch</span> tsconfig.json</span><br><span class="line">npx expo start <span class="comment"># Typescript 필요 번들설치</span></span><br><span class="line"><span class="built_in">mv</span> App.js App.tsx</span><br><span class="line">npx tsc <span class="comment"># 타입체크</span></span><br></pre></td></tr></table></figure><p>또는, 이미 만들어진 Typescript 기반의 expo 템플릿을 설치하여 사용할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-expo-app -t expo-template-blank-typescript</span><br></pre></td></tr></table></figure><blockquote><p>참고자료 : <a href="'https://docs.expo.dev/guides/typescript/'">Expo Docs</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Starting React Native app with Expo&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React" scheme="https://oxcarxierra.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>2022년 8월 회고</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/august-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/august-2022-review/</id>
    <published>2022-09-01T10:59:02.000Z</published>
    <updated>2022-11-30T14:55:29.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li><strong>군장병 공개SW 온라인 해커톤</strong> 준비로 바빴다. 코딩테스트 준비를 위해 BOJ 문제들을 난이도순으로 풀었고, 도중에 모르는 자료구조나 알고리즘은 종만북과 친절하게 설명해 놓은 블로그들을 참고하며 배울 수 있었다. 새로 알게된 내용은 블로그에 나만의 언어로 정리해서 포스팅하며 복습도 했다. 실제로 코딩테스트에 DP와 BFS문제가 나와서 공부했던 내용을 잘 써먹을 수 있었다. Dart 언어와 Flutter도 제공하는 강의를 모두 수강했더니 이론평가도 어렵지 않게 풀 수 있었다.</li></ul><div class="figure center fig-100" style="width:;"><a class="fancybox" href="https://imgur.com/dzRvkOI.png" title="알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!" data-caption="알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!" data-fancybox="default"><img class="fig-img" src="https://imgur.com/dzRvkOI.png" alt="알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!"></a><span class="caption">알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!</span></div><div style="clear:both;"></div><br ><ul><li>본선에서 실제로 구현할 아이디어를 담은 개발계획서를 제출해야 하는데, 아무래도 내가 있는 부대는 일반적인 육군과 근무 환경이 다르다보니 문제점을 찾고 솔루션을 제안하는게 쉽지 않다. 괜찮은 주제를 찾을 때까지 노션을 스케치북삼아 브레인스토밍을 해나가고 있는데 하나 꽂히는 것이 없어서 고민이 되고 있다.</li></ul><br ><ul><li>이번 후반기에 열리는 <a href="https://www.army-startup.co.kr/">제 8회 육군창업경진대회</a>에 도전해보고 싶어서 팀빌딩을 하고 아이디어를 같이 구상해보기로 했다. 군에 복무하면서 스타트업을 준비하고 경험해볼 수 있는 좋은 기회가 될 것 같다. 본선만 진출해도 포상휴가가 나온다고 해서 더더욱 열심히 해볼 생각이다.</li></ul><br ><ul><li>넷플릭스의 기업 문화를 담은 &lt;규칙 없음&gt;을 읽었다. 나는 극한의 인재 밀도를 추구하는 기업에 어울릴수 있는가? 나는 기업이 업계 최고의 대우를 해주어서라도 가지고 있을만한 인재인가? 나는 직설적이고 솔직한 피드백을 주고, 또 받을 준비가 되어있는가?</li></ul><br ><div class="figure center" style="width:;"><img class="fig-img" src="https://i.imgur.com/vhgtCzI.jpg" alt="PFC Oh promoted to CPL Oh!🫡"><span class="caption">PFC Oh promoted to CPL Oh!🫡</span></div><hr><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><p><strong>&lt;1Q84 #2&gt;</strong> - 무라카미 하루키<br><strong>&lt;규칙 없음&gt;</strong> - 리드 헤이스팅스 ∙ 에린 마이어 (진중문고)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;군장병 공개SW 온라인 해커톤&lt;/strong&gt; 준비로 바빴다. 코딩테스트 준비를 위해 BOJ 문제들을 난이도순으로 </summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>비트마스킹 Bitmask</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-bitmask-1052/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-bitmask-1052/</id>
    <published>2022-08-22T13:03:21.000Z</published>
    <updated>2022-09-29T17:39:26.470Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!--toc--><h2 id="비트마스킹이란"><a href="#비트마스킹이란" class="headerlink" title="비트마스킹이란?"></a>비트마스킹이란?</h2><p><strong>이진법 숫자의 각 자리(비트)에</strong> <code>true</code>&#x2F;<code>false</code> <strong>혹은 0&#x2F;1의 데이터를 저장</strong>하는 자료구조 혹은 테크닉이다.<br>예를 들어, 0,1,2,3중 두 숫자를 뽑는 모든 경우의 수를 생각하자. <code>[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]</code>처럼 행렬로 묶는 방법이 있다.<br>비트마스킹을 이용하여 i의 포함 여부를 2^i자리에 저장한다면, <code>0011 0101 0110 1001 1010 1100</code>로 여섯 가지 방법을 나타낼 수 있다. 이 숫자들을 십진법으로 바꾸면 각각 <code>3,5,6,9,11,13</code>이 된다.<br>즉, 리스트형 데이터를 정수형으로 간단하게 표현할 수 있게 된 것이다. 이렇게 비트마스킹은 원소들의 집합을 표현할 때 유용하다.</p><h3 id="비트-연산자"><a href="#비트-연산자" class="headerlink" title="비트 연산자"></a>비트 연산자</h3><p>이렇게 만들어진 이진수(혹은 정수)는 아래 5가지의 연산이 가능하다.</p><ul><li><strong>AND</strong><br>입력받은 두 이진수의 각 자리수가 모두 1일 때만 결과에도 1을 반환<br><code>1100 ^ 1010 = 1000</code></li><li><strong>OR</strong><br>입력받은 두 이진수의 각 자리수 중 하나라도 1일 때 결과에도 1을 반환<br><code>1100 ^ 1010 = 1110</code></li><li><strong>XOR</strong><br>입력받은 두 이진수의 각 자리수 중 하나만 1일 때 결과에도 1을 반환<br><code>1100 ^ 1010 = 0110</code></li><li><strong>NOT</strong><br>입력받은 이진수의 비트가 0일 때 1, 1일 때 0을 반환<br><code>~1100 = 0011</code></li><li><strong>shift</strong><br>이진수의 비트를 왼쪽, 오른쪽으로 원하는 만큼 움직인 값을 반환<br><code>11 &lt;&lt; 2 = 1100</code><br><code>1100 &gt;&gt; 2 = 11</code></li></ul><h3 id="비트-연산자를-이용한-데이터-제어"><a href="#비트-연산자를-이용한-데이터-제어" class="headerlink" title="비트 연산자를 이용한 데이터 제어"></a>비트 연산자를 이용한 데이터 제어</h3><ul><li><strong>비트 삽입</strong><br>p번 비트 추가 : <code>x = x | (1&lt;&lt;p)</code><br><code>1010 | (1&lt;&lt;2) = 1010 | 100 = 1110</code></li><li><strong>비트 삭제</strong><br>p번 비트 삭제 : <code>x = x &amp; ~(1&lt;&lt;p)</code><br><code>1110 &amp; ~ (1&lt;&lt;2) = 1110 &amp; 1011 = 1010</code></li><li><strong>비트 조회</strong><br>p번 비트 조회 : <code>x &amp; (1&lt;&lt;p)</code>의 p번 비트<br><code>1110 &amp; (1&lt;&lt;2) = 1110 &amp; 0100 = 0100</code></li><li><strong>비트 토글</strong><br>p번 비트 토글 : <code>x = x ^ (1&lt;&lt;p)</code><br><code>1110 ^ (1&lt;&lt;2) = 1110 ^ 0100 = 1010</code></li></ul><h2 id="BOJ-1052번-물병"><a href="#BOJ-1052번-물병" class="headerlink" title="BOJ 1052번 물병"></a>BOJ 1052번 물병</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p><a href="'https://www.acmicpc.net/problem/1052'">BOJ 1052번 물병</a></p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>문제를 수기로 조금 풀어보면, 물병의 물을 합치다 보면 <code>2^i</code>리터들의 합으로 분리됨을 알 수 있다. 즉 총 물의 양인 <code>N</code>을 이진수로 표현했을 때 1의 개수만큼의 비지 않은 병이 생긴다. 결국, <code>N+cnt</code>를 이진수로 표현했을 때 1의 개수가 k보다 작거나 같도록 하는 최소의 <code>cnt</code>를 구하는 문제가 된다.<br><code>cnt</code>를 1씩 증가시키면서 계산하면 최악의 경우 복잡도가 <code>O(NlogN)</code>이라서 시간초과가 난다. 1이 있는 가장 작은 자리수부터 1을 추가해주면 계산이 간단해진다.</p><blockquote><p>int형 자료 N의 이진법 표현은 <code>bin(N)</code>으로 구할 수 있으며, <code>0b</code>로 시작하기 때문에 <code>bin(N)[2:]</code>를 사용하기도 한다.</p></blockquote><figure class="highlight py"><figcaption><span>BOJ 1052번 물병</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>) &gt; k:</span><br><span class="line">  b = <span class="built_in">bin</span>(n)</span><br><span class="line">  idx = <span class="built_in">len</span>(b)-b.rfind(<span class="string">&#x27;1&#x27;</span>)-<span class="number">1</span></span><br><span class="line">  n += (<span class="number">1</span> &lt;&lt; idx)</span><br><span class="line">  cnt += (<span class="number">1</span> &lt;&lt; idx)</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 16장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1052번 물병&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 15686번 치킨 배달</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-15686/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-15686/</id>
    <published>2022-08-16T11:20:38.000Z</published>
    <updated>2022-09-29T17:39:26.479Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="'https://www.acmicpc.net/problem/15686'">BOJ 15686번 치킨 배달</a></p><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><ul><li><p>집 하나의 치킨거리를 구하기 위해 처음에는 BFS를 이용하여, 해당 집(1)에서 출발해 가장 가까운 직선거리에 있는 치킨집(2)을 발견하면 그 거리를 구했다. 결과는 당연히 시간초과. 치킨집들의 좌표를 배열로 저장해두고 각각으로의 치킨거리를 계산해서 최소값을 찾는 게 훨씬 빠르다.</p></li><li><p>itertools를 몰라서 치킨 가게들 중 m개를 임의로 선택하는 함수를 직접 백트래킹으로 구현했었다. 알고리즘은 동일했겠지만 시간초과가 나왔다.</p></li></ul><h3 id="그리디-알고리즘을-사용하면-안되는-이유"><a href="#그리디-알고리즘을-사용하면-안되는-이유" class="headerlink" title="그리디 알고리즘을 사용하면 안되는 이유"></a>그리디 알고리즘을 사용하면 안되는 이유</h3><p>도시의 치킨거리를 가장 많이 줄여주는 치킨집부터 m개를 고르는 방법도 생각해보았지만, 이 문제는 그리디 알고리즘을 사용하면 안된다. m에 따라 고르는 치킨집의 조합이 전혀 달라질 수 있기 때문이다.</p><h3 id="완전탐색-시간복잡도-계산"><a href="#완전탐색-시간복잡도-계산" class="headerlink" title="완전탐색 시간복잡도 계산"></a>완전탐색 시간복잡도 계산</h3><p>치킨집의 최대 개수는 13, 집의 최대 개수는 2N &#x3D; 100개이다. 치킨집의 조합의 가짓수가 가장 많으려면 m&#x3D;6일때, 13C6으로 약 1700이다. 그럼 이 조합마다 도시의 치킨거리를 계산하는데 <code>100*13=1300</code>의 계산이 필요하다고 해도 <code>1700*1300 &lt; 10^8</code>로 주어진 1초 내에 해결 가능하다.<br>컴퓨터는 1초에 약 1억번의 연산이 가능한 것을 이용해, 문제를 풀기 전 복잡도를 구해서 가능한 알고리즘인지 확인해보는 습관을 들여야겠다.</p><h3 id="Itertools-combinations-함수-이용"><a href="#Itertools-combinations-함수-이용" class="headerlink" title="Itertools combinations() 함수 이용"></a>Itertools combinations() 함수 이용</h3><p>Python 내장 모듈 <code>Itertools</code>내에 주어진 집합의 부분집합을 반환해주는 함수 <code>combinations()</code>가 있다는 걸 알게되었다. 이를 이용하면 굳이 백트래킹으로 조합을 일일히 반환하지 않아도 된다.</p><ul><li><code>permutations(p,r)</code>: p의 부분집합 중 <strong>중복된 원소 없이</strong> 길이가 r인 부분집합의 배열을 반환</li><li><code>combinations(p,r)</code> : p의 부분집합 중 <strong>중복된 원소 없이</strong> 길이가 r이고 <strong>사전순으로 정렬</strong>된 부분집합의 배열을 반환</li><li><code>combinations_with_replactment(p,r)</code> : p의 부분집합 중 <strong>원소의 중복을 허용</strong>하는 길이가 r이고 <strong>사전순으로 정렬된</strong> 부분집합의 배열을 반환</li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight py"><figcaption><span>BOJ 15686 치킨 배달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"></span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">home = []</span><br><span class="line">store =[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">  row = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> row[y] == <span class="number">2</span>:</span><br><span class="line">      store.append([x,y])</span><br><span class="line">    <span class="keyword">elif</span> row[y] == <span class="number">1</span>:</span><br><span class="line">      home.append([x,y])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nearest</span>(<span class="params">i,j</span>):</span><br><span class="line">  d = <span class="number">999999</span></span><br><span class="line">  <span class="keyword">for</span> [x,y] <span class="keyword">in</span> selected:</span><br><span class="line">    d = <span class="built_in">min</span>(d, <span class="built_in">abs</span>(i-x)+<span class="built_in">abs</span>(j-y))</span><br><span class="line">  <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chicken</span>():</span><br><span class="line">  chicken = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> [x,y] <span class="keyword">in</span> home:</span><br><span class="line">    chicken += nearest(x,y)</span><br><span class="line">  <span class="keyword">return</span> chicken</span><br><span class="line"></span><br><span class="line">min_chicken = <span class="number">999999</span></span><br><span class="line"><span class="keyword">for</span> selected <span class="keyword">in</span> combinations(store, m):</span><br><span class="line">  min_chicken = <span class="built_in">min</span>(min_chicken, chicken())</span><br><span class="line"><span class="built_in">print</span>(min_chicken)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br><a href="https://docs.python.org/3/library/itertools.html">itertools 공식 문서</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&#39;https://www.acmicpc.net/problem/15686&#39;&quot;&gt;BOJ 15</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="itertools" scheme="https://oxcarxierra.github.io/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 9935번 문자열 폭발</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-9935/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-9935/</id>
    <published>2022-08-16T06:52:39.000Z</published>
    <updated>2022-08-16T07:01:24.351Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="'https://www.acmicpc.net/problem/9935'">BOJ 9935번 문자열 폭발</a></p><hr><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><p>문자열 문제를 아직 많이 다뤄보지 못해서 처음 접근할 때 어려움이 있었다.<br>주어진 문자열에서 폭발 문자열을 찾고 모두 지우면 되는데, 문자열을 지우고 난 후 연쇄적으로 생성되는 폭발 문자열도 지워야 하는 게 어려운 점이었다.<br>예를 들어, 문자열이 <code>ACC44</code>, 폭발 문자열이 <code>C4</code>인 경우 앞에서부터 폭발문자열의 검사를 시작하면 끝마쳤을 때 <code>AC4</code>가 남게된다. 이후 한번 더 검사를 해야 최종문자열 <code>A</code>만 남는다.<br>그래서 처음에는 앞에서부터 폭발 문자열을 찾는 알고리즘을 함수로 만들고, 폭발 문자열을 검색할 수 없을 때 까지 재귀적으로 실행하려 했다.<br>몇 번 실패하고 다른 사람들의 풀이를 참고해보니, 문자열을 뒤에서부터 검색하면 굳이 재귀를 하지 않아도 되는 방법이 있었다.</p><ol><li>입력 문자열의 앞에서부터 한 문자씩 stack에 추가한다.</li><li>추가한 문자가 폭발 문자열의 마지막 문자와 일치하면, 문자의 앞쪽으로 폭발 문자열과 일치하는지 검사한다. 일치한다면 stack에서 폭발 문자열을 제거한다.</li><li>입력 문자열의 모든 문자를 검사하고, stack에 원소가 남아있다면 원소를 string으로 바꿔 출력한다. 없다면, <code>&#39;FRULA&#39;</code>를 출력한다.</li></ol><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><figcaption><span>BOJ 9935 문자열 폭발</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s = sys.stdin.readline().strip()</span><br><span class="line">bomb = sys.stdin.readline().strip()</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    stack.append(s[i])</span><br><span class="line">    <span class="keyword">if</span> stack[-<span class="number">1</span>] == bomb[-<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>.join(stack[-<span class="built_in">len</span>(bomb):]) == bomb:</span><br><span class="line">        <span class="keyword">del</span> stack[-<span class="built_in">len</span>(bomb):]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;FRULA&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>.join(stack))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&#39;https://www.acmicpc.net/problem/9935&#39;&quot;&gt;BOJ 993</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="string" scheme="https://oxcarxierra.github.io/tags/string/"/>
    
    <category term="search" scheme="https://oxcarxierra.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>위상 정렬 알고리즘 Topological Sort</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-topological-sort/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-topological-sort/</id>
    <published>2022-08-09T06:03:19.000Z</published>
    <updated>2022-09-29T17:39:26.470Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="위상-정렬-Topological-Sort"><a href="#위상-정렬-Topological-Sort" class="headerlink" title="위상 정렬 Topological Sort"></a>위상 정렬 <em>Topological Sort</em></h2><p>그래프 중 비순환 방향 그래프(DAG)에 대해, 간선 (u,v)가 있으면 u가 v보다 먼저 오도록 <strong>모든 정점을 선형으로 정렬하는 알고리즘</strong>이다. 대부분의 문제에서, 원소들 사이에 <strong>우선순위가 있는 데이터의 순서를 정하는 데에 사용</strong>될 수 있다.<br>한편 그래프에 순환이 존재한다면, 당연하게도 그 순환을 선형으로 표현할 수 없기 때문에 위상 정렬 알고리즘을 적용할 수 없다. 또한 하나의 그래프에서 다수의 위상 순서 <em>Topological Order</em>가 나올 수 있다.</p><h2 id="BFS를-이용한-in-degree-방법"><a href="#BFS를-이용한-in-degree-방법" class="headerlink" title="BFS를 이용한 in-degree 방법"></a>BFS를 이용한 in-degree 방법</h2><ol><li>정점 N개에 대해 방문했는지 여부를 표시할 배열 <strong>visited</strong>, 출력배열 <strong>t</strong>, <strong>deque</strong>를 초기화한다.</li><li>정점 N개에 대해 해당 정점으로 들어오는 간선의 개수를 <strong>in_degree</strong> 배열에 저장한다.</li><li>in_degree가 0인 원소들부터 deque에 넣는다. 없다면 반드시 사이클이 존재하므로 위상 정렬을 실핼할 수 없다.</li><li>deque의 왼쪽에서 원소 하나를 pop해서, 출력 배열 t에 추가한다. 또, 해당 정점과 연결된 정점들의 in_degree를 1 감소시킨다. 만약 그 값이 0이 되었다면 deque의 오른쪽에 추가한다. 또한 그 노드의 visited값을 True로 저장한다.</li><li>3~4의 과정을 deque가 빌 때까지 반복한다.</li></ol><p>만약 출력배열에 모든 정점이 출력되지 않았다면, DAG가 아니었던 것으로 판단할 수 있다. 이 사실을 이용해 <a href="'https://www.acmicpc.net/problem/2623'">BOJ 2623 음악 프로그램</a>을 해결할 수 있다.</p><h3 id="BOJ-2252-줄세우기"><a href="#BOJ-2252-줄세우기" class="headerlink" title="BOJ 2252 줄세우기"></a>BOJ 2252 줄세우기</h3><figure class="highlight python"><figcaption><span>BOJ 2252 줄세우기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">deg = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[a].append(b)</span><br><span class="line">  deg[b] +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">visited = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">t = []</span><br><span class="line">q = deque([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> deg[i] == <span class="number">0</span>:</span><br><span class="line">    deque.append(q,i)</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">  node = deque.popleft(q)</span><br><span class="line">  t.append(node)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph[node]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[<span class="built_in">next</span>]:</span><br><span class="line">      deg[<span class="built_in">next</span>] -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> deg[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">        visited[<span class="built_in">next</span>] = <span class="literal">True</span></span><br><span class="line">        deque.append(q, <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*t)</span><br></pre></td></tr></table></figure><h3 id="우선순위-힙을-접목한-in-degree-방법-BOJ-1766-문제집"><a href="#우선순위-힙을-접목한-in-degree-방법-BOJ-1766-문제집" class="headerlink" title="우선순위 힙을 접목한 in-degree 방법 (BOJ 1766 문제집)"></a>우선순위 힙을 접목한 in-degree 방법 (BOJ 1766 문제집)</h3><p><a href="'https://www.acmicpc.net/problem/1766'">BOJ 1766 문제집</a> 문제는 한 정점 뒤로 올 수 있는 모든 정점 중 <strong>최솟값</strong>이 그 다음에 와야만 하는 조건이 추가되어 있다. 이 경우엔 간단하게 deque를 heapq클래스로 바꿔주면 쉽게 해결할 수 있다. in-degree가 0이 되면 대기열에서 크기 순서대로 정렬되어 가장 크기가 작은 원소부터 출력 배열에 저장되게 된다.</p><figure class="highlight py"><figcaption><span>BOJ 1766 문제집</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">indeg = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a, b= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[a].append(b)</span><br><span class="line">  indeg[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">visited = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">t , q =[], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> indeg[i] == <span class="number">0</span>:</span><br><span class="line">    heapq.heappush(q,i)</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">  node = heapq.heappop(q)</span><br><span class="line">  t.append(node)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph[node]:</span><br><span class="line">    indeg[<span class="built_in">next</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> indeg[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">      visited[<span class="built_in">next</span>] = <span class="literal">True</span></span><br><span class="line">      heapq.heappush(q, <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*t)</span><br></pre></td></tr></table></figure><!-- ## DFS를 이용한 방법 --><blockquote><p>참고자료<br><a href="https://yoongrammer.tistory.com/86">https://yoongrammer.tistory.com/86</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 2252 줄세우기&lt;/strong&gt;, &lt;strong&gt;BOJ 1766 문제집&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="sort" scheme="https://oxcarxierra.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal 알고리즘 (최소 스패닝 트리 문제)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-kruskal/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-kruskal/</id>
    <published>2022-08-07T07:37:56.000Z</published>
    <updated>2022-09-29T17:39:26.483Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="최소-스패닝-트리-Minimum-Spanning-Tree-MST"><a href="#최소-스패닝-트리-Minimum-Spanning-Tree-MST" class="headerlink" title="최소 스패닝 트리 (Minimum Spanning Tree, MST)"></a>최소 스패닝 트리 (Minimum Spanning Tree, MST)</h2><p><strong>스패닝 트리 Spanning tree</strong>는 무향 그래프의 정점 전부와 간선의 부분집합으로 구성되어 있으면서, 모든 정점이 연결된 부분 그래프로 정의한다. 연결되기만 하면 되는 점에서 당연히 스패닝 트리는 하나가 아니다. 이 중 간선에 가중치가 부여된 경우 <strong>가중치의 합이 가장 작은 스패닝 트리</strong>를 찾는 문제가 <strong>최소 스패닝 트리 Minimum Spanning Tree</strong> 문제이다.<br>한마디로, 그래프의 연결성을 그대로 유지하는 가장 ‘저렴한’ 그래프를 찾는 문제라고 할 수 있다.</p><p>최소 스패닝 트리를 찾는 두 가지 유명한 알고리즘이 있는데, <strong>Kruskal 알고리즘</strong>과 <strong>Prim 알고리즘</strong>이 그것이다. 둘 다 비용이 적은 간선을 우선적으로 선택하는 <strong>탐욕법</strong>의 본질을 가지고 있다.</p><h2 id="Kruskal-알고리즘"><a href="#Kruskal-알고리즘" class="headerlink" title="Kruskal 알고리즘"></a>Kruskal 알고리즘</h2><p>Kruskal 알고리즘은 가중치가 낮은 간선부터 하나씩 추가해가면서 스패닝 트리를 만들어간다. 하나의 간선을 추가했을 때 최소 스패닝 트리의 조건을 만족하는지 검사해야 하는데, 이 때 <a href="#">Post not found: boj-disjoint-set Union-Find 자료구조</a>가 유용하게 쓰인다. 해당 간선을 추가했을 때 그래프에 사이클이 생긴다면, 불필요한 간선이므로 추가할 필요가 없기 때문이다.<br><br></p><ol><li>그래프의 모든 정점을 Union-Find 자료구조로 구현한다. 처음에는 원소 각각이 상호 배타적 부분집합이 된다.</li><li>가중치가 가장 낮은 간선부터 검사한다. 두 정점이 A,B라고 가정하면 <strong>Find(A)와 Find(B)가 다른 경우에만 Union(A, B)를 실행</strong>한다. 그리고 해당 간선의 가중치를 더한다.</li><li>2번 과정을 모든 간선에 대해 반복한다.</li></ol><h2 id="Kruskal-알고리즘의-시간-복잡도"><a href="#Kruskal-알고리즘의-시간-복잡도" class="headerlink" title="Kruskal 알고리즘의 시간 복잡도"></a>Kruskal 알고리즘의 시간 복잡도</h2><p>우선 Union, Find연산의 시간 복잡도는 <strong>상수 시간으로 수렴</strong>하므로 전체 알고리즘의 복잡도에 영향을 미치지 못한다. 따라서 정렬된 (<code>O(log E)</code>) 모든 간선에 대해(<code>O(E)</code>) 검사를 진행해야 하므로, 전체 시간 복잡도는 <code>O(ElogE)</code>가 된다.</p><h2 id="BOJ-1197번-최소-스패닝-트리"><a href="#BOJ-1197번-최소-스패닝-트리" class="headerlink" title="BOJ 1197번 최소 스패닝 트리"></a>BOJ 1197번 최소 스패닝 트리</h2><figure class="highlight py"><figcaption><span>BOJ 1197번 최소 스패닝 트리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  s,e,w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph.append([w,s,e])</span><br><span class="line">parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line">rank = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a])</span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]:</span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]:</span><br><span class="line">    rank[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kruskal</span>():</span><br><span class="line">  tot_weight = <span class="number">0</span></span><br><span class="line">  graph.sort()</span><br><span class="line">  <span class="keyword">for</span> w,s,e <span class="keyword">in</span> graph:</span><br><span class="line">    <span class="keyword">if</span> find(s) != find(e):</span><br><span class="line">      union(s,e)</span><br><span class="line">      tot_weight += w</span><br><span class="line">  <span class="keyword">return</span> tot_weight</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kruskal())</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 31장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1197번 최소 스패닝 트리&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="mst" scheme="https://oxcarxierra.github.io/tags/mst/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find 자료구조 (상호 배타적 집합 Disjoint Set)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-disjoint-set/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-disjoint-set/</id>
    <published>2022-08-07T05:40:33.000Z</published>
    <updated>2022-09-29T17:39:26.761Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="상호-배타적-집합-Disjoint-Set과-Union-Find-자료구조"><a href="#상호-배타적-집합-Disjoint-Set과-Union-Find-자료구조" class="headerlink" title="상호 배타적 집합 Disjoint Set과 Union-Find 자료구조"></a>상호 배타적 집합 Disjoint Set과 Union-Find 자료구조</h2><p>집합의 원소들을 여러 개의 부분집합으로 나누되, 그 부분집합들의 교집합이 없도록 분류하는 상황을 가정해 보자. 이러한 부분집합들을 <strong>상호 배타적 집합</strong>(혹은 분리집합, Disjoint Set)이라고 하는데, 이 상황을 구현하기 위해 고안된 자료구조가 <strong>Union-Find 자료구조</strong>이다.</p><p>Union-Find 자료구조는 세 가지 연산이 가능하다.</p><ul><li>초기화 : n개의 원소가 각각의 집합에 들어있을 수 있도록 초기화</li><li><strong>Find 연산</strong> : 주어진 원소가 속한 집합을 찾아(Find) 반환</li><li><strong>Union 연산</strong> : 주어진 두 원소가 속한 집합을 하나로 합침(Union)</li></ul><h3 id="배열로-구현한-Union-Find"><a href="#배열로-구현한-Union-Find" class="headerlink" title="배열로 구현한 Union-Find"></a>배열로 구현한 Union-Find</h3><p>쉽게 생각해보면, Union-Find는 <code>arr[i] = i가 속한 집합의 번호</code> 인 1차원 배열로 생각할 수 있다. 이 경우 Find연산은 배열에 직접 접근해서 찾으면 되니<code>O(1)</code>의 복잡도를 가진다. 그러나, Union연산은 전체 배열을 훑으며 a번 집합에 속한 모든 원소를 b로 바꿔주어야 하기 때문에, <code>O(n)</code>의 복잡도를 가진다.</p><h3 id="트리를-이용해-구현한-Union-Find"><a href="#트리를-이용해-구현한-Union-Find" class="headerlink" title="트리를 이용해 구현한 Union-Find"></a>트리를 이용해 구현한 Union-Find</h3><p>Find에 걸리는 시간을 조금 늘리더라도, Union을 빠르게 할 수 있도록 고안된 것이 트리를 활용한 방법이다. <strong>하나의 집합에 속한 원소들을 트리로 연결</strong>하면, 각각의 집합은 서로 다른 루트를 가진 독립적인 트리로 생각할 수 있다. Find연산의 경우, 해당 원소의 <strong>부모 노드를 따라가서 루트에 도달</strong>하면 어떤 집합에 속해있는지 알 수 있다. 또한 Union연산은 두 원소가 속한 집합을 Find로 찾아낸 후 <strong>한 쪽 트리를 다른 쪽 트리의 아래로 합치면</strong> 된다.</p><figure class="highlight python"><figcaption><span>트리를 이용해 구현한 Union-Find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]: <span class="comment"># 원소가 트리의 루트인 경우</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> find(parent[a]) <span class="comment"># 트리를 재귀적으로 따라 올라가 루트 원소를 반환</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a = find(a)</span><br><span class="line">  b = find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="comment"># 합치려는 두 집합이 같은 경우</span></span><br><span class="line">  parent[a] = b</span><br></pre></td></tr></table></figure><p>이 경우 Find, Union 연산 모두 트리의 높이에 비례한 복잡도를 가진다. <code>O(n)</code>의 복잡도를 가졌던 1차원 배열보다 훨씬 빨라진 것을 알 수 있다.</p><h2 id="Union-Find의-최적화"><a href="#Union-Find의-최적화" class="headerlink" title="Union-Find의 최적화"></a>Union-Find의 최적화</h2><p>1부터 n까지 n개의 원소로 초기화된 상호 배타적 집합을 Union-Find 구조로 구현된 상황을 생각해보자. 1,2를 합치고, 2,3을 합치고… i와 i+1을 합치는 반복적인 연산을 한다면, 트리의 깊이는 최대 n까지 늘어난다. 그려면 Find연산의 복잡도도 <code>O(n)</code>, Union연산의 복잡도도 <code>O(n)</code>으로 오히려 효율이 나빠진다. 이렇게 트리가 한쪽으로 기울어지는 문제를 해결하고 구조를 최적화하는 방법은 Union-by-rank, 경로압축으로 두 가지가 있다.</p><h3 id="Union-by-rank"><a href="#Union-by-rank" class="headerlink" title="Union-by-rank"></a>Union-by-rank</h3><p>트리를 합치는 과정에서 높이가 낮은 트리를 높은 트리 밑으로 집어넣는다면, 두 트리의 높이가 같지 않는 이상 트리의 높이가 증가하지 않는다. 이것이 Union-by-rank 최적화로, <code>rank=[]</code> 배열에 원소가 루트인 트리의 높이를 저장하고 union연산을 할 때 높이를 비교한 후 실행하도록 수정하면 된다.<br>이 과정으로 Find와 Union연산의 복잡도를 <code>O(logN)</code>까지 줄일 수 있다.</p><figure class="highlight py"><figcaption><span>Union-by-rank 최적화</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]: <span class="comment"># 합치려는 두 트리의 높이를 비교</span></span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]: <span class="comment"># 두 트리의 높이가 같은 경우에만 트리의 높이가 1 증가</span></span><br><span class="line">    rank[b] += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="경로-압축-Path-compression"><a href="#경로-압축-Path-compression" class="headerlink" title="경로 압축 Path compression"></a>경로 압축 Path compression</h3><p>찾기 연산의 복잡도를 줄이기 위해, 이미 루트를 아는 원소는 그 루트를 저장하는 간단한 방법이 있다. 5 -&gt; 3 -&gt; 2 -&gt; 1의 순서로 루트를 찾았다면, 5의 부모노드를 1로 갱신함으로써 다음에는 5 -&gt; 1로 루트에 접근할 수 있게 된다.</p><figure class="highlight py"><figcaption><span>path compression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a]) <span class="comment"># 부모노드를 루트로 갱신</span></span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br></pre></td></tr></table></figure><p>두 최적화 방법을 모두 적용한 Union-Find 자료구조는, Find연산의 복잡도가 크게 감소한다. 특히 Find를 여러 번 수행할수록 빨라지게 되는데, 이 경우 평균적으로 <code>O(𝛼(N))</code>의 복잡도를 가진다고 한다. 𝛼(N)은 애커만 함수를 이용해 정의되는 함수인데 산술적인 N값에 대해서 그 값이 4 이하이기 때문에, 사실상 상수시간 내에 실행된다고 할 수 있다.</p><h2 id="BOJ-20040-사이클-게임"><a href="#BOJ-20040-사이클-게임" class="headerlink" title="BOJ 20040 사이클 게임"></a>BOJ 20040 사이클 게임</h2><p>Path compression만 사용해도 제한 시간 내로 통과는 되는 것을 확인할 수 있었다. 입력이 많아질 수 있기 때문에 <code>sys.stdin.readline</code>을 이용해야 한다.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><figcaption><span>BOJ 20040 사이클게임</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">rank = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a])</span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]:</span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]:</span><br><span class="line">    rank[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cycle</span>():</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    a,b= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> union(a,b) == -<span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x+<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cycle()</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 25장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 20040 사이클 게임&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 2239번 스도쿠</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-2239/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-2239/</id>
    <published>2022-08-06T16:41:40.000Z</published>
    <updated>2022-08-07T05:12:39.154Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>하다 만 스도쿠 퍼즐이 주어졌을 때, 마저 끝내는 프로그램을 작성하시오.</p><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><ul><li><a href="#">Post not found: boj-9663 BOJ 9663 N-Queen문제</a>와 비슷하게, 백트래킹을 이용한다. 초기에 0이었던 위치에 1~9를 대입해보며 같은 행/열/사각형에 겹치는 숫자가 있는지 promising을 거치며 DFS를 실행한다.</li><li><p>현재 검사하고 있는 칸을 x,y좌표로 두는 것 보다, (0,0)에서부터 순서를 정해 cnt로 정의하면 <code>cnt // 9</code>, <code>cnt % 9</code>로 좌표를 구할 수 있어 편하다.</p></li><li><p>처음에 <code>cnt==81</code> 조건 이후 <code>return</code>을 넣었더니 출력초과가 떴다. 만족하는 모든 스도쿠의 해를 출력하고 있었던 것이다. 이 때 이용할 수 있는 함수가 <code>exit()</code>으로, 도달하면 컴파일된 프로그램 전체를 종료하기 때문에 처음으로 구한 해만 출력하고 종료할 수 있게 된다.</p></li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><figcaption><span>BOJ 2239 스도쿠</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s = [[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>()] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">r, c, sq = [[<span class="literal">False</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)],[[<span class="literal">False</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)],[[<span class="literal">False</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    x = s[i][j]</span><br><span class="line">    r[i][x] = c[j][x] = sq[(i//<span class="number">3</span>)*<span class="number">3</span>+j//<span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">cnt</span>):</span><br><span class="line">  <span class="keyword">global</span> r, c, sq</span><br><span class="line">  <span class="keyword">if</span> cnt == <span class="number">81</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">      <span class="built_in">print</span>(*i, sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line">  x,y = cnt // <span class="number">9</span>, cnt%<span class="number">9</span></span><br><span class="line">  <span class="keyword">if</span> s[x][y] == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> r[x][i] <span class="keyword">and</span> <span class="keyword">not</span> c[y][i] <span class="keyword">and</span> <span class="keyword">not</span> sq[(x//<span class="number">3</span>)*<span class="number">3</span>+y//<span class="number">3</span>][i]:</span><br><span class="line">        s[x][y] = i</span><br><span class="line">        r[x][i] = c[y][i] = sq[(x//<span class="number">3</span>)*<span class="number">3</span>+y//<span class="number">3</span>][i] = <span class="literal">True</span></span><br><span class="line">        solve(cnt+<span class="number">1</span>)</span><br><span class="line">        s[x][y] = <span class="number">0</span></span><br><span class="line">        r[x][i] = c[y][i] = sq[(x//<span class="number">3</span>)*<span class="number">3</span>+y//<span class="number">3</span>][i] = <span class="literal">False</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    solve(cnt+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">solve(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;하다 만 스도쿠 퍼즐이 주어졌을 때, 마저 끝내는 프로그램을 작성하시오.&lt;/p&gt;
&lt;h2 id=&quot;접근&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="backtracking" scheme="https://oxcarxierra.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 1918번 후위 표기식</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_1918/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_1918/</id>
    <published>2022-08-02T12:28:21.000Z</published>
    <updated>2022-09-29T17:39:27.028Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="전위-중위-후위-표기식"><a href="#전위-중위-후위-표기식" class="headerlink" title="전위, 중위, 후위 표기식"></a>전위, 중위, 후위 표기식</h2><p><em>Prefix, Infix, Postfix Expression</em></p><p>일반적인 수식은 피연산자와 피연산자 사이에 연산자를 위치시킨다. A와 B를 더하는(+)연산을 기술할 때 A+B로 표현하듯이 말이다. 연산자를 피연산자들의 앞에 위치시키거나 뒤에 위치시키는 표기 방법을 각각 전위 Prefix, 후위 Postfix 표기식이라고 하며, 앞의 예시는 각각+AB, AB+로 쓸 수 있다.</p><h2 id="중위-표기식에서-후위-표기식으로의-변환"><a href="#중위-표기식에서-후위-표기식으로의-변환" class="headerlink" title="중위 표기식에서 후위 표기식으로의 변환"></a>중위 표기식에서 후위 표기식으로의 변환</h2><p>피연산자는 그 상대적인 위치가 바뀌지 않으므로, 연산자만 위치를 바꿔서 넣어주면 된다. 그러기 위해 연산자를 담아놓는 스택을 하나 만들어서, 입력된 연산자를 추가하거나 제거하면서 진행한다.</p><ol><li>입력된 수식을 문자열로 저장하고, 출력용 문자열을 빈 문자열로 초기화한다. 연산자를 담기 위한 opstack을 초기화한다.</li><li>입력 문자열을 앞에서부터 하나의 문자씩 접근한다.<ol><li>문자가 피연산자인 경우, 출력용 문자열에 추가한다.</li><li>문자가 왼쪽 괄호 ‘(‘인 경우, opstack에 push한다.</li><li>문자가 오른쪽 괄호 ‘)’인 경우, 대응하는 왼쪽 괄호 ’(‘가 나올 때 까지 opstack에서 연산자를 pop하고 문자열에 추가한다.</li><li>문자가 연산자인 경우, opstack에 push한다. 그 전에, <em>이미 opstack에 있는 연산자들 중 우선순위가 높거나 같은 것</em>들을 모두 pop한 후 문자열에 추가한다.</li></ol></li><li>입력 문자열을 모두 읽었다면 opstack에 남아있는 연산자를 차례대로 pop하고 문자열에 추가한다.</li></ol><p>처음 문제를 접근했을 때는 어떤 경우에 연산자를 하나 pop하거나 여러개를 pop해야 하는지 기준을 생각하지 못했었는데, 위의 과정 중 2-4에 그 답이 있다. 연산자의 우선순위를 딕셔너리 형식으로 저장해서, 곱셈과 나눗셈을 먼저 끝낼 수 있도록 했다.</p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">eq = <span class="built_in">input</span>().strip()</span><br><span class="line">posteq = <span class="string">&#x27;&#x27;</span></span><br><span class="line">opstack = []</span><br><span class="line">opdic=&#123;<span class="string">&#x27;(&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;-&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;*&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;/&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eq:</span><br><span class="line">    <span class="keyword">if</span> i.isalpha():</span><br><span class="line">        posteq += i</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        opstack.append(i)</span><br><span class="line">  <span class="keyword">elif</span> i==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> opstack:</span><br><span class="line">      operator = opstack.pop()</span><br><span class="line">      <span class="keyword">if</span> operator == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      posteq += operator</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> opstack <span class="keyword">and</span> opdic[opstack[-<span class="number">1</span>]] &gt;= opdic[i]:</span><br><span class="line">      posteq += opstack.pop()</span><br><span class="line">    opstack.append(i)</span><br><span class="line"><span class="keyword">while</span> opstack:</span><br><span class="line">  posteq += opstack.pop()</span><br><span class="line"><span class="built_in">print</span>(posteq)</span><br></pre></td></tr></table></figure><h2 id="추가-후위-표기식의-연산"><a href="#추가-후위-표기식의-연산" class="headerlink" title="추가) 후위 표기식의 연산"></a>추가) 후위 표기식의 연산</h2><p>우리에게 친숙한 중위표기식은 연산하기 쉽지만, 후위 표기식으로 변환된 경우 직관적이지 않다. 이 때도 스택 자료구조를 사용한다.<br>앞에서부터 문자를 하나씩 접근해서 피연산자라면 스택에 push하고, 연산자라면 스택에서 두 개의 피연산자를 pop한 후 연산한 결과를 다시 push한다.<br>예를 들어, <code>4 5 6 * +</code>의 후위표기식이 있다고 하자. 스택에 담긴 데이터는 아래와 같은 순서로 변하면서 마지막에는 최종 결과값만 남아있게 된다.</p><ul><li><code>4</code> + <code>5</code></li><li><code>4 5</code> + <code>6</code></li><li><code>4 5 6</code> + <code>*</code></li><li><code>4 30</code> + <code>+</code></li><li><code>34</code></li></ul><blockquote><p>참고자료<br>Problem Solving with Algorithms and Data Structures using Python, Chapter 4.9.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;전위-중위-후위-표기식&quot;&gt;&lt;a href=&quot;#전위-중위-후위-표기식&quot; class=&quot;headerlink&quot; title=&quot;전위, 중위, 후위 표기식&quot;&gt;&lt;/a&gt;전위, 중위, 후위 표기식&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Prefix, </summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="stack" scheme="https://oxcarxierra.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Bellman-Ford 알고리즘</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_bellman_ford/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_bellman_ford/</id>
    <published>2022-08-02T07:52:10.000Z</published>
    <updated>2022-08-06T13:59:04.235Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Bellman-Ford-알고리즘"><a href="#Bellman-Ford-알고리즘" class="headerlink" title="Bellman-Ford 알고리즘"></a>Bellman-Ford 알고리즘</h2><p>가중치 그래프의 한 노드에서 다른 노드까지의 최단경로를 찾는 탐색 알고리즘이다. Dijkstra 알고리즘과 차이점은, 가중치가 음수인 간선이 있을 때도 적용 가능한 알고리즘이다.</p><p><strong>음의 사이클</strong>이 발생할 경우, 최단경로를 찾을 수 없다. 최단거리를 무한으로 감소시킬 수 있기 때문이다.<br>Bellman-Ford 알고리즘으로 이런 음의 사이클이 존재하는지도 찾아낼 수 있다. (BOJ 1865 웜홀이 이같은 문제)</p><p>기본적인 알고리즘은 이렇다.</p><ol><li>출발 노드를 설정한다.</li><li>최단거리 배열을 초기회한다. (출발노드의 최단거리 &#x3D; 0, 나머지는 매우 큰 수 INF)</li><li>모든 간선들에 대해 해당 간선을 거쳤을 때 최단거리가 짧아지는지 검사하고, 짧아진다면 갱신한다.</li><li>이 과정을 (노드 개수)번 반복한다.</li><li>최단경로의 길이는 최대 (노드 개수)-1인데, 그보다 많이 이동하고 최단거리가 갱신된다면 음의 사이클이 존재한다고 판단할 수 있다. 즉, 마지막 반복에 최단거리 배열이 갱신된다면, -1을 return한다.</li></ol><h2 id="BOJ-11657-타임머신"><a href="#BOJ-11657-타임머신" class="headerlink" title="BOJ 11657 타임머신"></a>BOJ 11657 타임머신</h2><p>Bellman-Ford 알고리즘을 적용하면 쉽게 해결할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bf</span>():</span><br><span class="line">    dist = [INF]*(n+<span class="number">1</span>)</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> [s,e,w] <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> dist[s] != INF <span class="keyword">and</span> dist[s]+w &lt; dist[e]:</span><br><span class="line">                dist[e] = dist[s]+w</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span> <span class="keyword">if</span> dist[j] == INF <span class="keyword">else</span> dist[j] )</span><br><span class="line"></span><br><span class="line">bf()</span><br></pre></td></tr></table></figure><h2 id="BOJ-1865-웜홀"><a href="#BOJ-1865-웜홀" class="headerlink" title="BOJ 1865 웜홀"></a>BOJ 1865 웜홀</h2><p>이 문제에서는 <strong>음수 사이클</strong>의 존재 여부만 반환하면 된다. 쉬워 보이지만, 출발 노드가 정해지지 않았다는 점을 잘 고려해야 한다.<br>만약 출발 노드를 임의로 1번으로 지정한 경우, 1번 노드와 간선으로 연결되어있지 않은 노드들의 음수 사이클 존재를 알아낼 수 없다.<br>그래서 <code>if dist[s] != INF and dist[s]+w &lt; dist[e]:</code> 조건문을 수정해주었는데, 이렇게 하면 음수 사이클을 돌았을 때 값이 INF보다 작아지게 되어 존재 여부를 판단할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TC = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bellman_ford</span>(<span class="params">n, graph, start</span>):</span><br><span class="line">  dist = [INF]*(n+<span class="number">1</span>)</span><br><span class="line">  dist[start] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> [s,e,t] <span class="keyword">in</span> graph:</span><br><span class="line">      <span class="keyword">if</span> dist[e] &gt; dist[s] + t:</span><br><span class="line">        dist[e] = dist[s] + t</span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;YES&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;NO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(TC):</span><br><span class="line">  n, m, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph = []</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    s, e, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph.append([s,e,t])</span><br><span class="line">    graph.append([e,s,t])</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    s, e, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph.append([s,e,-t])</span><br><span class="line">  <span class="built_in">print</span>(bellman_ford(n,graph, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><del>‘Yes’ ‘No’로 적고 왜 틀렸습니다가 뜨는지 30분 삽질했다..</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1865 웜홀, BOJ 11657 타임머신&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="bellman-ford" scheme="https://oxcarxierra.github.io/tags/bellman-ford/"/>
    
  </entry>
  
</feed>
