<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Seungseok Oh</title>
  
  <subtitle>OXcarXierra</subtitle>
  <link href="https://oxcarxierra.github.io/feed.xml" rel="self"/>
  
  <link href="https://oxcarxierra.github.io/"/>
  <updated>2022-08-03T07:34:09.089Z</updated>
  <id>https://oxcarxierra.github.io/</id>
  
  <author>
    <name>Seungseok Oh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BOJ 1918번 후위 표기식</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj_1918/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj_1918/</id>
    <published>2022-08-02T12:28:21.000Z</published>
    <updated>2022-08-03T07:34:09.089Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="전위-중위-후위-표기식"><a href="#전위-중위-후위-표기식" class="headerlink" title="전위, 중위, 후위 표기식"></a>전위, 중위, 후위 표기식</h2><p><em>Prefix, Infix, Postfix Expression</em></p><p>일반적인 수식은 피연산자와 피연산자 사이에 연산자를 위치시킨다. A와 B를 더하는(+)연산을 기술할 때 A+B로 표현하듯이 말이다. 연산자를 피연산자들의 앞에 위치시키거나 뒤에 위치시키는 표기 방법을 각각 전위 Prefix, 후위 Postfix 표기식이라고 하며, 앞의 예시는 각각+AB, AB+로 쓸 수 있다.</p><h2 id="중위-표기식에서-후위-표기식으로의-변환"><a href="#중위-표기식에서-후위-표기식으로의-변환" class="headerlink" title="중위 표기식에서 후위 표기식으로의 변환"></a>중위 표기식에서 후위 표기식으로의 변환</h2><p>피연산자는 그 상대적인 위치가 바뀌지 않으므로, 연산자만 위치를 바꿔서 넣어주면 된다. 그러기 위해 연산자를 담아놓는 스택을 하나 만들어서, 입력된 연산자를 추가하거나 제거하면서 진행한다.</p><ol><li>입력된 수식을 문자열로 저장하고, 출력용 문자열을 빈 문자열로 초기화한다. 연산자를 담기 위한 opstack을 초기화한다.</li><li>입력 문자열을 앞에서부터 하나의 문자씩 접근한다.<ol><li>문자가 피연산자인 경우, 출력용 문자열에 추가한다.</li><li>문자가 왼쪽 괄호 ‘(‘인 경우, opstack에 push한다.</li><li>문자가 오른쪽 괄호 ‘)’인 경우, 대응하는 왼쪽 괄호 ’(‘가 나올 때 까지 opstack에서 연산자를 pop하고 문자열에 추가한다.</li><li>문자가 연산자인 경우, opstack에 push한다. 그 전에, <em>이미 opstack에 있는 연산자들 중 우선순위가 높거나 같은 것</em>들을 모두 pop한 후 문자열에 추가한다.</li></ol></li><li>입력 문자열을 모두 읽었다면 opstack에 남아있는 연산자를 차례대로 pop하고 문자열에 추가한다.</li></ol><p>처음 문제를 접근했을 때는 어떤 경우에 연산자를 하나 pop하거나 여러개를 pop해야 하는지 기준을 생각하지 못했었는데, 위의 과정 중 2-4에 그 답이 있다. 연산자의 우선순위를 딕셔너리 형식으로 저장해서, 곱셈과 나눗셈을 먼저 끝낼 수 있도록 했다.</p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">eq = <span class="built_in">input</span>().strip()</span><br><span class="line">posteq = <span class="string">&#x27;&#x27;</span></span><br><span class="line">opstack = []</span><br><span class="line">opdic=&#123;<span class="string">&#x27;(&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;-&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;*&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;/&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eq:</span><br><span class="line">    <span class="keyword">if</span> i.isalpha():</span><br><span class="line">        posteq += i</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        opstack.append(i)</span><br><span class="line">  <span class="keyword">elif</span> i==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> opstack:</span><br><span class="line">      operator = opstack.pop()</span><br><span class="line">      <span class="keyword">if</span> operator == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      posteq += operator</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> opstack <span class="keyword">and</span> opdic[opstack[-<span class="number">1</span>]] &gt;= opdic[i]:</span><br><span class="line">      posteq += opstack.pop()</span><br><span class="line">    opstack.append(i)</span><br><span class="line"><span class="keyword">while</span> opstack:</span><br><span class="line">  posteq += opstack.pop()</span><br><span class="line"><span class="built_in">print</span>(posteq)</span><br></pre></td></tr></table></figure><h2 id="추가-후위-표기식의-연산"><a href="#추가-후위-표기식의-연산" class="headerlink" title="추가) 후위 표기식의 연산"></a>추가) 후위 표기식의 연산</h2><p>우리에게 친숙한 중위표기식은 연산하기 쉽지만, 후위 표기식으로 변환된 경우 직관적이지 않다. 이 때도 스택 자료구조를 사용한다.<br>앞에서부터 문자를 하나씩 접근해서 피연산자라면 스택에 push하고, 연산자라면 스택에서 두 개의 피연산자를 pop한 후 연산한 결과를 다시 push한다.<br>예를 들어, <code>4 5 6 * +</code>의 후위표기식이 있다고 하자. 스택에 담긴 데이터는 아래와 같은 순서로 변하면서 마지막에는 최종 결과값만 남아있게 된다.</p><ul><li><code>4</code> + <code>5</code></li><li><code>4 5</code> + <code>6</code></li><li><code>4 5 6</code> + <code>*</code></li><li><code>4 30</code> + <code>+</code></li><li><code>34</code></li></ul><blockquote><p>참고문헌<br>Problem Solving with Algorithms and Data Structures using Python, Chapter 4.9.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;전위-중위-후위-표기식&quot;&gt;&lt;a href=&quot;#전위-중위-후위-표기식&quot; class=&quot;headerlink&quot; title=&quot;전위, 중위, 후위 표기식&quot;&gt;&lt;/a&gt;전위, 중위, 후위 표기식&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Prefix, </summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="stack" scheme="https://oxcarxierra.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Bellman-Ford 알고리즘</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj_bellman_ford/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj_bellman_ford/</id>
    <published>2022-08-02T07:52:10.000Z</published>
    <updated>2022-08-06T08:56:39.722Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Bellman-Ford-알고리즘"><a href="#Bellman-Ford-알고리즘" class="headerlink" title="Bellman-Ford 알고리즘"></a>Bellman-Ford 알고리즘</h2><p>가중치 그래프의 한 노드에서 다른 노드까지의 최단경로를 찾는 탐색 알고리즘이다. Dijkstra 알고리즘과 차이점은, 가중치가 음수인 간선이 있을 때도 적용 가능한 알고리즘이다.</p><p><strong>음의 사이클</strong>이 발생할 경우, 최단경로를 찾을 수 없다. 최단거리를 무한으로 감소시킬 수 있기 때문이다.<br>Bellman-Ford 알고리즘으로 이런 음의 사이클이 존재하는지도 찾아낼 수 있다. (BOJ 1865 웜홀이 이같은 문제)</p><p>기본적인 알고리즘은 이렇다.</p><ol><li>출발 노드를 설정한다.</li><li>최단거리 배열을 초기회한다. (출발노드의 최단거리 &#x3D; 0, 나머지는 매우 큰 수 INF)</li><li>모든 간선들에 대해 해당 간선을 거쳤을 때 최단거리가 짧아지는지 검사하고, 짧아진다면 갱신한다.</li><li>이 과정을 (노드 개수)번 반복한다.</li><li>최단경로의 길이는 최대 (노드 개수)-1인데, 그보다 많이 이동하고 최단거리가 갱신된다면 음의 사이클이 존재한다고 판단할 수 있다. 즉, 마지막 반복에 최단거리 배열이 갱신된다면, -1을 return한다.</li></ol><h2 id="BOJ-11657-타임머신"><a href="#BOJ-11657-타임머신" class="headerlink" title="BOJ 11657 타임머신"></a>BOJ 11657 타임머신</h2><p>Bellman-Ford 알고리즘을 적용하면 쉽게 해결할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bf</span>():</span><br><span class="line">    dist = [INF]*(n+<span class="number">1</span>)</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> [s,e,w] <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> dist[s] != INF <span class="keyword">and</span> dist[s]+w &lt; dist[e]:</span><br><span class="line">                dist[e] = dist[s]+w</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span> <span class="keyword">if</span> dist[j] == INF <span class="keyword">else</span> dist[j] )</span><br><span class="line"></span><br><span class="line">bf()</span><br></pre></td></tr></table></figure><h2 id="BOJ-1865-웜홀"><a href="#BOJ-1865-웜홀" class="headerlink" title="BOJ 1865 웜홀"></a>BOJ 1865 웜홀</h2><p>이 문제에서는 <strong>음수 사이클</strong>의 존재 여부만 반환하면 된다. 쉬워 보이지만, 출발 노드가 정해지지 않았다는 점을 잘 고려해야 한다.<br>만약 출발 노드를 임의로 1번으로 지정한 경우, 1번 노드와 간선으로 연결되어있지 않은 노드들의 음수 사이클 존재를 알아낼 수 없다.<br>그래서 <code>if dist[s] != INF and dist[s]+w &lt; dist[e]:</code> 조건문을 수정해주었는데, 이렇게 하면 음수 사이클을 돌았을 때 값이 INF보다 작아지게 되어 존재 여부를 판단할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TC = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bellman_ford</span>(<span class="params">n, graph, start</span>):</span><br><span class="line">  dist = [INF]*(n+<span class="number">1</span>)</span><br><span class="line">  dist[start] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> [s,e,t] <span class="keyword">in</span> graph:</span><br><span class="line">      <span class="keyword">if</span> dist[e] &gt; dist[s] + t:</span><br><span class="line">        dist[e] = dist[s] + t</span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;YES&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;NO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(TC):</span><br><span class="line">  n, m, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph = []</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    s, e, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph.append([s,e,t])</span><br><span class="line">    graph.append([e,s,t])</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    s, e, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph.append([s,e,-t])</span><br><span class="line">  <span class="built_in">print</span>(bellman_ford(n,graph, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><del>‘Yes’ ‘No’로 적고 왜 틀렸습니다가 뜨는지 30분 삽질했다..</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1865 웜홀, BOJ 11657 타임머신&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="bellman-ford" scheme="https://oxcarxierra.github.io/tags/bellman-ford/"/>
    
  </entry>
  
  <entry>
    <title>2022년 7월 회고록</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/july_2022_review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/july_2022_review/</id>
    <published>2022-07-31T08:47:53.000Z</published>
    <updated>2022-08-03T07:10:49.578Z</updated>
    
    <content type="html"><![CDATA[<p>7월 한 달간은 <a href="/OKR/2022-3q-okr/" title="2022년 3분기 OKR">2022년 3분기 OKR</a>의 큰 틀 내에서 작은 목표들을 성취하려고 노력했다. 코로나에 걸려서 한 주 정도 고생하기도 했다.</p><ul><li>4월에 프로젝트를 시작했던 USFK BUS 앱을 <strong>앱스토어에 배포 완료</strong>했다. Apple Developer Program 활성화에 걸린 시간을 제외하고는, 제출과정과 제출 이후 심사과정이 아주 빠르게 진행되어서 생각보다 빨리 진행할 수 있었다. 앱스토어에 내 이름으로, 내가 풀 스택으로 만든 앱이 올라와 있는 것을 보니 이렇게 뿌듯할 수가 없다. 8월에 시간이 난다면 KR중 하나인 앱 기능 확장도 진행해야겠다.</li></ul><br><ul><li><strong>2022 군장병 공개SW 온라인 해커톤 본선 진출</strong>을 위해 BOJ과 프로그래머스에서 <strong>알고리즘 공부와 PS 연습</strong>을 꾸준히 하고 있다. Class 3, 4에 선별된 문제들 위주로 7월 한달간 BOJ에서만 <strong>20일 연속 66문제</strong>를 풀었다. 티어도 7월 초에 Silver 5에서 7월 말 현재 <strong>Gold 4</strong>까지 올랐다. 그래프 이론을 하나도 모를 정도로 베이스가 없었던 것을 생각하면 꽤 빠른 속도로 많은 것을 배운 것 같다. 8월 중순에 코딩테스트가 있는데, 어느 정도 난이도로 나오는지 몰라서(후기를 찾아보면 생각보다 어려웠다는 내용 뿐이다) 일단은 난이도에 제한을 두지 않고 계속해서 PS연습을 할 계획이다.</li></ul><br><ul><li><p>또한 이론평가 대비를 위해 <strong>Dart와 Flutter 강의</strong>도 꾸준히 수강했다. 강의에서는 Windows + Android Studio로 개발을 하라고 권고하는데 나에게 익숙한 IDE인 VS Code에서도 Plugin을 잘 활용하면 충분히 효율적으로 비슷한 기능을 사용할 수 있어 좋았다. View를 구성하는 과정만 비교해보았을 땐, CSS와 비슷한 문법을 제공하는 React가 나에게는 훨씬 효율적이고 직관적으로 다가와서 아직 Flutter의 큰 장점을 느끼지 못하겠다. 기본적으로 제공하는 컴포넌트가 디자인이 잘 되어있긴 한데, 라이브러리를 활용하면 React도 충분히 구현 가능한 수준인 것 같다.</p><ul><li><span class="highlight-text success">APP 강의 수강 - Dart 언어 기초 (69%)</span></li><li><span class="highlight-text warning">APP 강의 수강 - Flutter 초급 (32%)</span></li><li><span class="highlight-text success">APP 강의 수강 - Flutter 중급 (61%)</span></li><li><span class="highlight-text danger">APP 강의 수강 - Flutter 고급 (0%)</span></li></ul></li></ul><br><ul><li>운동도 꾸준히 하고 있다. 코로나 걸렸던 기간 제외하고는 주 3일은 헬스장에 갔던 것 같다. 이렇게 시설 좋은 헬스장을 언제 또 공짜로 다녀 보겠는가!</li></ul><br><ul><li>이번 달에는 책을 한 권도 읽지 않았다. 지하철에서 책을 꺼내서 읽었던 시간에 PS에 미쳐서 BOJ을 풀어서… 다음 달에는 책 읽기를 소홀히 했던 부분을 개선해야겠다. 그리고 예선 심사에 제출해야 하는 개발계획서도 꾸준히 브레인스토밍을 해야겠다. 평가 항목중 중요도는 제일 낮지만 내 군생활 환경이 다른 만큼 오랜 시간 고민해야 하나정도 제대로 된 아이디어가 나올 것 같다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;7월 한 달간은 &lt;a href=&quot;/OKR/2022-3q-okr/&quot; title=&quot;2022년 3분기 OKR&quot;&gt;2022년 3분기 OKR&lt;/a&gt;의 큰 틀 내에서 작은 목표들을 성취하려고 노력했다. 코로나에 걸려서 한 주 정도 고생하기도 했다.&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>Floyd-Warshall 알고리즘  - BOJ 11404번 플로이드</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj_11404/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj_11404/</id>
    <published>2022-07-28T01:43:12.000Z</published>
    <updated>2022-08-06T08:56:36.171Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Floyd-Warshall-알고리즘이란"><a href="#Floyd-Warshall-알고리즘이란" class="headerlink" title="Floyd-Warshall 알고리즘이란"></a>Floyd-Warshall 알고리즘이란</h2><p>Dijkstra 알고리즘이 그래프의 정해진 한 노드에서 다른 노드까지의 최단거리를 구하는 알고리즘이었다면, Floyd-Warshall 알고리즘은 출발 노드가 따로 정해져있지 않다. 따라서 V개의 노드가 있다면 V^2개의 최단경로를 결과로 얻게 된다.</p><p>이 알고리즘의 핵심은 각 노드를 돌며 <strong>이 노드를 지나는 경로가 더 짧을 경우 갱신</strong>헤주는 방식이다.</p><ol><li>최단경로를 저장할 V by V 인접행렬을 만들고, INF값으로 초기화시킨다.</li><li>입력값을 행렬에 저장한다. 대각선 원소들에는 0을 저장한다.</li><li>각 노드를 순환하며, 다른 두 노드 사이의 최단거리가 이 노드를 거쳐갈 경우에 거리가 짧아진다면 갱신한다. (min함수를 이용한다)</li></ol><h2 id="Floyd-Warshall-알고리즘의-시간복잡도"><a href="#Floyd-Warshall-알고리즘의-시간복잡도" class="headerlink" title="Floyd-Warshall 알고리즘의 시간복잡도"></a>Floyd-Warshall 알고리즘의 시간복잡도</h2><p>단순하게 생각하면, V개의 노드를 세 번 순환을 돌았으니 O(V^3)이다.</p><h2 id="BOJ-11404-플로이드"><a href="#BOJ-11404-플로이드" class="headerlink" title="BOJ 11404 플로이드"></a>BOJ 11404 플로이드</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">dist = [[INF]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a, b, c= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  dist[a][b] = <span class="built_in">min</span>(dist[a][b],c)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">  dist[i][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">      dist[j][k] = <span class="built_in">min</span>(dist[j][k],dist[j][i] + dist[i][k])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> dist[z][y] == INF:</span><br><span class="line">            dist[z][y] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(*dist[z][<span class="number">1</span>:],sep=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>BOJ 11404에선 입력값에 같은 간선이 들어올 수 있으므로 입력받을 때에도 min함수를 이용해 비교해주어야 한다.</p><blockquote><p>참고문헌<br><a href="https://namu.wiki/w/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://namu.wiki/w/플로이드-워셜%20알고리즘</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;Floyd-Warshall-알고리즘이란&quot;&gt;&lt;a href=&quot;#Floyd-Warshall-알고리즘이란&quot; class=&quot;headerlink&quot; title=&quot;Floyd-Warshall 알고리즘이란&quot;&gt;&lt;/a&gt;Floyd-War</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="floyd-warshall" scheme="https://oxcarxierra.github.io/tags/floyd-warshall/"/>
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra 알고리즘 - BOJ 1753 최단경로</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj_1753/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj_1753/</id>
    <published>2022-07-26T13:27:45.000Z</published>
    <updated>2022-08-06T09:08:05.874Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Dijkstra-Algorithm이란"><a href="#Dijkstra-Algorithm이란" class="headerlink" title="Dijkstra Algorithm이란?"></a>Dijkstra Algorithm이란?</h2><p>그래프의 모든 단선이 음이 아닌 가중치를 가졌을 때 노드와 노드 사이의 최단경로를 구하는 알고리즘이다.</p><p>→ 다른 알고리즘으로는 플로이드-워셜 알고리즘이 있다. 이건 모든 노드쌍 사이의 최단경로 알고리즘.<br>→ 단선에 음의 가중치가 있을 땐 벨만-포드 알고리즘.</p><p>노드의 개수 V, 단선의 개수 E인 그래프에 가중치가 주어졌고, 각 노드까지의 최단경로를 저장할 distance list를 선언했다고 가정하자.</p><ol><li>출발 노드를 설정</li><li>출발 노드와 연결된 노드들의 distance 설정 (최단거리라는 보장은 없다)</li><li>방문하지 않은 노드들 중 출발 노드와 최단거리가 가장 작은 노드를 선택한다.</li><li>이 노드를 거치는 경로를 계산했을 때 더 짧은 거리가 생성된다면 distance를 고친다.</li><li>3,4과정을 모든 노드에 대해 반복한다.</li></ol><p>핵심은, 3) 방문하지 않은 노드 중 최단거리의 노드를 선택하는 과정을 반복하는 데에 있다. 문제 안의 소문제를 찾아서 해결하는 DP의 응용이기도 하다.</p><p>이 과정에서 단순 탐색을 이용하는 방법과, 우선순위 큐를 이용하는 방법이 있다.</p><h2 id="단순탐색을-이용한-Dijkstra-Algorithm"><a href="#단순탐색을-이용한-Dijkstra-Algorithm" class="headerlink" title="단순탐색을 이용한 Dijkstra Algorithm"></a>단순탐색을 이용한 Dijkstra Algorithm</h2><p>이 때는 각 노드의 방문여부를 flag로 만들어준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">graph= [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  u, v, w= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[u].append((v,w))</span><br><span class="line"></span><br><span class="line">distance = [INF]*(V+<span class="number">1</span>)</span><br><span class="line">visited = [<span class="literal">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_smallest_node</span>():</span><br><span class="line">  min_value = INF</span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[i] <span class="keyword">and</span> distance[i] &lt; min_value:</span><br><span class="line">      index = i</span><br><span class="line">      min_value = distance[i]</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">  visited[K] = <span class="literal">True</span></span><br><span class="line">  distance[K] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i,v) <span class="keyword">in</span> graph[K]:</span><br><span class="line">    distance[i] = v</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V-<span class="number">1</span>):</span><br><span class="line">    i = get_smallest_node()</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> (j,v) <span class="keyword">in</span> graph[i]:</span><br><span class="line">      <span class="keyword">if</span> distance[j] &gt; distance[i] + v:</span><br><span class="line">        distance[j] = distance[i]+ v</span><br><span class="line"></span><br><span class="line">dijkstra()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> distance[i] == INF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(distance[i])</span><br></pre></td></tr></table></figure><p>시간복잡도는 O(V^2)이다. 왜냐하면 V개의 모든 노드에 대해 3)과정을 거치며 V번의 비교를 하게 되기 때문.</p><h2 id="우선순위-큐-최소-힙-을-이용하는-Dijkstra-Algorithm"><a href="#우선순위-큐-최소-힙-을-이용하는-Dijkstra-Algorithm" class="headerlink" title="우선순위 큐(최소 힙)을 이용하는 Dijkstra Algorithm"></a>우선순위 큐(최소 힙)을 이용하는 Dijkstra Algorithm</h2><p>이 과정에서 우선순위 큐(최소 힙)을 이용한다면, 복잡도를 줄일 수 있다.<br>아래 코드는 BOJ 1753 최단경로의 답이기도 하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">graph= [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  u, v, w= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[u].append((v,w))</span><br><span class="line"></span><br><span class="line">distance = [INF]*(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">  q = []</span><br><span class="line">  distance[K] = <span class="number">0</span></span><br><span class="line">  heapq.heappush(q, (<span class="number">0</span>, K))</span><br><span class="line">  <span class="keyword">while</span> q:</span><br><span class="line">    dist, node = heapq.heappop(q)</span><br><span class="line">    <span class="keyword">if</span> distance[node] &lt; dist:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> (j,v) <span class="keyword">in</span> graph[node]:</span><br><span class="line">      cost = distance[node]+ v</span><br><span class="line">      <span class="keyword">if</span> distance[j] &gt; cost:</span><br><span class="line">        distance[j] = cost</span><br><span class="line">        heapq.heappush(q, (cost, j))</span><br><span class="line"></span><br><span class="line">dijkstra()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> distance[i] == INF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(distance[i])</span><br></pre></td></tr></table></figure><p>이 과정에서는 최단거리 노드를 찾는 데에 O(VlogV)가 필요하고(V개의 노드에 대해 힙에서 추출하는 시간 logV, 각 노드가 인접한 노드를 갱신할 때 (visited를 체크하지 않으므로) 모든 간선을 확인하는 것과 같으며 갱신될 때 logV가 필요하므로 O(ElogV)가 필요하다. 결과적으론 O((E+V)logV)가 필요한 셈.</p><p>이 부분에서 헷갈린게 있었는데, 최악의 경우 E는 V^2 스케일일 때 복잡도를 비교하면 전자가 더 빠르다. 즉 그래프가 sparse할 때만 효율적이다.</p><blockquote><p>참고문헌<br><a href="https://techblog-history-younghunjo1.tistory.com/248?category=1014800">https://techblog-history-younghunjo1.tistory.com/248?category=1014800</a><br>위 블로그가 정말 설명이 깔끔하게 잘 되어있다. 다른 알고리즘도 참고해 보아야겠다<br><a href="https://namu.wiki/w/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC">https://namu.wiki/w/다익스트라</a> 알고리즘</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;Dijkstra-Algorithm이란&quot;&gt;&lt;a href=&quot;#Dijkstra-Algorithm이란&quot; class=&quot;headerlink&quot; title=&quot;Dijkstra Algorithm이란?&quot;&gt;&lt;/a&gt;Dijkstra Al</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="dijkstra algorithm" scheme="https://oxcarxierra.github.io/tags/dijkstra-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>최장 공통 부분 수열 알고리즘</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj_lcs/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj_lcs/</id>
    <published>2022-07-25T06:48:40.000Z</published>
    <updated>2022-08-05T06:27:04.162Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Longest-Common-Substring-최장-공통-문자열"><a href="#Longest-Common-Substring-최장-공통-문자열" class="headerlink" title="Longest Common Substring, 최장 공통 문자열"></a>Longest Common Substring, 최장 공통 문자열</h2><p>Substring인 경우 최장 공통 문자열을 찾는 다른 문제가 된다.<br><br></p><ul><li>2차원 배열을 두어서 A[i]와 B의 모든 문자열을 검토.</li><li>A[i]와 B[j]가 같다면, LCS[i][j] &#x3D; LCS[i-1][j-1]+1</li><li>다르다면, LCS[i][j] &#x3D; 0</li><li>LCS중 최댓값</li></ul><h2 id="Longest-Common-Subsequence-최장-공통-부분-수열"><a href="#Longest-Common-Subsequence-최장-공통-부분-수열" class="headerlink" title="Longest Common Subsequence, 최장 공통 부분 수열"></a>Longest Common Subsequence, 최장 공통 부분 수열</h2><p>Substring의 경우와 매우 비슷하지만, A[i]와 B[j]가 다를 경우의 취급이 다르다.<br><br></p><ul><li>A[i]와 B[j]가 같다면, LCS[i][j] &#x3D; LCS[i-1][j-1]+1</li><li>다르다면, LCS[i][j] &#x3D; max(LCS[i-1][j] ,LCS[i][j-1])<br>그 이유는.. 이해하기 오래 걸렸지만 생각해보면 당연하다.<br>A[i-1]와 B[j-1]까지 비교한 상황에서 A[i]가 추가되었을 때 새롭게 늘어나는 subsequence와 B[j]의 그것을 비교해주는 논리이다.</li><li>모두 완성한 LCS의 마지막 원소</li></ul><p>완성한 LCS의 표를 마지막 원소로부터 거꾸로 올라가면 만족하는 subsequence를 얻어낼 수도 있다. 이는 BOJ 9252 LCS2 문제이기도 하다.<br><br></p><ul><li>완성한 LCS행렬의 마지막 원소에서 출발한다.</li><li>해당 원소의 왼쪽이나 위쪽(LCS[i-1][j] or LCS[i][j-1])에 같은 값이 있다면, 그쪽으로 이동한다. (나는 왼쪽부터 탐색하도록 했다.)</li><li>없다면, LCS행렬을 완성할 때 A[i]와 B[j]가 같아서 값이 증가한 값이라고 볼 수 있다. 왼쪽대각선(LCS[i-1][j-1])으로 이동한다.</li><li>이동하면서 해당 위치의 알파벳을 다른 행렬 Sequence의 끝에 저장한다.</li><li>i나 j가 0이 되었을 경우, Sequence를 뒤집으면 최장 공통 부분 수열을 얻을 수 있다.</li></ul><h2 id="BOJ-9251-LCS"><a href="#BOJ-9251-LCS" class="headerlink" title="BOJ 9251 LCS"></a>BOJ 9251 LCS</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.</p><p>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">input</span>()</span><br><span class="line">B = <span class="built_in">input</span>()</span><br><span class="line">n, m = <span class="built_in">len</span>(A),<span class="built_in">len</span>(B)</span><br><span class="line"></span><br><span class="line">LCS = [[<span class="number">0</span>]*(m+<span class="number">1</span>)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> A[j-<span class="number">1</span>] == B[i-<span class="number">1</span>]:</span><br><span class="line">      LCS[j][i] = LCS[j-<span class="number">1</span>][i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      LCS[j][i] = <span class="built_in">max</span>(LCS[j-<span class="number">1</span>][i], LCS[j][i-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(LCS[n][m])</span><br></pre></td></tr></table></figure><h2 id="BOJ-9252-LCS-2"><a href="#BOJ-9252-LCS-2" class="headerlink" title="BOJ 9252 LCS 2"></a>BOJ 9252 LCS 2</h2><h3 id="문제-1"><a href="#문제-1" class="headerlink" title="문제"></a>문제</h3><p>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.</p><p>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.</p><h3 id="풀이-1"><a href="#풀이-1" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><figcaption><span>BOJ 9252</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">input</span>()</span><br><span class="line">b = <span class="built_in">input</span>()</span><br><span class="line">la ,lb = <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">LCS = [[<span class="number">0</span>]*(lb+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(la+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, la+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lb+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> a[i-<span class="number">1</span>] == b[j-<span class="number">1</span>]:</span><br><span class="line">      LCS[i][j] = LCS[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      LCS[i][j] = <span class="built_in">max</span>(LCS[i-<span class="number">1</span>][j], LCS[i][j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">sequence = []</span><br><span class="line">x,y = la, lb</span><br><span class="line"><span class="keyword">while</span> x!=<span class="number">0</span> <span class="keyword">and</span> y!= <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> LCS[x][y] == LCS[x-<span class="number">1</span>][y]:</span><br><span class="line">    x -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">elif</span> LCS[x][y] == LCS[x][y-<span class="number">1</span>]:</span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    sequence.append(a[x-<span class="number">1</span>])</span><br><span class="line">    x-=<span class="number">1</span></span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(LCS[la][lb])</span><br><span class="line"><span class="built_in">print</span>(*<span class="built_in">reversed</span>(sequence), sep=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>참고문헌<br><a href="https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence">https://velog.io/@emplam27/알고리즘-그림으로-알아보는-LCS-알고리즘-Longest-Common-Substring와-Longest-Common-Subsequence</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 9251 LCS, BOJ 9252 LCS 2&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://oxcarxierra.github.io/tags/dp/"/>
    
    <category term="lcs" scheme="https://oxcarxierra.github.io/tags/lcs/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 11053 가장 긴 증가하는 부분수열</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-11723/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-11723/</id>
    <published>2022-07-24T03:01:19.000Z</published>
    <updated>2022-08-02T07:49:20.187Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>처음에 알고리즘을 어떻게 짜야하지 고민하다가, 검색해본 결과 아주 유명한 dp문제였다.<br>LIS, Longest Increasing Subsequence라고도 불린다.</p><h2 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h2><p>주어진 행렬 A가 있으면, A[i]를 마지막으로 가지는 가장 긴 증가하는 부분수열의 길이를 D[i]에 할당한다.</p><p>즉, A[i]를 찾는 알고리즘은 아래와 같다.</p><ol><li>A[0] &#x3D; 0, D[0] &#x3D; 0</li><li>A[0] ~ A[i-1]중 대응하는 A[i]보다 작으면서(그래야 마지막에 올 수 있으니까), 대응하는 D중 가장 큰 값을 찾는다.</li><li>그 값에 1을 더한 값울 D[i]에 할당한다.</li><li>이렇게 D를 완성하면, D[0]~D[N]중 최댓값을 찾으면 된다.<br>O(n^2)이라 느려서, 더 좋은 방법도 존재한다.</li></ol><h2 id="BOJ-11723-가장-긴-증가하는-부분수열"><a href="#BOJ-11723-가장-긴-증가하는-부분수열" class="headerlink" title="BOJ 11723 가장 긴 증가하는 부분수열"></a>BOJ 11723 가장 긴 증가하는 부분수열</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Longest Increasing Subsequence</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">A = [<span class="number">0</span>]</span><br><span class="line">A.extend(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())))</span><br><span class="line">D = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">  max_D = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; A[i]:</span><br><span class="line">      max_D = <span class="built_in">max</span>(max_D, D[j])</span><br><span class="line">  D[i] = max_D + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(D))</span><br></pre></td></tr></table></figure><blockquote><p>참고문헌<br><a href="https://namu.wiki/w/%EC%B5%9C%EC%9E%A5">https://namu.wiki/w/최장</a> 증가 부분 수열</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;p&gt;처음에 알고리즘을 어떻게 짜야하지 고민하다가, 검색해본 결과 아주 유명한 dp문제였다.&lt;br&gt;LIS, Longest Increasing Subsequence라고도 불린다.&lt;/p&gt;
&lt;h2 id=&quot;LIS&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://oxcarxierra.github.io/tags/dp/"/>
    
    <category term="lis" scheme="https://oxcarxierra.github.io/tags/lis/"/>
    
  </entry>
  
  <entry>
    <title>그리디 알고리즘(탐욕법) - BOJ 1931 회의실 배정</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-1931/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-1931/</id>
    <published>2022-07-16T08:27:45.000Z</published>
    <updated>2022-08-02T07:49:05.178Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><p>탐욕적 알고리즘(그리디 알고리즘)이 사용되는 경우는 두 가지가 있다.</p><ol><li>탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제</li><li>다른 방법으로 최적해를 찾기 너무 어려울 때 근사해를 구할 수 있음.</li></ol><p>탐욕적 알고리즘으로 찾은 해가 항상 최적해라는 정당성을 증명하려면</p><ol><li>탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것. 즉, 적어도 하나의 최적해는 이 알고리즘으로 구할 수 있다는 것.(탐욕적 선택 속성, greedy choice property)</li><li>항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 증명. (최적 부분 구조, optimal substructure) ⇒ 대부분은 자명</li></ol><h2 id="BOJ-1931-회의실-배정"><a href="#BOJ-1931-회의실-배정" class="headerlink" title="BOJ 1931 회의실 배정"></a>BOJ 1931 회의실 배정</h2><p>초기 시도: 재귀, 분할정복을 이용해보았지만 시간초과.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greedy</span>():</span><br><span class="line">  <span class="keyword">global</span> cnt, time</span><br><span class="line">  time_min = time[<span class="number">0</span>]</span><br><span class="line">  new_time=[]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> time:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> time_min[<span class="number">1</span>]&lt;=i[<span class="number">0</span>]:</span><br><span class="line">      new_time.append(i)</span><br><span class="line">  time=new_time</span><br><span class="line">  <span class="built_in">print</span>(time)</span><br><span class="line">  cnt += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> time:</span><br><span class="line">    greedy()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line"></span><br><span class="line">greedy()</span><br></pre></td></tr></table></figure><p>탐욕법 이용:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">time = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line">time.sort(key=<span class="keyword">lambda</span> t: (t[<span class="number">1</span>],t[<span class="number">0</span>]))</span><br><span class="line">end_time = time[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">  <span class="keyword">if</span> time[i][<span class="number">0</span>] &gt;= end_time:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    end_time=time[i][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;Greedy-Algorithm&quot;&gt;&lt;a href=&quot;#Greedy-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Greedy Algorithm&quot;&gt;&lt;/a&gt;Greedy Algorithm&lt;/h2&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="greedy algorithm" scheme="https://oxcarxierra.github.io/tags/greedy-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 10816번 숫자카드 2</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-10816/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-10816/</id>
    <published>2022-07-12T03:01:19.000Z</published>
    <updated>2022-08-02T07:49:14.943Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.</p><h2 id="이분탐색을-이용한-풀이-시간초과"><a href="#이분탐색을-이용한-풀이-시간초과" class="headerlink" title="이분탐색을 이용한 풀이(시간초과)"></a>이분탐색을 이용한 풀이(시간초과)</h2><p>지금까지 배웠던 이분탐색으로 접근하면 숫자를 찾을수는 있어도 그 개수는 찾지 못한다. 각 정수마다 배열을 모두 훑으면서 개수를 찾으면 시간초과.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">이분탐색으로 접근 - 실패</span><br><span class="line">deck.sort()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_card</span>(<span class="params">n</span>):</span><br><span class="line">    start = <span class="number">0</span></span><br><span class="line">    end = N-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end :</span><br><span class="line">        p = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> deck[p] &gt; n:</span><br><span class="line">            end = p - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> deck[p] &lt; n :</span><br><span class="line">            start = p + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> deck[p] == n:</span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            i, j=<span class="number">1</span>, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> p-i&gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> deck[p-i] == n:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> p+j &lt; N:</span><br><span class="line">                <span class="keyword">if</span> deck[p+j] == n:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">answer = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M):</span><br><span class="line">    answer.append(<span class="built_in">str</span>(find_card(card[i])))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(answer))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="딕셔너리를-이용한-풀이"><a href="#딕셔너리를-이용한-풀이" class="headerlink" title="딕셔너리를 이용한 풀이"></a>딕셔너리를 이용한 풀이</h2><p>숫자를 key로 가지는 딕셔너리를 활용한다면, 입력을 받음과 동시에 개수를 저장할 수 있다. 이 때의 복잡도는 O(n)으로 훨씬 빠르다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline().strip())</span><br><span class="line">deck = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br><span class="line">M = <span class="built_in">int</span>(sys.stdin.readline().strip())</span><br><span class="line">card = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">        <span class="built_in">hash</span>[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">hash</span>[i] = <span class="number">1</span></span><br><span class="line">answer = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> card:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">        answer.append(<span class="built_in">str</span>(<span class="built_in">hash</span>[i]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(answer))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>ML Library cheatsheet</title>
    <link href="https://oxcarxierra.github.io/ML/ml-library-cheatsheet/"/>
    <id>https://oxcarxierra.github.io/ML/ml-library-cheatsheet/</id>
    <published>2022-07-09T08:27:45.000Z</published>
    <updated>2022-08-02T07:50:00.381Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><p><strong>A DataFrame</strong> is a table. It contains an array of individual <em>entries.</em></p><p>row name을 <code>index = [’A’,’B’]</code>로 할당 가능</p><p><strong>A Series</strong> is a sequence of data values, a single column of a DataFrame.</p><p><code>index=[’A’,’B’],name=”SERIES NAME”</code></p><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><ul><li><code>pd.read_csv(’’, index_col=0)</code> : index_col은 가져오지 않음.</li><li><code>DataFrame.to_csv(’name.csv’)</code> : name.csv으로 저장</li><li><code>DataFrame.shape</code> : 크기 m by n</li><li><code>DataFrame.describe()</code> : count, mean, Q1, Q2, Q3…</li><li><code>DataFrame.iloc[:, 0]</code> : Index - based selection. row first, column next.</li><li><code>DataFrame.loc[: , ‘title’]</code> : Label - based selction.</li><li><code>DataFrame.set_index[‘title’]</code> : index열의 이름을 붙여줌.<br>.loc[] 내에 조건을 주어 접근 가능, &amp; , | 사용 가능</li><li><code>isin</code> : <code>reviews.country.isin([&#39;Italy&#39;, &#39;France&#39;])</code></li><li><code>isnull | notnull</code> : <code>reviews.price.notnull()</code></li><li><code>DataFrame[’column_name’]</code> : 열 접근</li><li><code>DataFrame.columns</code> : 칼럼 인덱스만 배열로 보여줌.</li></ul><h3 id="“Summary-Functions”"><a href="#“Summary-Functions”" class="headerlink" title="“Summary Functions”"></a>“Summary Functions”</h3><ul><li><code>Series.mean()</code></li><li><code>Series.unique()</code> : unique value array</li><li><code>Series.value_counts()</code> : unique value와 그 빈도</li></ul><h3 id="열의-각-원소에-접근하는-방법-2가지"><a href="#열의-각-원소에-접근하는-방법-2가지" class="headerlink" title="열의 각 원소에 접근하는 방법 2가지"></a>열의 각 원소에 접근하는 방법 2가지</h3><ul><li><code>Series.map(lambda p : ~~~ )</code> : 원소를 P로 매개변수화해서 접근</li><li><code>DataFrame.apply(method, axis=”columns”)</code> : row를 변수로 받는 메소드</li></ul><p>! 둘 다 새로운 DataFrame이나 Series를 리턴하며, 원래의 것을 변형시키지 않는다.</p><ul><li>사실 이런 연산도 가능하다 :</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">review_points_mean = reviews.points.mean()</span><br><span class="line">reviews.points - review_points_mean</span><br></pre></td></tr></table></figure><ul><li><code>DataFrame.groupby([’columnA,&#39;columnB’])</code> : column의 value가 같은 데이터를 묶는다.<br>column이 여러개인 경우 Multi-index가 생성. 말그대로 index를 구성하는 데이터가 두개 이상.<br>multi-index를 풀려면 <code>.reset_index()</code></li><li><code>DataFrame.groupby().column.agg([&#39;functionA&#39;,&#39;functionB&#39;]</code> : multi function</li><li><code>DataFrame.sort_values(by=[’columnA’,&#39;columnB&#39;], ascending=Boolean)</code> : 데이터 순서 정렬</li><li><code>DataFrame.sort_index()</code> : index순서로 정렬</li><li><code>Series.dtype</code> : column의 data type</li><li><code>Series.astype(&#39;type&#39;)</code> : column의 data type을 변환<br>! NaN은 float64타입으로 취급된다</li><li><code>pd.isnull(DataFrame.column)</code> : column의 value &#x3D; NaN인 row만 추출</li><li><code>Series.fillna(&#39;something&#39;)</code> : 해당 column의 nan값을 something으로 바꿔줌</li><li><code>Series.replace(&#39;value1&#39;,&#39;value2&#39;)</code> : 해당 column중 value1인 것들을 value2로 바꿈</li><li><code>DataFrame.rename(columns=&#123;&#39;before&#39;:&#39;after&#39;&#125;)</code></li><li><code>pd.concat([DF1,DF2])</code> : field(column)이 모두 동일한 두 DF를 합침</li><li><code>DF1.join(DF2, lsuffix=&#39;&#39;, rsuffix=&#39;&#39;)</code> : index가 동일한 두 DF를 합침. lsuffix, rsuffix는 두 DF의 같은 column이 있을 때 column name 뒤에 추가됨</li></ul><h2 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h2><p><code>plt.figure(figsize=(14,6))</code> set size of chart</p><h3 id="Line-Charts"><a href="#Line-Charts" class="headerlink" title="Line Charts"></a>Line Charts</h3><p><code>sns.lineplot(data=&#39;&#39;, label=&#39;&#39;)</code></p><h3 id="Bar-Charts"><a href="#Bar-Charts" class="headerlink" title="Bar Charts"></a>Bar Charts</h3><p><code>sns.barplot(x=column, y=column)</code></p><h3 id="Heatmap"><a href="#Heatmap" class="headerlink" title="Heatmap"></a>Heatmap</h3><p><code>sns.heatmap(data=data, annot=Boolean)</code> annot : cell 위에 숫자 표시 여부</p><h3 id="ScatterPlot"><a href="#ScatterPlot" class="headerlink" title="ScatterPlot"></a>ScatterPlot</h3><ul><li><code>sns.scatterplot(x=columnA, y=columnB, hue?=columnC)</code> : hue에 넣은 column은 색으로 구분</li><li><code>sns.regplot(x=columnA, y=columnB)</code> : regression line</li><li><code>sns.lmplot(x=columnName, y=columnName, hue=columnName, data=data)</code></li></ul><h3 id="Histogram-y축은-항상-count"><a href="#Histogram-y축은-항상-count" class="headerlink" title="Histogram : y축은 항상 count"></a>Histogram : y축은 항상 count</h3><p><code>sns.histplot(column)</code></p><h3 id="kernel-density-estimate-KDE-Plot-smoothed-histogram"><a href="#kernel-density-estimate-KDE-Plot-smoothed-histogram" class="headerlink" title="kernel density estimate (KDE) Plot : smoothed histogram"></a>kernel density estimate (KDE) Plot : smoothed histogram</h3><ul><li><code>sns.kdeplot(data=column, shade=Boolean)</code> : 1D</li><li><code>sns.jointplot(x=column, y=column, kind=&quot;kde&quot;)</code></li></ul><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p><code>sns.setstyle(&#39;option&#39;)</code></p><ul><li><code>&quot;darkgrid&quot;</code></li><li><code>&quot;whitegrid&quot;</code></li><li><code>&quot;dark&quot;</code></li><li><code>&quot;white&quot;</code></li><li><code>&quot;ticks&quot;</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;What I learned in Kaggle Pandas, Seaborn course&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ML" scheme="https://oxcarxierra.github.io/categories/ML/"/>
    
    
    <category term="pandas" scheme="https://oxcarxierra.github.io/tags/pandas/"/>
    
    <category term="seaborn" scheme="https://oxcarxierra.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>2022년 3분기 OKR</title>
    <link href="https://oxcarxierra.github.io/OKR/2022_3q_okr/"/>
    <id>https://oxcarxierra.github.io/OKR/2022_3q_okr/</id>
    <published>2022-07-04T08:47:53.000Z</published>
    <updated>2022-08-03T07:30:09.130Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h3 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h3><ol><li><strong>2022 군장병 공개SW 온라인 해커톤 참가자 선발(150명) 합격</strong></li><li><strong>사이드 프로젝트 진행</strong></li><li><strong>운동</strong></li></ol><hr><h3 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h3><ol><li><strong>2022 군장병 공개SW 온라인 해커톤 참가자 선발(150명) 합격</strong><ul><li>알고리즘 연습 - <a href="https://solved.ac/profile/oxcarxierra">백준</a> CLASS 5 &#x2F; GOLD 1 달성</li><li>알고리즘 연습 - <a href="https://school.programmers.co.kr/app/courses/14092/dashboard">프로그래머스 문제은행</a> 모두 해결</li><li>APP 강의 수강 - Dart 언어 기초 수강</li><li>APP 강의 수강 - Flutter 초급 수강</li><li>APP 강의 수강 - Flutter 중급 수강</li><li>APP 강의 수강 - Flutter 고급 수강</li><li>개발계획서 작성 - 아이디어 3개 이상 생각해서 md로 개요 작성</li></ul></li><li><strong>사이드 프로젝트 진행</strong><ul><li>USFK Bus App AppStore에 배포 완료</li><li>Camp Casey 시간표 추가 완료</li><li>다운로드수 100 달성</li></ul></li><li><strong>운동</strong><ul><li>일주일에 5일 이상 운동(휴가 제외)</li></ul></li></ol><h3 id="2022-3분기-OKR-평가"><a href="#2022-3분기-OKR-평가" class="headerlink" title="2022 3분기 OKR 평가"></a>2022 3분기 OKR 평가</h3><p>— TBA —</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h3 id=&quot;Objectives&quot;&gt;&lt;a href=&quot;#Objectives&quot; class=&quot;headerlink&quot; title=&quot;Objectives&quot;&gt;&lt;/a&gt;Objectives&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;2022 군장병 공</summary>
      
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
    <category term="okr" scheme="https://oxcarxierra.github.io/tags/okr/"/>
    
  </entry>
  
  <entry>
    <title>2022년 6월 회고록</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/june-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/june-2022-review/</id>
    <published>2022-06-30T08:47:53.000Z</published>
    <updated>2022-08-02T08:28:45.659Z</updated>
    
    <content type="html"><![CDATA[<p>그저 클론코딩이나 강의 수강에서 그친다면 그 기술을 학습했다고 할 수 없을 것이다. 개발을 공부했다면 그 내용을 바탕으로 한 산출물이 반드시 있어야 한다. 그렇기에 6월 한달은 개인 사이드 프로젝트에 매진해 보았다.</p><ul><li><p>Django와 React Native를 이용해 개발할 만한 주제를 탐색하다 USFK Bus Schedule App으로 정했고, 6월 초 간단한 구상 이후 본격적인 개발을 시작했다. 현재 백엔드 서버는 개발 및 배포가 완료되었고, 프론트엔드 앱도 기능 구현이 모두 완료되었다. 앞으로 남은건 간단한 UI 수정과 App Store 심사 및 배포 과정 정도이다. Django Model 구상 및 Django Rest Framework, MySQL DB를 다루는 방법을 배울 수 있었다.</p></li><li><p>elice에서 제공하는 <a href="https://military22.elice.io/explore"><strong>2022 군 장병 SW∙AI 역량강화 교육</strong></a>을 수강하고 있다. 배정된 수준별 ML과정을 수강해 보았는데, pandas, sklearn 등 라이브러리의 사용 방법과 기본적인 ML 알고리즘 몇 개를 배울 수 있었다. Kaggle에 도전하려는 데엔 도움이 되었지만 결국 깊이있게 이해하기 위해선 수학적 베이스도 공부해야 할 것 같다. CS229 강의를 계속 들었어야 되는데 한번 끊기니까 이해도 잘 안되고 의욕도 줄었다… 앞으로는 두 코스를 병행하도록 노력해야 겠다.</p></li><li><p>헬스를 다시 시작했다. 귀찮을 땐 방에 사둔 풀업바 이용해서 조금씩이라도 하려고 노력중이다.</p></li></ul><h3 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h3><ul><li>Dale Carnegie, <strong>&lt;인간관계론&gt;</strong><!-- 사실 각 챕터에서 다루는 주제는 당연한 말들이지만, 사람들을 대하는 태도를 평가하기에 좋은 잣대가 될 것 같다. 자기효용감의 관점으로 접근하는 방식이 인상깊었다. 어쩌면 과할 정도로 모든 내용이 궁극적으로 타인의 자기효용감을 충족시켜준다는 목적인데, 확실한 것은 그 목적으로부터 나오는 모든 행동은 긍정적인 효과를 준다는 사실이다. --></li><li>유시민, <strong>&lt;국가란 무엇인가&gt;</strong><!-- 정치는 역시 어렵다. --></li><li>무라카미 하루키, <strong>&lt;1Q84 #1&gt;</strong><!-- 소설은 역시 재밌다. --></li></ul><p>여름 한동안은 포데이 외박도 없고, 날씨와 훈련 때문이라도 많이 지치는 기간이 될 것 같다. 나가기 싫으면 차라리 방에 박혀서 공부라도 많이 해야겠다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;그저 클론코딩이나 강의 수강에서 그친다면 그 기술을 학습했다고 할 수 없을 것이다. 개발을 공부했다면 그 내용을 바탕으로 한 산출물이 반드시 있어야 한다. 그렇기에 6월 한달은 개인 사이드 프로젝트에 매진해 보았다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>USFK Bus Schedule 앱 제작 후기 및 Troubleshooting</title>
    <link href="https://oxcarxierra.github.io/Development/usfk-bus-app-review/"/>
    <id>https://oxcarxierra.github.io/Development/usfk-bus-app-review/</id>
    <published>2022-06-25T08:27:45.000Z</published>
    <updated>2022-08-02T07:50:18.553Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><p>캠프 험프리스 내 셔틀버스 시간표 앱이 있으면 좋겠다는 의견이 있었다. 마침 App Store에는 Playstore만큼 좋은 퀄리티의 시간표 앱이 없어서 직접 제작해보기로 했다. 수요는 많이 없겠지만 작년에 열심히 썼던 React Native 복습 + 새로 배운 Django 프레임워크 활용을 연습해보는 목적이었다.</p><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><blockquote><h3 id="forwardRef-의-사용"><a href="#forwardRef-의-사용" class="headerlink" title="forwardRef()의 사용"></a>forwardRef()의 사용</h3></blockquote><p>Ref는 render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공한다. useRef 메소드로 ref를 생성해서 react-native-map, scrollview등의 컴포넌트에 쓸 수 있다. 이 때 다른 컴포넌트에서 이 Ref를 참조하고 조작하려 할 때 일반적인 Props로 넘겨주면 오류가 난다.<br>이유는 <strong>함수 컴포넌트는 인스턴스가 없기 때문에 함수 컴포넌트에 ref 어트리뷰트를 사용할 수 없기 때문</strong>.</p><p>이때는 React Native의 forwardRef() 메소드로 해당 컴포넌트를 감싸서 넘겨주어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">forwardRef</span>(component);</span><br></pre></td></tr></table></figure><p>참고:<br><a href="https://merrily-code.tistory.com/121">https://merrily-code.tistory.com/121</a><br><a href="https://ko.reactjs.org/docs/refs-and-the-dom.html">https://ko.reactjs.org/docs/refs-and-the-dom.html</a></p><blockquote><h3 id="install-react-native-reanimated"><a href="#install-react-native-reanimated" class="headerlink" title="install react-native-reanimated"></a>install react-native-reanimated</h3></blockquote><p>특정 library를 사용하기 위해 react-native-reanimated를 설치해야 했는데, 과정이 까다로워서 남겨둬야겠다.<br>당연히도 yarn또는 npm으로 설치 후 pod install까지 해준다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn install react-native-reanimated</span><br><span class="line">cd ios &amp;&amp; pod install &amp;&amp; cd ..</span><br></pre></td></tr></table></figure><p>이후 babel.config.js를 아래처럼 수정해주어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;module:metro-react-native-babel-preset&#x27;</span>],</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;react-native-reanimated/plugin&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이후에 캐시를 삭제하고 다시 시도해봐도 설치 오류가 나서 헤맸는데, 결국 답은 맥북 다시시작이었다… 껐다 키니까 빌드가 성공하는 매직!<br>참고 : <a href="https://github.com/software-mansion/react-native-reanimated/issues/2774">https://github.com/software-mansion/react-native-reanimated/issues/2774</a></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>사실 백엔드쪽을 스스로 제작해보는 것은 이번이 처음이라, Django와 MySQL을 독학으로 공부할 수 밖에 없었다.</p><blockquote><h3 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs NoSQL"></a>SQL vs NoSQL</h3></blockquote><p><strong>SQL - 관계형 데이터베이스</strong><br>엄밀하게 말하자면 SQL은 Structured Query Language의 약자로 데이터베이스와 상호작용할 때 쓰이는 언어이지만, 일반적으로 관계형 데이터베이스를 말한다.</p><ul><li>SQL에는 엄격한 데이터 구조(schema)에 따라 데이터가 저장된다. 즉 하나의 테이블에 저장된 데이터는 모두 같은 구조를 가져야만 한다.</li><li><strong>DB 정규화(Normalization)</strong> : SQL에는 각 데이터가 중복 없이 단 한번씩만 저장되어야 하기 때문에(이를 <strong>무결성</strong>이라고 한다), 구조 사이의 관계를 통해 여러 테이블에 분산된다.<br>정규화에 대한 좋은 설명 : <a href="https://mangkyu.tistory.com/110">https://mangkyu.tistory.com/110</a></li><li>언제 사용하는가? : 관계를 맺고 있는 <strong>데이터가 자주 변경되고 수정되는 경우</strong> 혹은 데이터의 스키마가 명확하여 DB를 구성할 때 중요한 경우</li><li>종류: Oracle, MySQL</li></ul><p><strong>NoSQL - 비관계형 데이터베이스</strong><br>관계형 DB의 한계를 해결하기 위해 제시된 방법으로, 스키마와 관계에 의존하지 않는다. 그렇기에 훨씬 유연하고 가변적인 데이터의 저장이 가능하고<br>데이터를 가져오는 속도가 빨라진다.</p><ul><li>종류: MongoDB</li></ul><blockquote><h3 id="Default-Table-지우기"><a href="#Default-Table-지우기" class="headerlink" title="Default Table 지우기"></a>Default Table 지우기</h3></blockquote><p>django에서 기본으로 제공하는 테이블이 있어서 makemigrations 후 migrate하면 sql에 테이블이 이미 여러개가 생성되어 있다. 이번 앱에서는 관리자 기능이나 authorization이 필요가 없으므로 기본 app과 middleware를 지워줄 필요가 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># &#x27;django.contrib.admin&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.auth&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.contenttypes&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.sessions&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.messages&#x27;</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><h3 id="Django-Server에서-MySQL-DB-이용"><a href="#Django-Server에서-MySQL-DB-이용" class="headerlink" title="Django Server에서 MySQL DB 이용"></a>Django Server에서 MySQL DB 이용</h3></blockquote><p>Mysql을 처음 구동한다면 설치후 초기 user를 생성해야 한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install mysqlclient</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mysql.server start</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><h3 id="import-csv-file-to-MySQL-DB"><a href="#import-csv-file-to-MySQL-DB" class="headerlink" title="import .csv file to MySQL DB"></a>import .csv file to MySQL DB</h3></blockquote><p>csv파일에 저장된 data를 DB에 넣는 방법은 두 가지가 있다. MySQLWorkbench를 이용하는 방법과, python code로 Django ORM을 통해 DB에 데이터를 추가하는 방법이다. 처음에는 전자를 이용했는데, DB를 직접 건드린다는 리스크가 있을 뿐더러 배포용 DB를 새로 만들 때에도 확장성이 부족하여 후자를 사용하는 편이 좋은 것 같다.</p><p>manage.py가 있는 디렉토리에 db_insert.py를 아래처럼 만들었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&#x27;appname.settings.prod&#x27;</span>)</span><br><span class="line"><span class="comment"># python이 실행될 때 DJANGO_SETTINGS_MODULE라는 환경 변수에</span></span><br><span class="line"><span class="comment"># 현재 프로젝트의 settings.py 파일 경로를 등록</span></span><br><span class="line">django.setup() <span class="comment"># python manage.py shell 을 실행하는 것이랑 비슷한 방법이다. 즉 파이썬 파일에서도 django를 실행 시킬수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_data</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data/data.csv&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        data_reader = csv.reader(csvfile)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> data_reader:</span><br><span class="line">        <span class="comment">#csv파일의 각각의 row에 대해 각 원소를 row[i]로 접근하여 model.objects.create()로 생성해주면 된다.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;DATA UPLOADED SUCCESSFULY!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Splash-Screen-적용"><a href="#Splash-Screen-적용" class="headerlink" title="Splash Screen 적용"></a>Splash Screen 적용</h2><p>앱 실행 후 처음 켜지는 화면을 바꿔주는 react-native-splash-screen 라이브러리. 본 프로젝트에 적용했을 때 splash screen이 <strong>검은색 화면</strong>으로 나오는 오류가 있어서, 공식 메뉴얼부터 기술블로그까지 구글링해가며 찾아봤지만 고쳐지지 않았다. 2주간의 삽질 끝에 찾아낸 이유는 splash screen에 들어가는 이미지의 사이즈가 너무 컸던 것.</p><p>참고 :<br><a href="https://velog.io/@dody_/React-Native-%EC%95%B1-%EC%95%84%EC%9D%B4%EC%BD%98-%EB%B0%94%EA%BE%B8%EA%B8%B0">https://velog.io/@dody_/React-Native-앱-아이콘-바꾸기</a><br><a href="https://appicon.co/">https://appicon.co</a><br><a href="https://ingg.dev/rn-splash/">https://ingg.dev/rn-splash/</a><br><a href="https://stackoverflow.com/questions/63978396/launch-screen-not-working-on-ios-14-with-xcode-12">https://stackoverflow.com/questions/63978396/launch-screen-not-working-on-ios-14-with-xcode-12</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;React Native 라이브러리로 앱을, Django와 MySQL DB 기반으로 서버를 제작하며 배운 점들&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="react native" scheme="https://oxcarxierra.github.io/tags/react-native/"/>
    
    <category term="django" scheme="https://oxcarxierra.github.io/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>2022년 5월 회고록</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/may-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/may-2022-review/</id>
    <published>2022-05-31T08:47:53.000Z</published>
    <updated>2022-08-02T08:28:49.605Z</updated>
    
    <content type="html"><![CDATA[<p>이번 달 초에 다양한 사람들을 만나면서 그들의 열정과 성실함에서 참 많이 배울 수 있었다.<br>덕분에 ‘갓생’살기를 다짐했고, OKR도 세우고, 미래에 대한 다양한 고찰을 해봤던 것 같다.</p><ul><li><p>BohYoh Shibata의 <strong>&lt;자료구조와 함께 배우는 알고리즘 입문&gt;</strong> 책을 모두 읽었다. 아무래도 Backend쪽을 이해하기 위해선 필수적일 것 같아 골라온 책이다.<br>대학 강의만큼 설명의 깊이가 깊지는 않았지만, 전반적으로 어렵지 않게 이해할 수 있었다.</p></li><li><p>인프런에서 제공하는 <strong>&lt;작정하고 Django&gt;</strong> 수업을 모두 들었다. Django의 structure와 Docker에 대해 전반적으로 이해한 것 같다.<br>하지만 어떤 Tech stack도 그것을 이용해 스스로 문제를 해결해보지 않는 이상 습득했다고 하기 어렵다는 것도 알았다.<br>곧 Django를 이용한 서버를 구축하는 사이드 프로젝트를 시작해볼 것이다.</p></li><li><p>ML을 꾸준히 배워서 Kaggle이나 데이콘에 올라오는 문제들을 풀어보고 싶어졌다.<br>그래서 **&lt;밑바닥부터 시작하는 딥러닝&gt;**이라는 책으로 Python기반의 라이브러리를 사용하는 방법과, Stanford Online중 Andrew Ng의 <strong>CS229: Machine Learning</strong>강좌를 통해 ML의 기초를 동시에 공부해보고 있다. 천천히 들어도 좋으니 꾸준히 끝까지 듣도록 해보자.</p></li><li><p>주말이면 외출, 외박을 나오느라 지하철에서 소비되는 시간이 상당하다. 이번 5월엔 이 시간에 핸드폰을 집어넣고 책을 읽어봤는데, <strong>시간도 잘 가고 꽤 많은 양을 읽을 수 있었다.</strong> 앞으로도 책을 가까이하는 습관을 들여야겠다.</p></li></ul><p>전반적으로 열심히 살았던 5월이었던 것 같다.<br>6월도 이대로 보낸다면 OKR 달성은 그다지 어렵지 않을 것 같다. 아무래도 너무 쉽게 설정한 것 같으니 다음 분기 OKR에 반영해야겠다.</p><p><del>이제 일병 4호봉이라니!</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;이번 달 초에 다양한 사람들을 만나면서 그들의 열정과 성실함에서 참 많이 배울 수 있었다.&lt;br&gt;덕분에 ‘갓생’살기를 다짐했고, OKR도 세우고, 미래에 대한 다양한 고찰을 해봤던 것 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;BohYoh Shibata</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>2022년 2분기 OKR</title>
    <link href="https://oxcarxierra.github.io/OKR/2022-2q-okr/"/>
    <id>https://oxcarxierra.github.io/OKR/2022-2q-okr/</id>
    <published>2022-05-22T08:47:53.000Z</published>
    <updated>2022-08-02T07:47:15.857Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>2분기의 시작으로부터는 조금 지난 시점이지만, 존 도어의 &lt;OKR&gt;을 읽고 personal차원의 OKR을 실천해 보고자 적어보았다.</p><p>OKR을 세우는 것은 구체적이면서 신중해야 한다. 주기가 끝난 후의 피드백은 처음 세울 때 만큼이나 중요하다.<br>내가 처음부터 완벽하게 실천할 수는 없겠지만, 시행착오를 겪으며 반복한다면 OKR의 효율을 극대화한 갓생을 살 수 있지 않을까?</p><hr><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><ol><li><strong>기록을 생활화하기</strong></li><li><strong>인사이트 넓히기</strong></li><li><strong>개발 스택 갖추기</strong></li></ol><h2 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h2><ol><li><p><strong>기록을 생활화하기 (aspirational KR)</strong></p><ul><li>5, 6월 회고록 블로그에 게시하기</li><li>생각들을 기록하고 develop해서 thoughts에 글 세개 올리기</li></ul></li><li><p><strong>인사이트 넓히기 (aspirational KR)</strong></p><ul><li>책 5권 읽기(개발책 제외)</li><li>스타트업과 관련되어 10회 네트워킹하기</li></ul></li><li><p><strong>개발 스택 갖추기 (committed KR)</strong></p><ul><li>인프런 Django 강의 진행률 100퍼센트 달성하기</li><li>CS229: Machine Learning 강의 수강률 70퍼센트 달성하기</li><li>바닥부터 시작하는 딥러닝 완독하기</li><li>자료구조 알고리즘 책 완독하기</li><li>사이드 프로젝트 개발 완료(5&#x2F;31 추가, 6&#x2F;5 수정)</li></ul></li></ol><hr><h2 id="2022-2분기-OKR-평가"><a href="#2022-2분기-OKR-평가" class="headerlink" title="2022 2분기 OKR 평가"></a>2022 2분기 OKR 평가</h2><table><thead><tr><th align="left">KR</th><th align="right">Achievement</th></tr></thead><tbody><tr><td align="left">5, 6월 회고록 블로그에 게시하기</td><td align="right"><span style="background-color: #dcffe4">100% </span></td></tr><tr><td align="left">생각들을 기록하고 develop해서 thoughts에 글 세개 올리기</td><td align="right"><span style="background-color: #f7ddbe"> 33%</span></td></tr><tr><td align="left">책 5권 읽기(개발책 제외)</td><td align="right"><span style="background-color: #dcffe4">100%</span></td></tr><tr><td align="left">스타트업과 관련되어 10회 네트워킹하기</td><td align="right"><span style="background-color: #f7ddbe">30%</span></td></tr><tr><td align="left">인프런 Django 강의 진행률 100퍼센트 달성하기</td><td align="right"><span style="background-color: #dcffe4"> 100%</span></td></tr><tr><td align="left">CS229: Machine Learning 강의 수강률 70퍼센트 달성하기</td><td align="right"><span style="background-color: #ffdce0">0%</span></td></tr><tr><td align="left">바닥부터 시작하는 딥러닝 완독하기</td><td align="right"><span style="background-color: #ffdce0">0%</span></td></tr><tr><td align="left">자료구조 알고리즘 책 완독하기</td><td align="right"><span style="background-color: #dcffe4">100%</span></td></tr><tr><td align="left">사이드 프로젝트 개발 완료</td><td align="right"><span style="background-color: #dcffe4">90%</span></td></tr></tbody></table><p>쉽게 쓰여진 OKR일수록 그 가치는 절감된다. 딱 내 OKR이 그랬다. 며칠동안 만든 내용을 몇 달동안 수정도 거의 없이 유지하다보니, 도중에 생각이 바뀌어 그 필요성을 잃어버린 KR도 생겼다. 또한 최대한 측정가능한 지표 위주로 KR을 세우다 보니 일상에서 실천할 수 있는 것을 작성하기에 한계를 느끼기도 했다.<br>변명을 하자면, 회사나 소규모 팀처럼 목적을 가진 공동체와는 다르게 내 모든 목표는 하나의 통일된 목적을 가진 것이 아니기에 personal OKR은 실천 도중 변화가 많이 생길 수 밖에 없다. 또한 초기 OKR의 틀에 박혀 계획한 대로 3개월을 사는 것 보다, 하고 싶은 거 다 하면서 그 내용만 KR로서 기록하는 편이 나을지도 모르겠다. 어찌 되었건 OKR이 내 성취욕을 자극시켜 motivation이 되어준다면, 원칙과는 어긋나더라도 지속적으로 이용해보는 것이 좋을 것 같다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;p&gt;2분기의 시작으로부터는 조금 지난 시점이지만, 존 도어의 &amp;lt;OKR&amp;gt;을 읽고 personal차원의 OKR을 실천해 보고자 적어보았다.&lt;/p&gt;
&lt;p&gt;OKR을 세우는 것은 구체적이면서 신중해야 한다. 주기가 끝난 후</summary>
      
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
    <category term="okr" scheme="https://oxcarxierra.github.io/tags/okr/"/>
    
  </entry>
  
</feed>
