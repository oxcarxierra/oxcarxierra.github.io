<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OXcarXierra</title>
  
  <subtitle>Seungseok Oh</subtitle>
  <link href="https://oxcarxierra.github.io/feed.xml" rel="self"/>
  
  <link href="https://oxcarxierra.github.io/"/>
  <updated>2022-07-28T02:05:52.316Z</updated>
  <id>https://oxcarxierra.github.io/</id>
  
  <author>
    <name>Seungseok Oh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>백준 11404번 플로이드</title>
    <link href="https://oxcarxierra.github.io/algorithm/boj-11404/"/>
    <id>https://oxcarxierra.github.io/algorithm/boj-11404/</id>
    <published>2022-07-28T01:43:12.000Z</published>
    <updated>2022-07-28T02:05:52.316Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="Floyd-Warshall-알고리즘이란"><a href="#Floyd-Warshall-알고리즘이란" class="headerlink" title="Floyd-Warshall 알고리즘이란"></a>Floyd-Warshall 알고리즘이란</h3><p>Dijkstra 알고리즘이 그래프의 정해진 한 노드에서 다른 노드까지의 최단거리를 구하는 알고리즘이었다면, Floyd-Warshall 알고리즘은 출발 노드가 따로 정해져있지 않다. 따라서 V개의 노드가 있다면 V^2개의 최단경로를 결과로 얻게 된다.</p><p>이 알고리즘의 핵심은 각 노드를 돌며 <strong>이 노드를 지나는 경로가 더 짧을 경우 갱신</strong>헤주는 방식이다.</p><ol><li>최단경로를 저장할 V by V 인접행렬을 만들고, INF값으로 초기화시킨다.</li><li>입력값을 행렬에 저장한다. 대각선 원소들에는 0을 저장한다.</li><li>각 노드를 순환하며, 다른 두 노드 사이의 최단거리가 이 노드를 거쳐갈 경우에 거리가 짧아진다면 갱신한다. (min함수를 이용한다)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">dist = [[INF]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a, b, c= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  dist[a][b] = <span class="built_in">min</span>(dist[a][b],c)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">  dist[i][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">      dist[j][k] = <span class="built_in">min</span>(dist[j][k],dist[j][i] + dist[i][k])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> dist[z][y] == INF:</span><br><span class="line">            dist[z][y] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(*dist[z][<span class="number">1</span>:],sep=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>백준 11404에선 입력값에 같은 간선이 들어올 수 있으므로 입력받을 때에도 min함수를 이용해 비교해주어야 한다.</p><h3 id="Floyd-Warshall-알고리즘의-시간복잡도"><a href="#Floyd-Warshall-알고리즘의-시간복잡도" class="headerlink" title="Floyd-Warshall 알고리즘의 시간복잡도"></a>Floyd-Warshall 알고리즘의 시간복잡도</h3><p>단순하게 생각하면, V개의 노드를 세 번 순환을 돌았으니 O(V^3)이다.</p><h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p><a href="https://namu.wiki/w/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://namu.wiki/w/플로이드-워셜%20알고리즘</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;그래프의 모든 노드들 간의 최단 경로를 구하는 Floyd-Warshall 알고리즘&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://oxcarxierra.github.io/categories/algorithm/"/>
    
    
    <category term="Graph" scheme="https://oxcarxierra.github.io/tags/Graph/"/>
    
    <category term="Floyd-Warshall" scheme="https://oxcarxierra.github.io/tags/Floyd-Warshall/"/>
    
  </entry>
  
  <entry>
    <title>백준 1753 최단경로</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-1753-dijkstra-algorithm/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-1753-dijkstra-algorithm/</id>
    <published>2022-07-26T13:27:45.000Z</published>
    <updated>2022-07-27T06:04:40.021Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h3 id="Dijkstra-Algorithm이란"><a href="#Dijkstra-Algorithm이란" class="headerlink" title="Dijkstra Algorithm이란?"></a>Dijkstra Algorithm이란?</h3><p>그래프의 모든 단선이 음이 아닌 가중치를 가졌을 때 노드와 노드 사이의 최단경로를 구하는 알고리즘이다.</p><p>→ 다른 알고리즘으로는 플로이드-워셜 알고리즘이 있다. 이건 모든 노드쌍 사이의 최단경로 알고리즘.<br>→ 단선에 음의 가중치가 있을 땐 벨만-포드 알고리즘.</p><p>노드의 개수 V, 단선의 개수 E인 그래프에 가중치가 주어졌고, 각 노드까지의 최단경로를 저장할 distance list를 선언했다고 가정하자.</p><ol><li>출발 노드를 설정</li><li>출발 노드와 연결된 노드들의 distance 설정 (최단거리라는 보장은 없다)</li><li>방문하지 않은 노드들 중 출발 노드와 최단거리가 가장 작은 노드를 선택한다.</li><li>이 노드를 거치는 경로를 계산했을 때 더 짧은 거리가 생성된다면 distance를 고친다.</li><li>3,4과정을 모든 노드에 대해 반복한다.</li></ol><p>핵심은, 3) 방문하지 않은 노드 중 최단거리의 노드를 선택하는 과정을 반복하는 데에 있다. 문제 안의 소문제를 찾아서 해결하는 DP의 응용이기도 하다.</p><p>이 과정에서 단순 탐색을 이용하는 방법과, 우선순위 큐를 이용하는 방법이 있다.</p><h3 id="단순탐색을-이용한-Dijkstra-Algorithm"><a href="#단순탐색을-이용한-Dijkstra-Algorithm" class="headerlink" title="단순탐색을 이용한 Dijkstra Algorithm"></a>단순탐색을 이용한 Dijkstra Algorithm</h3><p>이 때는 각 노드의 방문여부를 flag로 만들어준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">graph= [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  u, v, w= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[u].append((v,w))</span><br><span class="line"></span><br><span class="line">distance = [INF]*(V+<span class="number">1</span>)</span><br><span class="line">visited = [<span class="literal">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_smallest_node</span>():</span><br><span class="line">  min_value = INF</span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[i] <span class="keyword">and</span> distance[i] &lt; min_value:</span><br><span class="line">      index = i</span><br><span class="line">      min_value = distance[i]</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">  visited[K] = <span class="literal">True</span></span><br><span class="line">  distance[K] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i,v) <span class="keyword">in</span> graph[K]:</span><br><span class="line">    distance[i] = v</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V-<span class="number">1</span>):</span><br><span class="line">    i = get_smallest_node()</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> (j,v) <span class="keyword">in</span> graph[i]:</span><br><span class="line">      <span class="keyword">if</span> distance[j] &gt; distance[i] + v:</span><br><span class="line">        distance[j] = distance[i]+ v</span><br><span class="line"></span><br><span class="line">dijkstra()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> distance[i] == INF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(distance[i])</span><br></pre></td></tr></table></figure><p>시간복잡도는 O(V^2)이다. 왜냐하면 V개의 모든 노드에 대해 3)과정을 거치며 V번의 비교를 하게 되기 때문.</p><h3 id="우선순위-큐-최소-힙-을-이용하는-Dijkstra-Algorithm"><a href="#우선순위-큐-최소-힙-을-이용하는-Dijkstra-Algorithm" class="headerlink" title="우선순위 큐(최소 힙)을 이용하는 Dijkstra Algorithm"></a>우선순위 큐(최소 힙)을 이용하는 Dijkstra Algorithm</h3><p>이 과정에서 우선순위 큐(최소 힙)을 이용한다면, 복잡도를 줄일 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">graph= [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  u, v, w= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[u].append((v,w))</span><br><span class="line"></span><br><span class="line">distance = [INF]*(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">  q = []</span><br><span class="line">  distance[K] = <span class="number">0</span></span><br><span class="line">  heapq.heappush(q, (<span class="number">0</span>, K))</span><br><span class="line">  <span class="keyword">while</span> q:</span><br><span class="line">    dist, node = heapq.heappop(q)</span><br><span class="line">    <span class="keyword">if</span> distance[node] &lt; dist:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> (j,v) <span class="keyword">in</span> graph[node]:</span><br><span class="line">      cost = distance[node]+ v</span><br><span class="line">      <span class="keyword">if</span> distance[j] &gt; cost:</span><br><span class="line">        distance[j] = cost</span><br><span class="line">        heapq.heappush(q, (cost, j))</span><br><span class="line"></span><br><span class="line">dijkstra()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> distance[i] == INF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(distance[i])</span><br></pre></td></tr></table></figure><p>이 과정에서는 최단거리 노드를 찾는 데에 O(VlogV)가 필요하고(V개의 노드에 대해 힙에서 추출하는 시간 logV, 각 노드가 인접한 노드를 갱신할 때 (visited를 체크하지 않으므로) 모든 간선을 확인하는 것과 같으며 갱신될 때 logV가 필요하므로 O(ElogV)가 필요하다. 결과적으론 O((E+V)logV)가 필요한 셈.</p><p>이 부분에서 헷갈린게 있었는데, 최악의 경우 E는 V^2 스케일일 때 복잡도를 비교하면 전자가 더 빠르다. 즉 그래프가 sparse할 때만 효율적이다.</p><h3 id="참고문헌"><a href="#참고문헌" class="headerlink" title="참고문헌"></a>참고문헌</h3><p><a href="https://techblog-history-younghunjo1.tistory.com/248?category=1014800">https://techblog-history-younghunjo1.tistory.com/248?category=1014800</a></p><p>위 블로그가 정말 설명이 깔끔하게 잘 되어있다. 다른 알고리즘도 참고해 보아야겠다</p><p><a href="https://namu.wiki/w/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://namu.wiki/w/다익스트라 알고리즘</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;가중치 그래프의 최단경로의 길이를 구하는 Dijkstra Algorithm을 공부해보자&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="Dijkstra Algorithm" scheme="https://oxcarxierra.github.io/tags/Dijkstra-Algorithm/"/>
    
    <category term="Graph" scheme="https://oxcarxierra.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>백준 9251 LCS</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-9251/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-9251/</id>
    <published>2022-07-25T06:48:40.000Z</published>
    <updated>2022-07-27T06:05:57.860Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="Longest-Common-Substring-최장-공통-문자열"><a href="#Longest-Common-Substring-최장-공통-문자열" class="headerlink" title="Longest Common Substring, 최장 공통 문자열"></a>Longest Common Substring, 최장 공통 문자열</h3><p>Substring인 경우 최장 공통 문자열을 찾는 다른 문제가 된다.<br><br></p><ul><li>2차원 배열을 두어서 A[i]와 B의 모든 문자열을 검토.</li><li>A[i]와 B[j]가 같다면, LCS[i][j] &#x3D; LCS[i-1][j-1]+1</li><li>다르다면, LCS[i][j] &#x3D; 0</li><li>LCS중 최댓값</li></ul><h3 id="Longest-Common-Subsequence-최장-공통-부분-수열"><a href="#Longest-Common-Subsequence-최장-공통-부분-수열" class="headerlink" title="Longest Common Subsequence, 최장 공통 부분 수열"></a>Longest Common Subsequence, 최장 공통 부분 수열</h3><p>Substring의 경우와 매우 비슷하지만, A[i]와 B[j]가 다를 경우의 취급이 다르다.<br><br></p><ul><li>A[i]와 B[j]가 같다면, LCS[i][j] &#x3D; LCS[i-1][j-1]+1</li><li>다르다면, LCS[i][j] &#x3D; max(LCS[i-1][j] ,LCS[i][j-1])<br>그 이유는.. 이해하기 오래 걸렸지만 생각해보면 당연하다.<br>A[i-1]와 B[j-1]까지 비교한 상황에서 A[i]가 추가되었을 때 새롭게 늘어나는 subsequence와 B[j]의 그것을 비교해주는 논리이다.</li><li>모두 완성한 LCS의 마지막 원소</li></ul><p>완성한 LCS의 표를 마지막 원소로부터 거꾸로 올라가면 만족하는 subsequence를 얻어낼 수도 있다. 이 방법은 위의 블로그 참고.</p><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.</p><p>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">input</span>()</span><br><span class="line">B = <span class="built_in">input</span>()</span><br><span class="line">n, m = <span class="built_in">len</span>(A),<span class="built_in">len</span>(B)</span><br><span class="line"></span><br><span class="line">LCS = [[<span class="number">0</span>]*(m+<span class="number">1</span>)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> A[j-<span class="number">1</span>] == B[i-<span class="number">1</span>]:</span><br><span class="line">      LCS[j][i] = LCS[j-<span class="number">1</span>][i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      LCS[j][i] = <span class="built_in">max</span>(LCS[j-<span class="number">1</span>][i], LCS[j][i-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(LCS[n][m])</span><br></pre></td></tr></table></figure><p>참고자료 : <a href="https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence">https:&#x2F;&#x2F;velog.io&#x2F;@emplam27&#x2F;알고리즘-그림으로-알아보는-LCS-알고리즘-Longest-Common-Substring와-Longest-Common-Subsequence</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DP를 사용하는 고전적인 알고리즘 중 하나인 LCS(최장 공통 부분 수열)&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="DP" scheme="https://oxcarxierra.github.io/tags/DP/"/>
    
    <category term="LCS" scheme="https://oxcarxierra.github.io/tags/LCS/"/>
    
  </entry>
  
  <entry>
    <title>백준 11053 가장 긴 증가하는 부분수열</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-11723/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-11723/</id>
    <published>2022-07-24T03:01:19.000Z</published>
    <updated>2022-07-27T06:06:02.943Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>처음에 알고리즘을 어떻게 짜야하지 고민하다가, 검색해본 결과 아주 유명한 dp문제였다.<br>LIS, Longest Increasing Subsequence라고도 불린다.</p><p>주어진 행렬 A가 있으면, A[i]를 마지막으로 가지는 가장 긴 증가하는 부분수열의 길이를 D[i]에 할당한다.</p><p>즉, A[i]를 찾는 알고리즘은 아래와 같다.</p><ol><li>A[0] &#x3D; 0, D[0] &#x3D; 0</li><li>A[0] ~ A[i-1]중 대응하는 A[i]보다 작으면서(그래야 마지막에 올 수 있으니까), 대응하는 D중 가장 큰 값을 찾는다.</li><li>그 값에 1을 더한 값울 D[i]에 할당한다.</li><li>이렇게 D를 완성하면, D[0]~D[N]중 최댓값을 찾으면 된다.<br>O(n^2)이라 느려서, 더 좋은 방법도 존재한다.</li></ol><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Longest Increasing Subsequence</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">A = [<span class="number">0</span>]</span><br><span class="line">A.extend(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())))</span><br><span class="line">D = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">  max_D = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; A[i]:</span><br><span class="line">      max_D = <span class="built_in">max</span>(max_D, D[j])</span><br><span class="line">  D[i] = max_D + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(D))</span><br></pre></td></tr></table></figure><p>참고자료 - <a href="https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4">https://namu.wiki/w/최장 증가 부분 수열</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;DP를 적용하는 대표적인 문제 LIS를 python으로 구현한 풀이&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="DP" scheme="https://oxcarxierra.github.io/tags/DP/"/>
    
    <category term="LIS" scheme="https://oxcarxierra.github.io/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>백준 1931 회의실 배정</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-1931/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-1931/</id>
    <published>2022-07-16T08:27:45.000Z</published>
    <updated>2022-07-27T06:05:55.267Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><p>탐욕적 알고리즘(그리디 알고리즘)이 사용되는 경우는 두 가지가 있다.</p><ol><li>탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제</li><li>다른 방법으로 최적해를 찾기 너무 어려울 때 근사해를 구할 수 있음.</li></ol><p>탐욕적 알고리즘으로 찾은 해가 항상 최적해라는 정당성을 증명하려면</p><ol><li>탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것. 즉, 적어도 하나의 최적해는 이 알고리즘으로 구할 수 있다는 것.(탐욕적 선택 속성, greedy choice property)</li><li>항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 증명. (최적 부분 구조, optimal substructure) ⇒ 대부분은 자명</li></ol><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>초기 시도: 재귀, 분할정복을 이용해보았지만 시간초과.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greedy</span>():</span><br><span class="line">  <span class="keyword">global</span> cnt, time</span><br><span class="line">  time_min = time[<span class="number">0</span>]</span><br><span class="line">  new_time=[]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> time:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> time_min[<span class="number">1</span>]&lt;=i[<span class="number">0</span>]:</span><br><span class="line">      new_time.append(i)</span><br><span class="line">  time=new_time</span><br><span class="line">  <span class="built_in">print</span>(time)</span><br><span class="line">  cnt += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> time:</span><br><span class="line">    greedy()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line"></span><br><span class="line">greedy()</span><br></pre></td></tr></table></figure><p>탐욕법 이용:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">time = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line">time.sort(key=<span class="keyword">lambda</span> t: (t[<span class="number">1</span>],t[<span class="number">0</span>]))</span><br><span class="line">end_time = time[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">  <span class="keyword">if</span> time[i][<span class="number">0</span>] &gt;= end_time:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    end_time=time[i][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Greedy Algorithm (탐욕법)의 간단한 공부와 회의실 배정 문제&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="greedy algorithm" scheme="https://oxcarxierra.github.io/tags/greedy-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>백준 10816번 숫자카드 2</title>
    <link href="https://oxcarxierra.github.io/Algorithm/boj-10816/"/>
    <id>https://oxcarxierra.github.io/Algorithm/boj-10816/</id>
    <published>2022-07-12T03:01:19.000Z</published>
    <updated>2022-07-27T06:06:00.639Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>지금까지 배웠던 이분탐색으로 접근하면 숫자를 찾을수는 있어도 그 개수는 찾지 못한다. 각 정수마다 배열을 모두 훑으면서 개수를 찾으면 시간초과.<br>숫자를 key로 가지는 딕셔너리를 활용한다면, 입력을 받음과 동시에 개수를 저장할 수 있다. 이 때의 복잡도는 O(n)으로 훨씬 빠름.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline().strip())</span><br><span class="line">deck = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br><span class="line">M = <span class="built_in">int</span>(sys.stdin.readline().strip())</span><br><span class="line">card = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split()))</span><br><span class="line"></span><br><span class="line"><span class="built_in">hash</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">        <span class="built_in">hash</span>[i] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">hash</span>[i] = <span class="number">1</span></span><br><span class="line">answer = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> card:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">        answer.append(<span class="built_in">str</span>(<span class="built_in">hash</span>[i]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        answer.append(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(answer))</span><br><span class="line"></span><br><span class="line"><span class="comment">#이분탐색으로 접근 - 실패</span></span><br><span class="line"><span class="comment"># deck.sort()</span></span><br><span class="line"><span class="comment"># def find_card(n):</span></span><br><span class="line"><span class="comment">#     start = 0</span></span><br><span class="line"><span class="comment">#     end = N-1</span></span><br><span class="line"><span class="comment">#     while start &lt;= end :</span></span><br><span class="line"><span class="comment">#         p = (start + end) // 2</span></span><br><span class="line"><span class="comment">#         if deck[p] &gt; n:</span></span><br><span class="line"><span class="comment">#             end = p - 1</span></span><br><span class="line"><span class="comment">#         elif deck[p] &lt; n :</span></span><br><span class="line"><span class="comment">#             start = p + 1</span></span><br><span class="line"><span class="comment">#         elif deck[p] == n:</span></span><br><span class="line"><span class="comment">#             cnt = 1</span></span><br><span class="line"><span class="comment">#             i, j=1, 1</span></span><br><span class="line"><span class="comment">#             while p-i&gt;= 0:</span></span><br><span class="line"><span class="comment">#                 if deck[p-i] == n:</span></span><br><span class="line"><span class="comment">#                     cnt += 1</span></span><br><span class="line"><span class="comment">#                     i += 1</span></span><br><span class="line"><span class="comment">#                 else:</span></span><br><span class="line"><span class="comment">#                     break</span></span><br><span class="line"><span class="comment">#             while p+j &lt; N:</span></span><br><span class="line"><span class="comment">#                 if deck[p+j] == n:</span></span><br><span class="line"><span class="comment">#                     cnt += 1</span></span><br><span class="line"><span class="comment">#                     j += 1</span></span><br><span class="line"><span class="comment">#                 else:</span></span><br><span class="line"><span class="comment">#                     break</span></span><br><span class="line"><span class="comment">#             return cnt</span></span><br><span class="line"><span class="comment">#     return 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># answer = []</span></span><br><span class="line"><span class="comment"># for i in range(M):</span></span><br><span class="line"><span class="comment">#     answer.append(str(find_card(card[i])))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&#x27; &#x27;.join(answer))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;해시 자료구조를 python dictionary로 구현한 풀이&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>ML Library cheatsheet</title>
    <link href="https://oxcarxierra.github.io/ML/ml-library-cheatsheet/"/>
    <id>https://oxcarxierra.github.io/ML/ml-library-cheatsheet/</id>
    <published>2022-07-09T08:27:45.000Z</published>
    <updated>2022-07-27T07:12:43.500Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><p><strong>A DataFrame</strong> is a table. It contains an array of individual <em>entries.</em></p><p>row name을 <code>index = [’A’,’B’]</code>로 할당 가능</p><p><strong>A Series</strong> is a sequence of data values, a single column of a DataFrame.</p><p><code>index=[’A’,’B’],name=”SERIES NAME”</code></p><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><ul><li><code>pd.read_csv(’’, index_col=0)</code> : index_col은 가져오지 않음.</li><li><code>DataFrame.to_csv(’name.csv’)</code> : name.csv으로 저장</li><li><code>DataFrame.shape</code> : 크기 m by n</li><li><code>DataFrame.describe()</code> : count, mean, Q1, Q2, Q3…</li><li><code>DataFrame.iloc[:, 0]</code> : Index - based selection. row first, column next.</li><li><code>DataFrame.loc[: , ‘title’]</code> : Label - based selction.</li><li><code>DataFrame.set_index[‘title’]</code> : index열의 이름을 붙여줌.<br>.loc[] 내에 조건을 주어 접근 가능, &amp; , | 사용 가능</li><li><code>isin</code> : <code>reviews.country.isin([&#39;Italy&#39;, &#39;France&#39;])</code></li><li><code>isnull | notnull</code> : <code>reviews.price.notnull()</code></li><li><code>DataFrame[’column_name’]</code> : 열 접근</li><li><code>DataFrame.columns</code> : 칼럼 인덱스만 배열로 보여줌.</li></ul><h3 id="“Summary-Functions”"><a href="#“Summary-Functions”" class="headerlink" title="“Summary Functions”"></a>“Summary Functions”</h3><ul><li><code>Series.mean()</code></li><li><code>Series.unique()</code> : unique value array</li><li><code>Series.value_counts()</code> : unique value와 그 빈도</li></ul><h3 id="열의-각-원소에-접근하는-방법-2가지"><a href="#열의-각-원소에-접근하는-방법-2가지" class="headerlink" title="열의 각 원소에 접근하는 방법 2가지"></a>열의 각 원소에 접근하는 방법 2가지</h3><ul><li><code>Series.map(lambda p : ~~~ )</code> : 원소를 P로 매개변수화해서 접근</li><li><code>DataFrame.apply(method, axis=”columns”)</code> : row를 변수로 받는 메소드</li></ul><p>! 둘 다 새로운 DataFrame이나 Series를 리턴하며, 원래의 것을 변형시키지 않는다.</p><ul><li>사실 이런 연산도 가능하다 :</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">review_points_mean = reviews.points.mean()</span><br><span class="line">reviews.points - review_points_mean</span><br></pre></td></tr></table></figure><ul><li><code>DataFrame.groupby([’columnA,&#39;columnB’])</code> : column의 value가 같은 데이터를 묶는다.<br>column이 여러개인 경우 Multi-index가 생성. 말그대로 index를 구성하는 데이터가 두개 이상.<br>multi-index를 풀려면 <code>.reset_index()</code></li><li><code>DataFrame.groupby().column.agg([&#39;functionA&#39;,&#39;functionB&#39;]</code> : multi function</li><li><code>DataFrame.sort_values(by=[’columnA’,&#39;columnB&#39;], ascending=Boolean)</code> : 데이터 순서 정렬</li><li><code>DataFrame.sort_index()</code> : index순서로 정렬</li><li><code>Series.dtype</code> : column의 data type</li><li><code>Series.astype(&#39;type&#39;)</code> : column의 data type을 변환<br>! NaN은 float64타입으로 취급된다</li><li><code>pd.isnull(DataFrame.column)</code> : column의 value &#x3D; NaN인 row만 추출</li><li><code>Series.fillna(&#39;something&#39;)</code> : 해당 column의 nan값을 something으로 바꿔줌</li><li><code>Series.replace(&#39;value1&#39;,&#39;value2&#39;)</code> : 해당 column중 value1인 것들을 value2로 바꿈</li><li><code>DataFrame.rename(columns=&#123;&#39;before&#39;:&#39;after&#39;&#125;)</code></li><li><code>pd.concat([DF1,DF2])</code> : field(column)이 모두 동일한 두 DF를 합침</li><li><code>DF1.join(DF2, lsuffix=&#39;&#39;, rsuffix=&#39;&#39;)</code> : index가 동일한 두 DF를 합침. lsuffix, rsuffix는 두 DF의 같은 column이 있을 때 column name 뒤에 추가됨</li></ul><h2 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a>Seaborn</h2><p><code>plt.figure(figsize=(14,6))</code> set size of chart</p><h3 id="Line-Charts"><a href="#Line-Charts" class="headerlink" title="Line Charts"></a>Line Charts</h3><p><code>sns.lineplot(data=&#39;&#39;, label=&#39;&#39;)</code></p><h3 id="Bar-Charts"><a href="#Bar-Charts" class="headerlink" title="Bar Charts"></a>Bar Charts</h3><p><code>sns.barplot(x=column, y=column)</code></p><h3 id="Heatmap"><a href="#Heatmap" class="headerlink" title="Heatmap"></a>Heatmap</h3><p><code>sns.heatmap(data=data, annot=Boolean)</code> annot : cell 위에 숫자 표시 여부</p><h3 id="ScatterPlot"><a href="#ScatterPlot" class="headerlink" title="ScatterPlot"></a>ScatterPlot</h3><ul><li><code>sns.scatterplot(x=columnA, y=columnB, hue?=columnC)</code> : hue에 넣은 column은 색으로 구분</li><li><code>sns.regplot(x=columnA, y=columnB)</code> : regression line</li><li><code>sns.lmplot(x=columnName, y=columnName, hue=columnName, data=data)</code></li></ul><h3 id="Histogram-y축은-항상-count"><a href="#Histogram-y축은-항상-count" class="headerlink" title="Histogram : y축은 항상 count"></a>Histogram : y축은 항상 count</h3><p><code>sns.histplot(column)</code></p><h3 id="kernel-density-estimate-KDE-Plot-smoothed-histogram"><a href="#kernel-density-estimate-KDE-Plot-smoothed-histogram" class="headerlink" title="kernel density estimate (KDE) Plot : smoothed histogram"></a>kernel density estimate (KDE) Plot : smoothed histogram</h3><ul><li><code>sns.kdeplot(data=column, shade=Boolean)</code> : 1D</li><li><code>sns.jointplot(x=column, y=column, kind=&quot;kde&quot;)</code></li></ul><h3 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h3><p><code>sns.setstyle(&#39;option&#39;)</code></p><ul><li><code>&quot;darkgrid&quot;</code></li><li><code>&quot;whitegrid&quot;</code></li><li><code>&quot;dark&quot;</code></li><li><code>&quot;white&quot;</code></li><li><code>&quot;ticks&quot;</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;What I learned in Kaggle Pandas, Seaborn course&lt;/p&gt;</summary>
    
    
    
    <category term="ML" scheme="https://oxcarxierra.github.io/categories/ML/"/>
    
    
    <category term="pandas" scheme="https://oxcarxierra.github.io/tags/pandas/"/>
    
    <category term="seaborn" scheme="https://oxcarxierra.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>2022년 3분기 OKR</title>
    <link href="https://oxcarxierra.github.io/OKR/2022_3q_okr/"/>
    <id>https://oxcarxierra.github.io/OKR/2022_3q_okr/</id>
    <published>2022-07-04T08:47:53.000Z</published>
    <updated>2022-07-25T08:59:58.661Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h3 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h3><ol><li><strong>2022 군장병 공개SW 온라인 해커톤 참가자 선발(150명) 합격</strong></li><li><strong>사이드 프로젝트 진행</strong></li><li><strong>운동</strong></li></ol><hr><h3 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h3><ol><li><strong>2022 군장병 공개SW 온라인 해커톤 참가자 선발(150명) 합격</strong><ul><li>알고리즘 연습 - <a href="https://solved.ac/profile/oxcarxierra">백준</a> CLASS 5 &#x2F; GOLD 1 달성</li><li>알고리즘 연습 - <a href="https://school.programmers.co.kr/app/courses/14092/dashboard">프로그래머스 문제은행</a> 모두 해결</li><li>APP 강의 수강 - Dart 언어 기초 수강</li><li>APP 강의 수강 - Flutter 초급 수강</li><li>APP 강의 수강 - Flutter 중급 수강</li><li>APP 강의 수강 - Flutter 고급 수강</li><li>개발계획서 작성 - 아이디어 3개 이상 생각해서 md로 개요 작성</li></ul></li><li><strong>사이드 프로젝트 진행</strong><ul><li>USFK Bus App AppStore에 배포 완료</li><li>Camp Casey 시간표 추가 완료</li><li>다운로드수 100 달성</li></ul></li><li><strong>운동</strong><ul><li>일주일에 5일 이상 운동(휴가 제외)</li></ul></li></ol><h3 id="2022-3분기-OKR-평가"><a href="#2022-3분기-OKR-평가" class="headerlink" title="2022 3분기 OKR 평가"></a>2022 3분기 OKR 평가</h3><p>— TBA —</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022년 3분기 OKR&lt;/p&gt;</summary>
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/tags/OKR/"/>
    
  </entry>
  
  <entry>
    <title>2022년 6월 회고록</title>
    <link href="https://oxcarxierra.github.io/OKR/june_2022_review/"/>
    <id>https://oxcarxierra.github.io/OKR/june_2022_review/</id>
    <published>2022-06-30T08:47:53.000Z</published>
    <updated>2022-07-26T01:56:50.880Z</updated>
    
    <content type="html"><![CDATA[<p>그저 클론코딩이나 강의 수강에서 그친다면 그 기술을 학습했다고 할 수 없을 것이다. 개발을 공부했다면 그 내용을 바탕으로 한 산출물이 반드시 있어야 한다. 그렇기에 6월 한달은 개인 사이드 프로젝트에 매진해 보았다.</p><span id="more"></span><ul><li><p>Django와 React Native를 이용해 개발할 만한 주제를 탐색하다 USFK Bus Schedule App으로 정했고, 6월 초 간단한 구상 이후 본격적인 개발을 시작했다. 현재 백엔드 서버는 개발 및 배포가 완료되었고, 프론트엔드 앱도 기능 구현이 모두 완료되었다. 앞으로 남은건 간단한 UI 수정과 App Store 심사 및 배포 과정 정도이다. Django Model 구상 및 Django Rest Framework, MySQL DB를 다루는 방법을 배울 수 있었다.</p></li><li><p>elice에서 제공하는 <a href="https://military22.elice.io/explore"><strong>2022 군 장병 SW∙AI 역량강화 교육</strong></a>을 수강하고 있다. 배정된 수준별 ML과정을 수강해 보았는데, pandas, sklearn 등 라이브러리의 사용 방법과 기본적인 ML 알고리즘 몇 개를 배울 수 있었다. Kaggle에 도전하려는 데엔 도움이 되었지만 결국 깊이있게 이해하기 위해선 수학적 베이스도 공부해야 할 것 같다. CS229 강의를 계속 들었어야 되는데 한번 끊기니까 이해도 잘 안되고 의욕도 줄었다… 앞으로는 두 코스를 병행하도록 노력해야 겠다.</p></li><li><p>헬스를 다시 시작했다. 귀찮을 땐 방에 사둔 풀업바 이용해서 조금씩이라도 하려고 노력중이다.</p></li></ul><h3 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h3><ul><li>Dale Carnegie, <strong>&lt;인간관계론&gt;</strong><!-- 사실 각 챕터에서 다루는 주제는 당연한 말들이지만, 사람들을 대하는 태도를 평가하기에 좋은 잣대가 될 것 같다. 자기효용감의 관점으로 접근하는 방식이 인상깊었다. 어쩌면 과할 정도로 모든 내용이 궁극적으로 타인의 자기효용감을 충족시켜준다는 목적인데, 확실한 것은 그 목적으로부터 나오는 모든 행동은 긍정적인 효과를 준다는 사실이다. --></li><li>유시민, <strong>&lt;국가란 무엇인가&gt;</strong><!-- 정치는 역시 어렵다. --></li><li>무라카미 하루키, <strong>&lt;1Q84 #1&gt;</strong><!-- 소설은 역시 재밌다. --></li></ul><p>여름 한동안은 포데이 외박도 없고, 날씨와 훈련 때문이라도 많이 지치는 기간이 될 것 같다. 나가기 싫으면 차라리 방에 박혀서 공부라도 많이 해야겠다.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;그저 클론코딩이나 강의 수강에서 그친다면 그 기술을 학습했다고 할 수 없을 것이다. 개발을 공부했다면 그 내용을 바탕으로 한 산출물이 반드시 있어야 한다. 그렇기에 6월 한달은 개인 사이드 프로젝트에 매진해 보았다.&lt;/p&gt;</summary>
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
    <category term="회고" scheme="https://oxcarxierra.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
  </entry>
  
  <entry>
    <title>USFK Bus Schedule 앱 제작 후기 및 Troubleshooting</title>
    <link href="https://oxcarxierra.github.io/Development/usfk-bus-app-review/"/>
    <id>https://oxcarxierra.github.io/Development/usfk-bus-app-review/</id>
    <published>2022-06-25T08:27:45.000Z</published>
    <updated>2022-07-27T06:06:56.327Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><p>캠프 험프리스 내 셔틀버스 시간표 앱이 있으면 좋겠다는 의견이 있었다. 마침 App Store에는 Playstore만큼 좋은 퀄리티의 시간표 앱이 없어서 직접 제작해보기로 했다. 수요는 많이 없겠지만 작년에 열심히 썼던 React Native 복습 + 새로 배운 Django 프레임워크 활용을 연습해보는 목적이었다.</p><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><blockquote><h3 id="forwardRef-의-사용"><a href="#forwardRef-의-사용" class="headerlink" title="forwardRef()의 사용"></a>forwardRef()의 사용</h3></blockquote><p>Ref는 render 메서드에서 생성된 DOM 노드나 React 엘리먼트에 접근하는 방법을 제공한다. useRef 메소드로 ref를 생성해서 react-native-map, scrollview등의 컴포넌트에 쓸 수 있다. 이 때 다른 컴포넌트에서 이 Ref를 참조하고 조작하려 할 때 일반적인 Props로 넘겨주면 오류가 난다.<br>이유는 <strong>함수 컴포넌트는 인스턴스가 없기 때문에 함수 컴포넌트에 ref 어트리뷰트를 사용할 수 없기 때문</strong>.</p><p>이때는 React Native의 forwardRef() 메소드로 해당 컴포넌트를 감싸서 넘겨주어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">forwardRef</span>(component);</span><br></pre></td></tr></table></figure><p>참고:<br><a href="https://merrily-code.tistory.com/121">https://merrily-code.tistory.com/121</a><br><a href="https://ko.reactjs.org/docs/refs-and-the-dom.html">https://ko.reactjs.org/docs/refs-and-the-dom.html</a></p><blockquote><h3 id="install-react-native-reanimated"><a href="#install-react-native-reanimated" class="headerlink" title="install react-native-reanimated"></a>install react-native-reanimated</h3></blockquote><p>특정 library를 사용하기 위해 react-native-reanimated를 설치해야 했는데, 과정이 까다로워서 남겨둬야겠다.<br>당연히도 yarn또는 npm으로 설치 후 pod install까지 해준다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn install react-native-reanimated</span><br><span class="line">cd ios &amp;&amp; pod install &amp;&amp; cd ..</span><br></pre></td></tr></table></figure><p>이후 babel.config.js를 아래처럼 수정해주어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&#x27;module:metro-react-native-babel-preset&#x27;</span>],</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&#x27;react-native-reanimated/plugin&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>이후에 캐시를 삭제하고 다시 시도해봐도 설치 오류가 나서 헤맸는데, 결국 답은 맥북 다시시작이었다… 껐다 키니까 빌드가 성공하는 매직!<br>참고 : <a href="https://github.com/software-mansion/react-native-reanimated/issues/2774">https://github.com/software-mansion/react-native-reanimated/issues/2774</a></p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>사실 백엔드쪽을 스스로 제작해보는 것은 이번이 처음이라, Django와 MySQL을 독학으로 공부할 수 밖에 없었다.</p><blockquote><h3 id="SQL-vs-NoSQL"><a href="#SQL-vs-NoSQL" class="headerlink" title="SQL vs NoSQL"></a>SQL vs NoSQL</h3></blockquote><p><strong>SQL - 관계형 데이터베이스</strong><br>엄밀하게 말하자면 SQL은 Structured Query Language의 약자로 데이터베이스와 상호작용할 때 쓰이는 언어이지만, 일반적으로 관계형 데이터베이스를 말한다.</p><ul><li>SQL에는 엄격한 데이터 구조(schema)에 따라 데이터가 저장된다. 즉 하나의 테이블에 저장된 데이터는 모두 같은 구조를 가져야만 한다.</li><li><strong>DB 정규화(Normalization)</strong> : SQL에는 각 데이터가 중복 없이 단 한번씩만 저장되어야 하기 때문에(이를 <strong>무결성</strong>이라고 한다), 구조 사이의 관계를 통해 여러 테이블에 분산된다.<br>정규화에 대한 좋은 설명 : <a href="https://mangkyu.tistory.com/110">https://mangkyu.tistory.com/110</a></li><li>언제 사용하는가? : 관계를 맺고 있는 <strong>데이터가 자주 변경되고 수정되는 경우</strong> 혹은 데이터의 스키마가 명확하여 DB를 구성할 때 중요한 경우</li><li>종류: Oracle, MySQL</li></ul><p><strong>NoSQL - 비관계형 데이터베이스</strong><br>관계형 DB의 한계를 해결하기 위해 제시된 방법으로, 스키마와 관계에 의존하지 않는다. 그렇기에 훨씬 유연하고 가변적인 데이터의 저장이 가능하고<br>데이터를 가져오는 속도가 빨라진다.</p><ul><li>종류: MongoDB</li></ul><blockquote><h3 id="Default-Table-지우기"><a href="#Default-Table-지우기" class="headerlink" title="Default Table 지우기"></a>Default Table 지우기</h3></blockquote><p>django에서 기본으로 제공하는 테이블이 있어서 makemigrations 후 migrate하면 sql에 테이블이 이미 여러개가 생성되어 있다. 이번 앱에서는 관리자 기능이나 authorization이 필요가 없으므로 기본 app과 middleware를 지워줄 필요가 있었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment"># &#x27;django.contrib.admin&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.auth&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.contenttypes&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.sessions&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.messages&#x27;</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;rest_framework&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span></span><br><span class="line">    <span class="comment"># &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><h3 id="Django-Server에서-MySQL-DB-이용"><a href="#Django-Server에서-MySQL-DB-이용" class="headerlink" title="Django Server에서 MySQL DB 이용"></a>Django Server에서 MySQL DB 이용</h3></blockquote><p>Mysql을 처음 구동한다면 설치후 초기 user를 생성해야 한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install mysqlclient</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mysql.server start</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><blockquote><h3 id="import-csv-file-to-MySQL-DB"><a href="#import-csv-file-to-MySQL-DB" class="headerlink" title="import .csv file to MySQL DB"></a>import .csv file to MySQL DB</h3></blockquote><p>csv파일에 저장된 data를 DB에 넣는 방법은 두 가지가 있다. MySQLWorkbench를 이용하는 방법과, python code로 Django ORM을 통해 DB에 데이터를 추가하는 방법이다. 처음에는 전자를 이용했는데, DB를 직접 건드린다는 리스크가 있을 뿐더러 배포용 DB를 새로 만들 때에도 확장성이 부족하여 후자를 사용하는 편이 좋은 것 같다.</p><p>manage.py가 있는 디렉토리에 db_insert.py를 아래처럼 만들었다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&#x27;appname.settings.prod&#x27;</span>)</span><br><span class="line"><span class="comment"># python이 실행될 때 DJANGO_SETTINGS_MODULE라는 환경 변수에</span></span><br><span class="line"><span class="comment"># 현재 프로젝트의 settings.py 파일 경로를 등록</span></span><br><span class="line">django.setup() <span class="comment"># python manage.py shell 을 실행하는 것이랑 비슷한 방법이다. 즉 파이썬 파일에서도 django를 실행 시킬수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_data</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data/data.csv&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        data_reader = csv.reader(csvfile)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> data_reader:</span><br><span class="line">        <span class="comment">#csv파일의 각각의 row에 대해 각 원소를 row[i]로 접근하여 model.objects.create()로 생성해주면 된다.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;DATA UPLOADED SUCCESSFULY!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Splash-Screen-적용"><a href="#Splash-Screen-적용" class="headerlink" title="Splash Screen 적용"></a>Splash Screen 적용</h2><p>앱 실행 후 처음 켜지는 화면을 바꿔주는 react-native-splash-screen 라이브러리. 본 프로젝트에 적용했을 때 splash screen이 <strong>검은색 화면</strong>으로 나오는 오류가 있어서, 공식 메뉴얼부터 기술블로그까지 구글링해가며 찾아봤지만 고쳐지지 않았다. 2주간의 삽질 끝에 찾아낸 이유는 splash screen에 들어가는 이미지의 사이즈가 너무 컸던 것.</p><p>참고 :<br><a href="https://velog.io/@dody_/React-Native-%EC%95%B1-%EC%95%84%EC%9D%B4%EC%BD%98-%EB%B0%94%EA%BE%B8%EA%B8%B0">https://velog.io/@dody_/React-Native-앱-아이콘-바꾸기</a><br><a href="https://appicon.co/">https://appicon.co</a><br><a href="https://ingg.dev/rn-splash/">https://ingg.dev/rn-splash/</a><br><a href="https://stackoverflow.com/questions/63978396/launch-screen-not-working-on-ios-14-with-xcode-12">https://stackoverflow.com/questions/63978396/launch-screen-not-working-on-ios-14-with-xcode-12</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;React Native 라이브러리로 앱을, Django와 MySQL DB 기반으로 서버를 제작하며 배운 점들&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
    <category term="React Native" scheme="https://oxcarxierra.github.io/tags/React-Native/"/>
    
    <category term="Django" scheme="https://oxcarxierra.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>2022년 5월 회고록</title>
    <link href="https://oxcarxierra.github.io/OKR/may_2022_review/"/>
    <id>https://oxcarxierra.github.io/OKR/may_2022_review/</id>
    <published>2022-05-31T08:47:53.000Z</published>
    <updated>2022-07-26T01:57:19.168Z</updated>
    
    <content type="html"><![CDATA[<p>이번 달 초에 다양한 사람들을 만나면서 그들의 열정과 성실함에서 참 많이 배울 수 있었다.<br>덕분에 ‘갓생’살기를 다짐했고, OKR도 세우고, 미래에 대한 다양한 고찰을 해봤던 것 같다.</p><span id="more"></span><ul><li><p>BohYoh Shibata의 <strong>&lt;자료구조와 함께 배우는 알고리즘 입문&gt;</strong> 책을 모두 읽었다. 아무래도 Backend쪽을 이해하기 위해선 필수적일 것 같아 골라온 책이다.<br>대학 강의만큼 설명의 깊이가 깊지는 않았지만, 전반적으로 어렵지 않게 이해할 수 있었다.</p></li><li><p>인프런에서 제공하는 <strong>&lt;작정하고 Django&gt;</strong> 수업을 모두 들었다. Django의 structure와 Docker에 대해 전반적으로 이해한 것 같다.<br>하지만 어떤 Tech stack도 그것을 이용해 스스로 문제를 해결해보지 않는 이상 습득했다고 하기 어렵다는 것도 알았다.<br>곧 Django를 이용한 서버를 구축하는 사이드 프로젝트를 시작해볼 것이다.</p></li><li><p>ML을 꾸준히 배워서 Kaggle이나 데이콘에 올라오는 문제들을 풀어보고 싶어졌다.<br>그래서 **&lt;밑바닥부터 시작하는 딥러닝&gt;**이라는 책으로 Python기반의 라이브러리를 사용하는 방법과, Stanford Online중 Andrew Ng의 <strong>CS229: Machine Learning</strong>강좌를 통해 ML의 기초를 동시에 공부해보고 있다. 천천히 들어도 좋으니 꾸준히 끝까지 듣도록 해보자.</p></li><li><p>주말이면 외출, 외박을 나오느라 지하철에서 소비되는 시간이 상당하다. 이번 5월엔 이 시간에 핸드폰을 집어넣고 책을 읽어봤는데, <strong>시간도 잘 가고 꽤 많은 양을 읽을 수 있었다.</strong> 앞으로도 책을 가까이하는 습관을 들여야겠다.</p></li></ul><p>전반적으로 열심히 살았던 5월이었던 것 같다.<br>6월도 이대로 보낸다면 OKR 달성은 그다지 어렵지 않을 것 같다. 아무래도 너무 쉽게 설정한 것 같으니 다음 분기 OKR에 반영해야겠다.</p><p><del>이제 일병 4호봉이라니!</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;이번 달 초에 다양한 사람들을 만나면서 그들의 열정과 성실함에서 참 많이 배울 수 있었다.&lt;br&gt;덕분에 ‘갓생’살기를 다짐했고, OKR도 세우고, 미래에 대한 다양한 고찰을 해봤던 것 같다.&lt;/p&gt;</summary>
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
    <category term="회고" scheme="https://oxcarxierra.github.io/tags/%ED%9A%8C%EA%B3%A0/"/>
    
  </entry>
  
  <entry>
    <title>2022년 2분기 OKR</title>
    <link href="https://oxcarxierra.github.io/OKR/2022_2q_okr/"/>
    <id>https://oxcarxierra.github.io/OKR/2022_2q_okr/</id>
    <published>2022-05-22T08:47:53.000Z</published>
    <updated>2022-07-26T01:58:05.486Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><p>2분기의 시작으로부터는 조금 지난 시점이지만, 존 도어의 &lt;OKR&gt;을 읽고 personal차원의 OKR을 실천해 보고자 적어보았다.</p><p>OKR을 세우는 것은 구체적이면서 신중해야 한다. 주기가 끝난 후의 피드백은 처음 세울 때 만큼이나 중요하다.<br>내가 처음부터 완벽하게 실천할 수는 없겠지만, 시행착오를 겪으며 반복한다면 OKR의 효율을 극대화한 갓생을 살 수 있지 않을까?</p><hr><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><ol><li><strong>기록을 생활화하기</strong></li><li><strong>인사이트 넓히기</strong></li><li><strong>개발 스택 갖추기</strong></li></ol><h2 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h2><ol><li><p><strong>기록을 생활화하기 (aspirational KR)</strong></p><ul><li>5, 6월 회고록 블로그에 게시하기</li><li>생각들을 기록하고 develop해서 thoughts에 글 세개 올리기</li></ul></li><li><p><strong>인사이트 넓히기 (aspirational KR)</strong></p><ul><li>책 5권 읽기(개발책 제외)</li><li>스타트업과 관련되어 10회 네트워킹하기</li></ul></li><li><p><strong>개발 스택 갖추기 (committed KR)</strong></p><ul><li>인프런 Django 강의 진행률 100퍼센트 달성하기</li><li>CS229: Machine Learning 강의 수강률 70퍼센트 달성하기</li><li>바닥부터 시작하는 딥러닝 완독하기</li><li>자료구조 알고리즘 책 완독하기</li><li>사이드 프로젝트 개발 완료(5&#x2F;31 추가, 6&#x2F;5 수정)</li></ul></li></ol><hr><h2 id="2022-2분기-OKR-평가"><a href="#2022-2분기-OKR-평가" class="headerlink" title="2022 2분기 OKR 평가"></a>2022 2분기 OKR 평가</h2><table><thead><tr><th align="left">KR</th><th align="right">Achievement</th></tr></thead><tbody><tr><td align="left">5, 6월 회고록 블로그에 게시하기</td><td align="right"><span style="background-color: #dcffe4">100% </span></td></tr><tr><td align="left">생각들을 기록하고 develop해서 thoughts에 글 세개 올리기</td><td align="right"><span style="background-color: #f7ddbe"> 33%</span></td></tr><tr><td align="left">책 5권 읽기(개발책 제외)</td><td align="right"><span style="background-color: #dcffe4">100%</span></td></tr><tr><td align="left">스타트업과 관련되어 10회 네트워킹하기</td><td align="right"><span style="background-color: #f7ddbe">30%</span></td></tr><tr><td align="left">인프런 Django 강의 진행률 100퍼센트 달성하기</td><td align="right"><span style="background-color: #dcffe4"> 100%</span></td></tr><tr><td align="left">CS229: Machine Learning 강의 수강률 70퍼센트 달성하기</td><td align="right"><span style="background-color: #ffdce0">0%</span></td></tr><tr><td align="left">바닥부터 시작하는 딥러닝 완독하기</td><td align="right"><span style="background-color: #ffdce0">0%</span></td></tr><tr><td align="left">자료구조 알고리즘 책 완독하기</td><td align="right"><span style="background-color: #dcffe4">100%</span></td></tr><tr><td align="left">사이드 프로젝트 개발 완료</td><td align="right"><span style="background-color: #dcffe4">90%</span></td></tr></tbody></table><p>쉽게 쓰여진 OKR일수록 그 가치는 절감된다. 딱 내 OKR이 그랬다. 며칠동안 만든 내용을 몇 달동안 수정도 거의 없이 유지하다보니, 도중에 생각이 바뀌어 그 필요성을 잃어버린 KR도 생겼다. 또한 최대한 측정가능한 지표 위주로 KR을 세우다 보니 일상에서 실천할 수 있는 것을 작성하기에 한계를 느끼기도 했다.<br>변명을 하자면, 회사나 소규모 팀처럼 목적을 가진 공동체와는 다르게 내 모든 목표는 하나의 통일된 목적을 가진 것이 아니기에 personal OKR은 실천 도중 변화가 많이 생길 수 밖에 없다. 또한 초기 OKR의 틀에 박혀 계획한 대로 3개월을 사는 것 보다, 하고 싶은 거 다 하면서 그 내용만 KR로서 기록하는 편이 나을지도 모르겠다. 어찌 되었건 OKR이 내 성취욕을 자극시켜 motivation이 되어준다면, 원칙과는 어긋나더라도 지속적으로 이용해보는 것이 좋을 것 같다.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2022년 2분기 OKR과 평가&lt;/p&gt;</summary>
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/tags/OKR/"/>
    
  </entry>
  
</feed>
