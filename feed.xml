<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Seungseok Oh</title>
  
  <subtitle>OXcarXierra</subtitle>
  <link href="https://oxcarxierra.github.io/feed.xml" rel="self"/>
  
  <link href="https://oxcarxierra.github.io/"/>
  <updated>2022-10-04T19:14:27.672Z</updated>
  <id>https://oxcarxierra.github.io/</id>
  
  <author>
    <name>Seungseok Oh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2022년 4분기 OKR</title>
    <link href="https://oxcarxierra.github.io/OKR/2022/2022-4q-okr/"/>
    <id>https://oxcarxierra.github.io/OKR/2022/2022-4q-okr/</id>
    <published>2022-10-02T01:50:18.000Z</published>
    <updated>2022-10-04T19:14:27.672Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="Objectives"><a href="#Objectives" class="headerlink" title="Objectives"></a>Objectives</h2><ol><li><strong>경진대회 준비</strong></li><li><strong>꾸준한 자기개발</strong></li></ol><h2 id="Key-Results"><a href="#Key-Results" class="headerlink" title="Key Results"></a>Key Results</h2><ol><li><strong>경진대회 준비</strong></li></ol><ul><li>2022 OSAM 국방 해커톤 1위 수상</li><li>제 8회 육군창업경진대회 본선 진출 및 수상</li></ul><ol start="2"><li><strong>꾸준한 자기개발</strong></li></ol><ul><li>경제, 금융 기초지식 공부하기</li><li>책 7권 읽기</li><li>운동(농구 헬스 포함) 일주일에 3번 이상 하기</li></ul><blockquote><p>목표가 생기거나 바뀔 때 마다 OKR은 유연하게 수정해도 됨!</p></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;Objectives&quot;&gt;&lt;a href=&quot;#Objectives&quot; class=&quot;headerlink&quot; title=&quot;Objectives&quot;&gt;&lt;/a&gt;Objectives&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;경진대회 준비&lt;/s</summary>
      
    
    
    
    <category term="OKR" scheme="https://oxcarxierra.github.io/categories/OKR/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 9월 회고록</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/september-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/september-2022-review/</id>
    <published>2022-09-29T17:17:42.000Z</published>
    <updated>2022-10-03T13:45:11.611Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>9월엔 포데이 3번에, 2박 3일 휴가까지 써서 부대보다 사회에 있었던 시간이 더 많았다. <del>이게 군인이 맞냐?</del> 그치만 시간을 효율적으로 잘 보냈냐고 물어보면 잘 모르겠다.. 사람도 많이 만나고 개인적으로 재충전하느라 공부는 많이 못했다. 이럴 때 쉬어줘야지 느낌으로 자기합리화하는중.</p><br><ul><li><strong>군장병 공개SW 온라인 해커톤 본선</strong>에 진출했다. 9&#x2F;7에 참가자 발표가 났고, 나는 고등학교 친구가 낸 주제에 팀원으로 합류했다. 다른 장병분들도 주제를 보고 지원해 주셔서 총 7명의 거대 팀을 구성할 수 있었다. 모인 분들의 스펙이 대단하셔서 엄청 놀랐다.. 자세한 후기는 <a href="">OSAM 해커톤 후기</a>로 따로 포스팅할 생각이다. 이제 구체적인 기획을 마무리하고 내가 맡은 Front-End 쪽 개발에 집중할 계획이다. 그런데 마지막으로 받았던 피드백에서 주제가 대차게 까여서 어떻게 방향을 틀어야 할지 좀 고민이 돤다 ㅎㅎ..</li></ul><br><ul><li><strong>제 8회 육군창업경진대회</strong>를 2~3주 빡세게 준비해서 접수를 해놓은 상태다. 2주 뒤에 예선 결과발표가 나는데, 본선 진출만 해도 포상휴가라는 말에 시작한 대회였으니 제발 본선만이라도 갔으면 좋겠다. 지금 육군으로 복무중인 고등학교 친구 군바리 둘이랑 팀을 짜서, 몇 주 전부터 여러 아이디어를 내고 서로 피드백도 해주면서 나온 가장 괜찮은 아이템 하나로 develop하고 접수를 했다. 하나 걱정되는 건 아무래도 육군에서 주관하는 경진대회이다 보니 기술성을 많이 보고 특히 군과 관련된 아이템이 좋은 점수를 받는다고 하는데 우리 아이템이 그쪽은 아니라는거… 암튼 이번 기회에 유튜브로 Figma를 독학해서 프로토타입을 제작하는 데에 사용해봤다. 컴포넌트를 지정하고 그 variation을 만드는 기능이 아주 유용했고, 전반적으로 Adobe XD보다 사용하기 편했던 것 같다. 이제 UI&#x2F;UX Design + Front-End 개발을 같이 할 수 있다고 어디가서 말할 수 있을 것 같다.</li></ul><br><ul><li><strong>제로 투 원</strong>을 읽으며 인사이트를 얻을 수 있었다. 독점적 스타트업이 되야하는 이유, 기하급수적 성장의 중요성, 20-80 법칙, 작은 시장부터 독점하는 방법, 경쟁과 자본주의의 근본적 차이점.</li></ul><hr><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><p><strong>제로 투 원</strong> - 피터 틸<br><strong>1Q84 #3</strong> - 무라카미 하루키</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- excerpt --&gt;

&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;9월엔 포데이 3번에, 2박 3일 휴가까지 써서 부대보다 사회에 있었던 시간이 더 많았다. &lt;del&gt;이게 군</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>Expo memos &amp; troubleshooting</title>
    <link href="https://oxcarxierra.github.io/Development/expo-init/"/>
    <id>https://oxcarxierra.github.io/Development/expo-init/</id>
    <published>2022-09-27T02:20:51.000Z</published>
    <updated>2022-09-29T17:39:26.431Z</updated>
    
    <content type="html"><![CDATA[<!--excerpt--><h3 id="Expo-CLI-설치"><a href="#Expo-CLI-설치" class="headerlink" title="Expo CLI 설치"></a>Expo CLI 설치</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx expo <span class="built_in">whoami</span> <span class="comment"># 로그인된 계정 확인, Not logged in 이 뜨면 로그인해줘야함</span></span><br><span class="line">npx expo register <span class="comment"># 회원가입</span></span><br><span class="line">npx expo login</span><br></pre></td></tr></table></figure><h3 id="Typescript-Expo-앱-시작"><a href="#Typescript-Expo-앱-시작" class="headerlink" title="Typescript - Expo 앱 시작"></a>Typescript - Expo 앱 시작</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npx create-expo-app app-name</span><br><span class="line"><span class="built_in">cd</span> app-name</span><br><span class="line"><span class="built_in">touch</span> tsconfig.json</span><br><span class="line">npx expo start <span class="comment"># Typescript 필요 번들설치</span></span><br><span class="line"><span class="built_in">mv</span> App.js App.tsx</span><br><span class="line">npx tsc <span class="comment"># 타입체크</span></span><br></pre></td></tr></table></figure><p>또는, 이미 만들어진 Typescript 기반의 expo 템플릿을 설치하여 사용할 수도 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-expo-app -t expo-template-blank-typescript</span><br></pre></td></tr></table></figure><blockquote><p>참고자료 : <a href="'https://docs.expo.dev/guides/typescript/'">Expo Docs</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;나중에 내가 보려고 메모해두는 Expo 앱 제작 과정 메모들&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://oxcarxierra.github.io/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>2022년 8월 회고록</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/august-2022-review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/august-2022-review/</id>
    <published>2022-09-01T10:59:02.000Z</published>
    <updated>2022-09-29T18:21:40.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li><strong>군장병 공개SW 온라인 해커톤</strong> 준비로 바빴다. 코딩테스트 준비를 위해 BOJ 문제들을 난이도순으로 풀었고, 도중에 모르는 자료구조나 알고리즘은 종만북과 친절하게 설명해 놓은 블로그들을 참고하며 배울 수 있었다. 새로 알게된 내용은 블로그에 나만의 언어로 정리해서 포스팅하며 복습도 했다. 실제로 코딩테스트에 DP와 BFS문제가 나와서 공부했던 내용을 잘 써먹을 수 있었다. Dart 언어와 Flutter도 제공하는 강의를 모두 수강했더니 이론평가도 어렵지 않게 풀 수 있었다.</li></ul><img src="https://imgur.com/dzRvkOI.png"/><blockquote><p>알고리즘 공부를 시작하고 1개월 반동안 solved.ac 레이팅도 많이 올랐다!</p></blockquote><br ><ul><li>본선에서 실제로 구현할 아이디어를 담은 개발계획서를 제출해야 하는데, 아무래도 내가 있는 부대는 일반적인 육군과 근무 환경이 다르다보니 문제점을 찾고 솔루션을 제안하는게 쉽지 않다. 괜찮은 주제를 찾을 때까지 노션을 스케치북삼아 브레인스토밍을 해나가고 있는데 하나 꽂히는 것이 없어서 고민이 되고 있다.</li></ul><br ><ul><li>이번 후반기에 열리는 <a href="https://www.army-startup.co.kr/">제 8회 육군창업경진대회</a>에 도전해보고 싶어서 팀빌딩을 하고 아이디어를 같이 구상해보기로 했다. 군에 복무하면서 스타트업을 준비하고 경험해볼 수 있는 좋은 기회가 될 것 같다. 본선만 진출해도 포상휴가가 나온다고 해서 더더욱 열심히 해볼 생각이다.</li></ul><br ><ul><li>넷플릭스의 기업 문화를 담은 &lt;규칙 없음&gt;을 읽었다. 나는 극한의 인재 밀도를 추구하는 기업에 어울릴수 있는가? 나는 기업이 업계 최고의 대우를 해주어서라도 가지고 있을만한 인재인가? 나는 직설적이고 솔직한 피드백을 주고, 또 받을 준비가 되어있는가?</li></ul><br ><div class="figure center" style="width:;"><img class="fig-img" src="https://i.imgur.com/vhgtCzI.jpg" alt=""></div><blockquote><p>PFC Oh promoted to CPL Oh!🫡</p></blockquote><hr><h2 id="읽은-책들"><a href="#읽은-책들" class="headerlink" title="읽은 책들"></a>읽은 책들</h2><p><strong>1Q84 #2</strong> - 무라카미 하루키<br><strong>규칙 없음</strong> - 리드 헤이스팅스 ∙ 에린 마이어</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;군장병 공개SW 온라인 해커톤&lt;/strong&gt; 준비로 바빴다. 코딩테스트 준비를 위해 BOJ 문제들을 난이도순으로 </summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>비트마스킹 Bitmask</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-bitmask-1052/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-bitmask-1052/</id>
    <published>2022-08-22T13:03:21.000Z</published>
    <updated>2022-09-29T17:39:26.470Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!--toc--><h2 id="비트마스킹이란"><a href="#비트마스킹이란" class="headerlink" title="비트마스킹이란?"></a>비트마스킹이란?</h2><p><strong>이진법 숫자의 각 자리(비트)에</strong> <code>true</code>&#x2F;<code>false</code> <strong>혹은 0&#x2F;1의 데이터를 저장</strong>하는 자료구조 혹은 테크닉이다.<br>예를 들어, 0,1,2,3중 두 숫자를 뽑는 모든 경우의 수를 생각하자. <code>[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]</code>처럼 행렬로 묶는 방법이 있다.<br>비트마스킹을 이용하여 i의 포함 여부를 2^i자리에 저장한다면, <code>0011 0101 0110 1001 1010 1100</code>로 여섯 가지 방법을 나타낼 수 있다. 이 숫자들을 십진법으로 바꾸면 각각 <code>3,5,6,9,11,13</code>이 된다.<br>즉, 리스트형 데이터를 정수형으로 간단하게 표현할 수 있게 된 것이다. 이렇게 비트마스킹은 원소들의 집합을 표현할 때 유용하다.</p><h3 id="비트-연산자"><a href="#비트-연산자" class="headerlink" title="비트 연산자"></a>비트 연산자</h3><p>이렇게 만들어진 이진수(혹은 정수)는 아래 5가지의 연산이 가능하다.</p><ul><li><strong>AND</strong><br>입력받은 두 이진수의 각 자리수가 모두 1일 때만 결과에도 1을 반환<br><code>1100 ^ 1010 = 1000</code></li><li><strong>OR</strong><br>입력받은 두 이진수의 각 자리수 중 하나라도 1일 때 결과에도 1을 반환<br><code>1100 ^ 1010 = 1110</code></li><li><strong>XOR</strong><br>입력받은 두 이진수의 각 자리수 중 하나만 1일 때 결과에도 1을 반환<br><code>1100 ^ 1010 = 0110</code></li><li><strong>NOT</strong><br>입력받은 이진수의 비트가 0일 때 1, 1일 때 0을 반환<br><code>~1100 = 0011</code></li><li><strong>shift</strong><br>이진수의 비트를 왼쪽, 오른쪽으로 원하는 만큼 움직인 값을 반환<br><code>11 &lt;&lt; 2 = 1100</code><br><code>1100 &gt;&gt; 2 = 11</code></li></ul><h3 id="비트-연산자를-이용한-데이터-제어"><a href="#비트-연산자를-이용한-데이터-제어" class="headerlink" title="비트 연산자를 이용한 데이터 제어"></a>비트 연산자를 이용한 데이터 제어</h3><ul><li><strong>비트 삽입</strong><br>p번 비트 추가 : <code>x = x | (1&lt;&lt;p)</code><br><code>1010 | (1&lt;&lt;2) = 1010 | 100 = 1110</code></li><li><strong>비트 삭제</strong><br>p번 비트 삭제 : <code>x = x &amp; ~(1&lt;&lt;p)</code><br><code>1110 &amp; ~ (1&lt;&lt;2) = 1110 &amp; 1011 = 1010</code></li><li><strong>비트 조회</strong><br>p번 비트 조회 : <code>x &amp; (1&lt;&lt;p)</code>의 p번 비트<br><code>1110 &amp; (1&lt;&lt;2) = 1110 &amp; 0100 = 0100</code></li><li><strong>비트 토글</strong><br>p번 비트 토글 : <code>x = x ^ (1&lt;&lt;p)</code><br><code>1110 ^ (1&lt;&lt;2) = 1110 ^ 0100 = 1010</code></li></ul><h2 id="BOJ-1052번-물병"><a href="#BOJ-1052번-물병" class="headerlink" title="BOJ 1052번 물병"></a>BOJ 1052번 물병</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p><a href="'https://www.acmicpc.net/problem/1052'">BOJ 1052번 물병</a></p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><p>문제를 수기로 조금 풀어보면, 물병의 물을 합치다 보면 <code>2^i</code>리터들의 합으로 분리됨을 알 수 있다. 즉 총 물의 양인 <code>N</code>을 이진수로 표현했을 때 1의 개수만큼의 비지 않은 병이 생긴다. 결국, <code>N+cnt</code>를 이진수로 표현했을 때 1의 개수가 k보다 작거나 같도록 하는 최소의 <code>cnt</code>를 구하는 문제가 된다.<br><code>cnt</code>를 1씩 증가시키면서 계산하면 최악의 경우 복잡도가 <code>O(NlogN)</code>이라서 시간초과가 난다. 1이 있는 가장 작은 자리수부터 1을 추가해주면 계산이 간단해진다.</p><blockquote><p>int형 자료 N의 이진법 표현은 <code>bin(N)</code>으로 구할 수 있으며, <code>0b</code>로 시작하기 때문에 <code>bin(N)[2:]</code>를 사용하기도 한다.</p></blockquote><figure class="highlight py"><figcaption><span>BOJ 1052번 물병</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>) &gt; k:</span><br><span class="line">  b = <span class="built_in">bin</span>(n)</span><br><span class="line">  idx = <span class="built_in">len</span>(b)-b.rfind(<span class="string">&#x27;1&#x27;</span>)-<span class="number">1</span></span><br><span class="line">  n += (<span class="number">1</span> &lt;&lt; idx)</span><br><span class="line">  cnt += (<span class="number">1</span> &lt;&lt; idx)</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 16장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1052번 물병&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 15686번 치킨 배달</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-15686/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-15686/</id>
    <published>2022-08-16T11:20:38.000Z</published>
    <updated>2022-09-29T17:39:26.479Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="'https://www.acmicpc.net/problem/15686'">BOJ 15686번 치킨 배달</a></p><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><ul><li><p>집 하나의 치킨거리를 구하기 위해 처음에는 BFS를 이용하여, 해당 집(1)에서 출발해 가장 가까운 직선거리에 있는 치킨집(2)을 발견하면 그 거리를 구했다. 결과는 당연히 시간초과. 치킨집들의 좌표를 배열로 저장해두고 각각으로의 치킨거리를 계산해서 최소값을 찾는 게 훨씬 빠르다.</p></li><li><p>itertools를 몰라서 치킨 가게들 중 m개를 임의로 선택하는 함수를 직접 백트래킹으로 구현했었다. 알고리즘은 동일했겠지만 시간초과가 나왔다.</p></li></ul><h3 id="그리디-알고리즘을-사용하면-안되는-이유"><a href="#그리디-알고리즘을-사용하면-안되는-이유" class="headerlink" title="그리디 알고리즘을 사용하면 안되는 이유"></a>그리디 알고리즘을 사용하면 안되는 이유</h3><p>도시의 치킨거리를 가장 많이 줄여주는 치킨집부터 m개를 고르는 방법도 생각해보았지만, 이 문제는 그리디 알고리즘을 사용하면 안된다. m에 따라 고르는 치킨집의 조합이 전혀 달라질 수 있기 때문이다.</p><h3 id="완전탐색-시간복잡도-계산"><a href="#완전탐색-시간복잡도-계산" class="headerlink" title="완전탐색 시간복잡도 계산"></a>완전탐색 시간복잡도 계산</h3><p>치킨집의 최대 개수는 13, 집의 최대 개수는 2N &#x3D; 100개이다. 치킨집의 조합의 가짓수가 가장 많으려면 m&#x3D;6일때, 13C6으로 약 1700이다. 그럼 이 조합마다 도시의 치킨거리를 계산하는데 <code>100*13=1300</code>의 계산이 필요하다고 해도 <code>1700*1300 &lt; 10^8</code>로 주어진 1초 내에 해결 가능하다.<br>컴퓨터는 1초에 약 1억번의 연산이 가능한 것을 이용해, 문제를 풀기 전 복잡도를 구해서 가능한 알고리즘인지 확인해보는 습관을 들여야겠다.</p><h3 id="Itertools-combinations-함수-이용"><a href="#Itertools-combinations-함수-이용" class="headerlink" title="Itertools combinations() 함수 이용"></a>Itertools combinations() 함수 이용</h3><p>Python 내장 모듈 <code>Itertools</code>내에 주어진 집합의 부분집합을 반환해주는 함수 <code>combinations()</code>가 있다는 걸 알게되었다. 이를 이용하면 굳이 백트래킹으로 조합을 일일히 반환하지 않아도 된다.</p><ul><li><code>permutations(p,r)</code>: p의 부분집합 중 <strong>중복된 원소 없이</strong> 길이가 r인 부분집합의 배열을 반환</li><li><code>combinations(p,r)</code> : p의 부분집합 중 <strong>중복된 원소 없이</strong> 길이가 r이고 <strong>사전순으로 정렬</strong>된 부분집합의 배열을 반환</li><li><code>combinations_with_replactment(p,r)</code> : p의 부분집합 중 <strong>원소의 중복을 허용</strong>하는 길이가 r이고 <strong>사전순으로 정렬된</strong> 부분집합의 배열을 반환</li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight py"><figcaption><span>BOJ 15686 치킨 배달</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"></span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">home = []</span><br><span class="line">store =[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">  row = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">  <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">if</span> row[y] == <span class="number">2</span>:</span><br><span class="line">      store.append([x,y])</span><br><span class="line">    <span class="keyword">elif</span> row[y] == <span class="number">1</span>:</span><br><span class="line">      home.append([x,y])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nearest</span>(<span class="params">i,j</span>):</span><br><span class="line">  d = <span class="number">999999</span></span><br><span class="line">  <span class="keyword">for</span> [x,y] <span class="keyword">in</span> selected:</span><br><span class="line">    d = <span class="built_in">min</span>(d, <span class="built_in">abs</span>(i-x)+<span class="built_in">abs</span>(j-y))</span><br><span class="line">  <span class="keyword">return</span> d</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chicken</span>():</span><br><span class="line">  chicken = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> [x,y] <span class="keyword">in</span> home:</span><br><span class="line">    chicken += nearest(x,y)</span><br><span class="line">  <span class="keyword">return</span> chicken</span><br><span class="line"></span><br><span class="line">min_chicken = <span class="number">999999</span></span><br><span class="line"><span class="keyword">for</span> selected <span class="keyword">in</span> combinations(store, m):</span><br><span class="line">  min_chicken = <span class="built_in">min</span>(min_chicken, chicken())</span><br><span class="line"><span class="built_in">print</span>(min_chicken)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br><a href="https://docs.python.org/3/library/itertools.html">itertools 공식 문서</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&#39;https://www.acmicpc.net/problem/15686&#39;&quot;&gt;BOJ 15</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="itertools" scheme="https://oxcarxierra.github.io/tags/itertools/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 9935번 문자열 폭발</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-9935/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-9935/</id>
    <published>2022-08-16T06:52:39.000Z</published>
    <updated>2022-08-16T07:01:24.351Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p><a href="'https://www.acmicpc.net/problem/9935'">BOJ 9935번 문자열 폭발</a></p><hr><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><p>문자열 문제를 아직 많이 다뤄보지 못해서 처음 접근할 때 어려움이 있었다.<br>주어진 문자열에서 폭발 문자열을 찾고 모두 지우면 되는데, 문자열을 지우고 난 후 연쇄적으로 생성되는 폭발 문자열도 지워야 하는 게 어려운 점이었다.<br>예를 들어, 문자열이 <code>ACC44</code>, 폭발 문자열이 <code>C4</code>인 경우 앞에서부터 폭발문자열의 검사를 시작하면 끝마쳤을 때 <code>AC4</code>가 남게된다. 이후 한번 더 검사를 해야 최종문자열 <code>A</code>만 남는다.<br>그래서 처음에는 앞에서부터 폭발 문자열을 찾는 알고리즘을 함수로 만들고, 폭발 문자열을 검색할 수 없을 때 까지 재귀적으로 실행하려 했다.<br>몇 번 실패하고 다른 사람들의 풀이를 참고해보니, 문자열을 뒤에서부터 검색하면 굳이 재귀를 하지 않아도 되는 방법이 있었다.</p><ol><li>입력 문자열의 앞에서부터 한 문자씩 stack에 추가한다.</li><li>추가한 문자가 폭발 문자열의 마지막 문자와 일치하면, 문자의 앞쪽으로 폭발 문자열과 일치하는지 검사한다. 일치한다면 stack에서 폭발 문자열을 제거한다.</li><li>입력 문자열의 모든 문자를 검사하고, stack에 원소가 남아있다면 원소를 string으로 바꿔 출력한다. 없다면, <code>&#39;FRULA&#39;</code>를 출력한다.</li></ol><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><figcaption><span>BOJ 9935 문자열 폭발</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">s = sys.stdin.readline().strip()</span><br><span class="line">bomb = sys.stdin.readline().strip()</span><br><span class="line">stack = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">    stack.append(s[i])</span><br><span class="line">    <span class="keyword">if</span> stack[-<span class="number">1</span>] == bomb[-<span class="number">1</span>] <span class="keyword">and</span> <span class="string">&#x27;&#x27;</span>.join(stack[-<span class="built_in">len</span>(bomb):]) == bomb:</span><br><span class="line">        <span class="keyword">del</span> stack[-<span class="built_in">len</span>(bomb):]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;FRULA&#x27;</span> <span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>.join(stack))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;&#39;https://www.acmicpc.net/problem/9935&#39;&quot;&gt;BOJ 993</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="string" scheme="https://oxcarxierra.github.io/tags/string/"/>
    
    <category term="search" scheme="https://oxcarxierra.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>위상 정렬 알고리즘 Topological Sort</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-topological-sort/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-topological-sort/</id>
    <published>2022-08-09T06:03:19.000Z</published>
    <updated>2022-09-29T17:39:26.470Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="위상-정렬-Topological-Sort"><a href="#위상-정렬-Topological-Sort" class="headerlink" title="위상 정렬 Topological Sort"></a>위상 정렬 <em>Topological Sort</em></h2><p>그래프 중 비순환 방향 그래프(DAG)에 대해, 간선 (u,v)가 있으면 u가 v보다 먼저 오도록 <strong>모든 정점을 선형으로 정렬하는 알고리즘</strong>이다. 대부분의 문제에서, 원소들 사이에 <strong>우선순위가 있는 데이터의 순서를 정하는 데에 사용</strong>될 수 있다.<br>한편 그래프에 순환이 존재한다면, 당연하게도 그 순환을 선형으로 표현할 수 없기 때문에 위상 정렬 알고리즘을 적용할 수 없다. 또한 하나의 그래프에서 다수의 위상 순서 <em>Topological Order</em>가 나올 수 있다.</p><h2 id="BFS를-이용한-in-degree-방법"><a href="#BFS를-이용한-in-degree-방법" class="headerlink" title="BFS를 이용한 in-degree 방법"></a>BFS를 이용한 in-degree 방법</h2><ol><li>정점 N개에 대해 방문했는지 여부를 표시할 배열 <strong>visited</strong>, 출력배열 <strong>t</strong>, <strong>deque</strong>를 초기화한다.</li><li>정점 N개에 대해 해당 정점으로 들어오는 간선의 개수를 <strong>in_degree</strong> 배열에 저장한다.</li><li>in_degree가 0인 원소들부터 deque에 넣는다. 없다면 반드시 사이클이 존재하므로 위상 정렬을 실핼할 수 없다.</li><li>deque의 왼쪽에서 원소 하나를 pop해서, 출력 배열 t에 추가한다. 또, 해당 정점과 연결된 정점들의 in_degree를 1 감소시킨다. 만약 그 값이 0이 되었다면 deque의 오른쪽에 추가한다. 또한 그 노드의 visited값을 True로 저장한다.</li><li>3~4의 과정을 deque가 빌 때까지 반복한다.</li></ol><p>만약 출력배열에 모든 정점이 출력되지 않았다면, DAG가 아니었던 것으로 판단할 수 있다. 이 사실을 이용해 <a href="'https://www.acmicpc.net/problem/2623'">BOJ 2623 음악 프로그램</a>을 해결할 수 있다.</p><h3 id="BOJ-2252-줄세우기"><a href="#BOJ-2252-줄세우기" class="headerlink" title="BOJ 2252 줄세우기"></a>BOJ 2252 줄세우기</h3><figure class="highlight python"><figcaption><span>BOJ 2252 줄세우기</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">deg = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a,b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[a].append(b)</span><br><span class="line">  deg[b] +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">visited = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">t = []</span><br><span class="line">q = deque([])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> deg[i] == <span class="number">0</span>:</span><br><span class="line">    deque.append(q,i)</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">  node = deque.popleft(q)</span><br><span class="line">  t.append(node)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph[node]:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[<span class="built_in">next</span>]:</span><br><span class="line">      deg[<span class="built_in">next</span>] -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> deg[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">        visited[<span class="built_in">next</span>] = <span class="literal">True</span></span><br><span class="line">        deque.append(q, <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*t)</span><br></pre></td></tr></table></figure><h3 id="우선순위-힙을-접목한-in-degree-방법-BOJ-1766-문제집"><a href="#우선순위-힙을-접목한-in-degree-방법-BOJ-1766-문제집" class="headerlink" title="우선순위 힙을 접목한 in-degree 방법 (BOJ 1766 문제집)"></a>우선순위 힙을 접목한 in-degree 방법 (BOJ 1766 문제집)</h3><p><a href="'https://www.acmicpc.net/problem/1766'">BOJ 1766 문제집</a> 문제는 한 정점 뒤로 올 수 있는 모든 정점 중 <strong>최솟값</strong>이 그 다음에 와야만 하는 조건이 추가되어 있다. 이 경우엔 간단하게 deque를 heapq클래스로 바꿔주면 쉽게 해결할 수 있다. in-degree가 0이 되면 대기열에서 크기 순서대로 정렬되어 가장 크기가 작은 원소부터 출력 배열에 저장되게 된다.</p><figure class="highlight py"><figcaption><span>BOJ 1766 문제집</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">indeg = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a, b= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[a].append(b)</span><br><span class="line">  indeg[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">visited = [<span class="literal">False</span>]*(n+<span class="number">1</span>)</span><br><span class="line">t , q =[], []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> indeg[i] == <span class="number">0</span>:</span><br><span class="line">    heapq.heappush(q,i)</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> q:</span><br><span class="line">  node = heapq.heappop(q)</span><br><span class="line">  t.append(node)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph[node]:</span><br><span class="line">    indeg[<span class="built_in">next</span>] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> indeg[<span class="built_in">next</span>] == <span class="number">0</span>:</span><br><span class="line">      visited[<span class="built_in">next</span>] = <span class="literal">True</span></span><br><span class="line">      heapq.heappush(q, <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(*t)</span><br></pre></td></tr></table></figure><!-- ## DFS를 이용한 방법 --><blockquote><p>참고자료<br><a href="https://yoongrammer.tistory.com/86">https://yoongrammer.tistory.com/86</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 2252 줄세우기&lt;/strong&gt;, &lt;strong&gt;BOJ 1766 문제집&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="sort" scheme="https://oxcarxierra.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal 알고리즘 (최소 스패닝 트리 문제)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-kruskal/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-kruskal/</id>
    <published>2022-08-07T07:37:56.000Z</published>
    <updated>2022-09-29T17:39:26.483Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="최소-스패닝-트리-Minimum-Spanning-Tree-MST"><a href="#최소-스패닝-트리-Minimum-Spanning-Tree-MST" class="headerlink" title="최소 스패닝 트리 (Minimum Spanning Tree, MST)"></a>최소 스패닝 트리 (Minimum Spanning Tree, MST)</h2><p><strong>스패닝 트리 Spanning tree</strong>는 무향 그래프의 정점 전부와 간선의 부분집합으로 구성되어 있으면서, 모든 정점이 연결된 부분 그래프로 정의한다. 연결되기만 하면 되는 점에서 당연히 스패닝 트리는 하나가 아니다. 이 중 간선에 가중치가 부여된 경우 <strong>가중치의 합이 가장 작은 스패닝 트리</strong>를 찾는 문제가 <strong>최소 스패닝 트리 Minimum Spanning Tree</strong> 문제이다.<br>한마디로, 그래프의 연결성을 그대로 유지하는 가장 ‘저렴한’ 그래프를 찾는 문제라고 할 수 있다.</p><p>최소 스패닝 트리를 찾는 두 가지 유명한 알고리즘이 있는데, <strong>Kruskal 알고리즘</strong>과 <strong>Prim 알고리즘</strong>이 그것이다. 둘 다 비용이 적은 간선을 우선적으로 선택하는 <strong>탐욕법</strong>의 본질을 가지고 있다.</p><h2 id="Kruskal-알고리즘"><a href="#Kruskal-알고리즘" class="headerlink" title="Kruskal 알고리즘"></a>Kruskal 알고리즘</h2><p>Kruskal 알고리즘은 가중치가 낮은 간선부터 하나씩 추가해가면서 스패닝 트리를 만들어간다. 하나의 간선을 추가했을 때 최소 스패닝 트리의 조건을 만족하는지 검사해야 하는데, 이 때 <a href="#">Post not found: boj-disjoint-set Union-Find 자료구조</a>가 유용하게 쓰인다. 해당 간선을 추가했을 때 그래프에 사이클이 생긴다면, 불필요한 간선이므로 추가할 필요가 없기 때문이다.<br><br></p><ol><li>그래프의 모든 정점을 Union-Find 자료구조로 구현한다. 처음에는 원소 각각이 상호 배타적 부분집합이 된다.</li><li>가중치가 가장 낮은 간선부터 검사한다. 두 정점이 A,B라고 가정하면 <strong>Find(A)와 Find(B)가 다른 경우에만 Union(A, B)를 실행</strong>한다. 그리고 해당 간선의 가중치를 더한다.</li><li>2번 과정을 모든 간선에 대해 반복한다.</li></ol><h2 id="Kruskal-알고리즘의-시간-복잡도"><a href="#Kruskal-알고리즘의-시간-복잡도" class="headerlink" title="Kruskal 알고리즘의 시간 복잡도"></a>Kruskal 알고리즘의 시간 복잡도</h2><p>우선 Union, Find연산의 시간 복잡도는 <strong>상수 시간으로 수렴</strong>하므로 전체 알고리즘의 복잡도에 영향을 미치지 못한다. 따라서 정렬된 (<code>O(log E)</code>) 모든 간선에 대해(<code>O(E)</code>) 검사를 진행해야 하므로, 전체 시간 복잡도는 <code>O(ElogE)</code>가 된다.</p><h2 id="BOJ-1197번-최소-스패닝-트리"><a href="#BOJ-1197번-최소-스패닝-트리" class="headerlink" title="BOJ 1197번 최소 스패닝 트리"></a>BOJ 1197번 최소 스패닝 트리</h2><figure class="highlight py"><figcaption><span>BOJ 1197번 최소 스패닝 트리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  s,e,w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph.append([w,s,e])</span><br><span class="line">parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line">rank = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a])</span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]:</span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]:</span><br><span class="line">    rank[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kruskal</span>():</span><br><span class="line">  tot_weight = <span class="number">0</span></span><br><span class="line">  graph.sort()</span><br><span class="line">  <span class="keyword">for</span> w,s,e <span class="keyword">in</span> graph:</span><br><span class="line">    <span class="keyword">if</span> find(s) != find(e):</span><br><span class="line">      union(s,e)</span><br><span class="line">      tot_weight += w</span><br><span class="line">  <span class="keyword">return</span> tot_weight</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(kruskal())</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 31장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1197번 최소 스패닝 트리&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="mst" scheme="https://oxcarxierra.github.io/tags/mst/"/>
    
  </entry>
  
  <entry>
    <title>Union-Find 자료구조 (상호 배타적 집합 Disjoint Set)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-disjoint-set/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-disjoint-set/</id>
    <published>2022-08-07T05:40:33.000Z</published>
    <updated>2022-09-29T17:39:26.761Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><hr><h2 id="상호-배타적-집합-Disjoint-Set과-Union-Find-자료구조"><a href="#상호-배타적-집합-Disjoint-Set과-Union-Find-자료구조" class="headerlink" title="상호 배타적 집합 Disjoint Set과 Union-Find 자료구조"></a>상호 배타적 집합 Disjoint Set과 Union-Find 자료구조</h2><p>집합의 원소들을 여러 개의 부분집합으로 나누되, 그 부분집합들의 교집합이 없도록 분류하는 상황을 가정해 보자. 이러한 부분집합들을 <strong>상호 배타적 집합</strong>(혹은 분리집합, Disjoint Set)이라고 하는데, 이 상황을 구현하기 위해 고안된 자료구조가 <strong>Union-Find 자료구조</strong>이다.</p><p>Union-Find 자료구조는 세 가지 연산이 가능하다.</p><ul><li>초기화 : n개의 원소가 각각의 집합에 들어있을 수 있도록 초기화</li><li><strong>Find 연산</strong> : 주어진 원소가 속한 집합을 찾아(Find) 반환</li><li><strong>Union 연산</strong> : 주어진 두 원소가 속한 집합을 하나로 합침(Union)</li></ul><h3 id="배열로-구현한-Union-Find"><a href="#배열로-구현한-Union-Find" class="headerlink" title="배열로 구현한 Union-Find"></a>배열로 구현한 Union-Find</h3><p>쉽게 생각해보면, Union-Find는 <code>arr[i] = i가 속한 집합의 번호</code> 인 1차원 배열로 생각할 수 있다. 이 경우 Find연산은 배열에 직접 접근해서 찾으면 되니<code>O(1)</code>의 복잡도를 가진다. 그러나, Union연산은 전체 배열을 훑으며 a번 집합에 속한 모든 원소를 b로 바꿔주어야 하기 때문에, <code>O(n)</code>의 복잡도를 가진다.</p><h3 id="트리를-이용해-구현한-Union-Find"><a href="#트리를-이용해-구현한-Union-Find" class="headerlink" title="트리를 이용해 구현한 Union-Find"></a>트리를 이용해 구현한 Union-Find</h3><p>Find에 걸리는 시간을 조금 늘리더라도, Union을 빠르게 할 수 있도록 고안된 것이 트리를 활용한 방법이다. <strong>하나의 집합에 속한 원소들을 트리로 연결</strong>하면, 각각의 집합은 서로 다른 루트를 가진 독립적인 트리로 생각할 수 있다. Find연산의 경우, 해당 원소의 <strong>부모 노드를 따라가서 루트에 도달</strong>하면 어떤 집합에 속해있는지 알 수 있다. 또한 Union연산은 두 원소가 속한 집합을 Find로 찾아낸 후 <strong>한 쪽 트리를 다른 쪽 트리의 아래로 합치면</strong> 된다.</p><figure class="highlight python"><figcaption><span>트리를 이용해 구현한 Union-Find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]: <span class="comment"># 원소가 트리의 루트인 경우</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> find(parent[a]) <span class="comment"># 트리를 재귀적으로 따라 올라가 루트 원소를 반환</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a = find(a)</span><br><span class="line">  b = find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span> <span class="comment"># 합치려는 두 집합이 같은 경우</span></span><br><span class="line">  parent[a] = b</span><br></pre></td></tr></table></figure><p>이 경우 Find, Union 연산 모두 트리의 높이에 비례한 복잡도를 가진다. <code>O(n)</code>의 복잡도를 가졌던 1차원 배열보다 훨씬 빨라진 것을 알 수 있다.</p><h2 id="Union-Find의-최적화"><a href="#Union-Find의-최적화" class="headerlink" title="Union-Find의 최적화"></a>Union-Find의 최적화</h2><p>1부터 n까지 n개의 원소로 초기화된 상호 배타적 집합을 Union-Find 구조로 구현된 상황을 생각해보자. 1,2를 합치고, 2,3을 합치고… i와 i+1을 합치는 반복적인 연산을 한다면, 트리의 깊이는 최대 n까지 늘어난다. 그려면 Find연산의 복잡도도 <code>O(n)</code>, Union연산의 복잡도도 <code>O(n)</code>으로 오히려 효율이 나빠진다. 이렇게 트리가 한쪽으로 기울어지는 문제를 해결하고 구조를 최적화하는 방법은 Union-by-rank, 경로압축으로 두 가지가 있다.</p><h3 id="Union-by-rank"><a href="#Union-by-rank" class="headerlink" title="Union-by-rank"></a>Union-by-rank</h3><p>트리를 합치는 과정에서 높이가 낮은 트리를 높은 트리 밑으로 집어넣는다면, 두 트리의 높이가 같지 않는 이상 트리의 높이가 증가하지 않는다. 이것이 Union-by-rank 최적화로, <code>rank=[]</code> 배열에 원소가 루트인 트리의 높이를 저장하고 union연산을 할 때 높이를 비교한 후 실행하도록 수정하면 된다.<br>이 과정으로 Find와 Union연산의 복잡도를 <code>O(logN)</code>까지 줄일 수 있다.</p><figure class="highlight py"><figcaption><span>Union-by-rank 최적화</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]: <span class="comment"># 합치려는 두 트리의 높이를 비교</span></span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]: <span class="comment"># 두 트리의 높이가 같은 경우에만 트리의 높이가 1 증가</span></span><br><span class="line">    rank[b] += <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="경로-압축-Path-compression"><a href="#경로-압축-Path-compression" class="headerlink" title="경로 압축 Path compression"></a>경로 압축 Path compression</h3><p>찾기 연산의 복잡도를 줄이기 위해, 이미 루트를 아는 원소는 그 루트를 저장하는 간단한 방법이 있다. 5 -&gt; 3 -&gt; 2 -&gt; 1의 순서로 루트를 찾았다면, 5의 부모노드를 1로 갱신함으로써 다음에는 5 -&gt; 1로 루트에 접근할 수 있게 된다.</p><figure class="highlight py"><figcaption><span>path compression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a]) <span class="comment"># 부모노드를 루트로 갱신</span></span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br></pre></td></tr></table></figure><p>두 최적화 방법을 모두 적용한 Union-Find 자료구조는, Find연산의 복잡도가 크게 감소한다. 특히 Find를 여러 번 수행할수록 빨라지게 되는데, 이 경우 평균적으로 <code>O(𝛼(N))</code>의 복잡도를 가진다고 한다. 𝛼(N)은 애커만 함수를 이용해 정의되는 함수인데 산술적인 N값에 대해서 그 값이 4 이하이기 때문에, 사실상 상수시간 내에 실행된다고 할 수 있다.</p><h2 id="BOJ-20040-사이클-게임"><a href="#BOJ-20040-사이클-게임" class="headerlink" title="BOJ 20040 사이클 게임"></a>BOJ 20040 사이클 게임</h2><p>Path compression만 사용해도 제한 시간 내로 통과는 되는 것을 확인할 수 있었다. 입력이 많아질 수 있기 때문에 <code>sys.stdin.readline</code>을 이용해야 한다.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><figcaption><span>BOJ 20040 사이클게임</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.setrecursionlimit(<span class="number">10</span>**<span class="number">6</span>)</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">n,m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">rank = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">a</span>):</span><br><span class="line">  <span class="keyword">if</span> a == parent[a]:</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[a] = find(parent[a])</span><br><span class="line">    <span class="keyword">return</span> parent[a]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">a,b</span>):</span><br><span class="line">  a, b = find(a), find(b)</span><br><span class="line">  <span class="keyword">if</span> a==b:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> rank[a] &gt; rank[b]:</span><br><span class="line">    a, b = b, a</span><br><span class="line">  parent[a] = b</span><br><span class="line">  <span class="keyword">if</span> rank[a] == rank[b]:</span><br><span class="line">    rank[b] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cycle</span>():</span><br><span class="line">  <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    a,b= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    <span class="keyword">if</span> union(a,b) == -<span class="number">1</span>:</span><br><span class="line">      <span class="built_in">print</span>(x+<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cycle()</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br>프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (종만북), 25장</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 20040 사이클 게임&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="data structure" scheme="https://oxcarxierra.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 2239번 스도쿠</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-2239/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-2239/</id>
    <published>2022-08-06T16:41:40.000Z</published>
    <updated>2022-08-07T05:12:39.154Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>하다 만 스도쿠 퍼즐이 주어졌을 때, 마저 끝내는 프로그램을 작성하시오.</p><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><ul><li><a href="#">Post not found: boj-9663 BOJ 9663 N-Queen문제</a>와 비슷하게, 백트래킹을 이용한다. 초기에 0이었던 위치에 1~9를 대입해보며 같은 행/열/사각형에 겹치는 숫자가 있는지 promising을 거치며 DFS를 실행한다.</li><li><p>현재 검사하고 있는 칸을 x,y좌표로 두는 것 보다, (0,0)에서부터 순서를 정해 cnt로 정의하면 <code>cnt // 9</code>, <code>cnt % 9</code>로 좌표를 구할 수 있어 편하다.</p></li><li><p>처음에 <code>cnt==81</code> 조건 이후 <code>return</code>을 넣었더니 출력초과가 떴다. 만족하는 모든 스도쿠의 해를 출력하고 있었던 것이다. 이 때 이용할 수 있는 함수가 <code>exit()</code>으로, 도달하면 컴파일된 프로그램 전체를 종료하기 때문에 처음으로 구한 해만 출력하고 종료할 수 있게 된다.</p></li></ul><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><figcaption><span>BOJ 2239 스도쿠</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">s = [[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">input</span>()] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">r, c, sq = [[<span class="literal">False</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)],[[<span class="literal">False</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)],[[<span class="literal">False</span>]*<span class="number">10</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    x = s[i][j]</span><br><span class="line">    r[i][x] = c[j][x] = sq[(i//<span class="number">3</span>)*<span class="number">3</span>+j//<span class="number">3</span>][x] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">cnt</span>):</span><br><span class="line">  <span class="keyword">global</span> r, c, sq</span><br><span class="line">  <span class="keyword">if</span> cnt == <span class="number">81</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">      <span class="built_in">print</span>(*i, sep=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line">  x,y = cnt // <span class="number">9</span>, cnt%<span class="number">9</span></span><br><span class="line">  <span class="keyword">if</span> s[x][y] == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> r[x][i] <span class="keyword">and</span> <span class="keyword">not</span> c[y][i] <span class="keyword">and</span> <span class="keyword">not</span> sq[(x//<span class="number">3</span>)*<span class="number">3</span>+y//<span class="number">3</span>][i]:</span><br><span class="line">        s[x][y] = i</span><br><span class="line">        r[x][i] = c[y][i] = sq[(x//<span class="number">3</span>)*<span class="number">3</span>+y//<span class="number">3</span>][i] = <span class="literal">True</span></span><br><span class="line">        solve(cnt+<span class="number">1</span>)</span><br><span class="line">        s[x][y] = <span class="number">0</span></span><br><span class="line">        r[x][i] = c[y][i] = sq[(x//<span class="number">3</span>)*<span class="number">3</span>+y//<span class="number">3</span>][i] = <span class="literal">False</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    solve(cnt+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">solve(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;하다 만 스도쿠 퍼즐이 주어졌을 때, 마저 끝내는 프로그램을 작성하시오.&lt;/p&gt;
&lt;h2 id=&quot;접근&quot;</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="backtracking" scheme="https://oxcarxierra.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 1918번 후위 표기식</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_1918/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_1918/</id>
    <published>2022-08-02T12:28:21.000Z</published>
    <updated>2022-09-29T17:39:27.028Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="전위-중위-후위-표기식"><a href="#전위-중위-후위-표기식" class="headerlink" title="전위, 중위, 후위 표기식"></a>전위, 중위, 후위 표기식</h2><p><em>Prefix, Infix, Postfix Expression</em></p><p>일반적인 수식은 피연산자와 피연산자 사이에 연산자를 위치시킨다. A와 B를 더하는(+)연산을 기술할 때 A+B로 표현하듯이 말이다. 연산자를 피연산자들의 앞에 위치시키거나 뒤에 위치시키는 표기 방법을 각각 전위 Prefix, 후위 Postfix 표기식이라고 하며, 앞의 예시는 각각+AB, AB+로 쓸 수 있다.</p><h2 id="중위-표기식에서-후위-표기식으로의-변환"><a href="#중위-표기식에서-후위-표기식으로의-변환" class="headerlink" title="중위 표기식에서 후위 표기식으로의 변환"></a>중위 표기식에서 후위 표기식으로의 변환</h2><p>피연산자는 그 상대적인 위치가 바뀌지 않으므로, 연산자만 위치를 바꿔서 넣어주면 된다. 그러기 위해 연산자를 담아놓는 스택을 하나 만들어서, 입력된 연산자를 추가하거나 제거하면서 진행한다.</p><ol><li>입력된 수식을 문자열로 저장하고, 출력용 문자열을 빈 문자열로 초기화한다. 연산자를 담기 위한 opstack을 초기화한다.</li><li>입력 문자열을 앞에서부터 하나의 문자씩 접근한다.<ol><li>문자가 피연산자인 경우, 출력용 문자열에 추가한다.</li><li>문자가 왼쪽 괄호 ‘(‘인 경우, opstack에 push한다.</li><li>문자가 오른쪽 괄호 ‘)’인 경우, 대응하는 왼쪽 괄호 ’(‘가 나올 때 까지 opstack에서 연산자를 pop하고 문자열에 추가한다.</li><li>문자가 연산자인 경우, opstack에 push한다. 그 전에, <em>이미 opstack에 있는 연산자들 중 우선순위가 높거나 같은 것</em>들을 모두 pop한 후 문자열에 추가한다.</li></ol></li><li>입력 문자열을 모두 읽었다면 opstack에 남아있는 연산자를 차례대로 pop하고 문자열에 추가한다.</li></ol><p>처음 문제를 접근했을 때는 어떤 경우에 연산자를 하나 pop하거나 여러개를 pop해야 하는지 기준을 생각하지 못했었는데, 위의 과정 중 2-4에 그 답이 있다. 연산자의 우선순위를 딕셔너리 형식으로 저장해서, 곱셈과 나눗셈을 먼저 끝낼 수 있도록 했다.</p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">eq = <span class="built_in">input</span>().strip()</span><br><span class="line">posteq = <span class="string">&#x27;&#x27;</span></span><br><span class="line">opstack = []</span><br><span class="line">opdic=&#123;<span class="string">&#x27;(&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;+&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;-&#x27;</span>:<span class="number">2</span>, <span class="string">&#x27;*&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;/&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> eq:</span><br><span class="line">    <span class="keyword">if</span> i.isalpha():</span><br><span class="line">        posteq += i</span><br><span class="line">    <span class="keyword">elif</span> i==<span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        opstack.append(i)</span><br><span class="line">  <span class="keyword">elif</span> i==<span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> opstack:</span><br><span class="line">      operator = opstack.pop()</span><br><span class="line">      <span class="keyword">if</span> operator == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      posteq += operator</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> opstack <span class="keyword">and</span> opdic[opstack[-<span class="number">1</span>]] &gt;= opdic[i]:</span><br><span class="line">      posteq += opstack.pop()</span><br><span class="line">    opstack.append(i)</span><br><span class="line"><span class="keyword">while</span> opstack:</span><br><span class="line">  posteq += opstack.pop()</span><br><span class="line"><span class="built_in">print</span>(posteq)</span><br></pre></td></tr></table></figure><h2 id="추가-후위-표기식의-연산"><a href="#추가-후위-표기식의-연산" class="headerlink" title="추가) 후위 표기식의 연산"></a>추가) 후위 표기식의 연산</h2><p>우리에게 친숙한 중위표기식은 연산하기 쉽지만, 후위 표기식으로 변환된 경우 직관적이지 않다. 이 때도 스택 자료구조를 사용한다.<br>앞에서부터 문자를 하나씩 접근해서 피연산자라면 스택에 push하고, 연산자라면 스택에서 두 개의 피연산자를 pop한 후 연산한 결과를 다시 push한다.<br>예를 들어, <code>4 5 6 * +</code>의 후위표기식이 있다고 하자. 스택에 담긴 데이터는 아래와 같은 순서로 변하면서 마지막에는 최종 결과값만 남아있게 된다.</p><ul><li><code>4</code> + <code>5</code></li><li><code>4 5</code> + <code>6</code></li><li><code>4 5 6</code> + <code>*</code></li><li><code>4 30</code> + <code>+</code></li><li><code>34</code></li></ul><blockquote><p>참고자료<br>Problem Solving with Algorithms and Data Structures using Python, Chapter 4.9.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;전위-중위-후위-표기식&quot;&gt;&lt;a href=&quot;#전위-중위-후위-표기식&quot; class=&quot;headerlink&quot; title=&quot;전위, 중위, 후위 표기식&quot;&gt;&lt;/a&gt;전위, 중위, 후위 표기식&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Prefix, </summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="stack" scheme="https://oxcarxierra.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Bellman-Ford 알고리즘</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_bellman_ford/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_bellman_ford/</id>
    <published>2022-08-02T07:52:10.000Z</published>
    <updated>2022-08-06T13:59:04.235Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Bellman-Ford-알고리즘"><a href="#Bellman-Ford-알고리즘" class="headerlink" title="Bellman-Ford 알고리즘"></a>Bellman-Ford 알고리즘</h2><p>가중치 그래프의 한 노드에서 다른 노드까지의 최단경로를 찾는 탐색 알고리즘이다. Dijkstra 알고리즘과 차이점은, 가중치가 음수인 간선이 있을 때도 적용 가능한 알고리즘이다.</p><p><strong>음의 사이클</strong>이 발생할 경우, 최단경로를 찾을 수 없다. 최단거리를 무한으로 감소시킬 수 있기 때문이다.<br>Bellman-Ford 알고리즘으로 이런 음의 사이클이 존재하는지도 찾아낼 수 있다. (BOJ 1865 웜홀이 이같은 문제)</p><p>기본적인 알고리즘은 이렇다.</p><ol><li>출발 노드를 설정한다.</li><li>최단거리 배열을 초기회한다. (출발노드의 최단거리 &#x3D; 0, 나머지는 매우 큰 수 INF)</li><li>모든 간선들에 대해 해당 간선을 거쳤을 때 최단거리가 짧아지는지 검사하고, 짧아진다면 갱신한다.</li><li>이 과정을 (노드 개수)번 반복한다.</li><li>최단경로의 길이는 최대 (노드 개수)-1인데, 그보다 많이 이동하고 최단거리가 갱신된다면 음의 사이클이 존재한다고 판단할 수 있다. 즉, 마지막 반복에 최단거리 배열이 갱신된다면, -1을 return한다.</li></ol><h2 id="BOJ-11657-타임머신"><a href="#BOJ-11657-타임머신" class="headerlink" title="BOJ 11657 타임머신"></a>BOJ 11657 타임머신</h2><p>Bellman-Ford 알고리즘을 적용하면 쉽게 해결할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">n, m = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">graph = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    graph.append(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bf</span>():</span><br><span class="line">    dist = [INF]*(n+<span class="number">1</span>)</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> [s,e,w] <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> dist[s] != INF <span class="keyword">and</span> dist[s]+w &lt; dist[e]:</span><br><span class="line">                dist[e] = dist[s]+w</span><br><span class="line">                <span class="keyword">if</span> i == n-<span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">print</span>(-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(-<span class="number">1</span> <span class="keyword">if</span> dist[j] == INF <span class="keyword">else</span> dist[j] )</span><br><span class="line"></span><br><span class="line">bf()</span><br></pre></td></tr></table></figure><h2 id="BOJ-1865-웜홀"><a href="#BOJ-1865-웜홀" class="headerlink" title="BOJ 1865 웜홀"></a>BOJ 1865 웜홀</h2><p>이 문제에서는 <strong>음수 사이클</strong>의 존재 여부만 반환하면 된다. 쉬워 보이지만, 출발 노드가 정해지지 않았다는 점을 잘 고려해야 한다.<br>만약 출발 노드를 임의로 1번으로 지정한 경우, 1번 노드와 간선으로 연결되어있지 않은 노드들의 음수 사이클 존재를 알아낼 수 없다.<br>그래서 <code>if dist[s] != INF and dist[s]+w &lt; dist[e]:</code> 조건문을 수정해주었는데, 이렇게 하면 음수 사이클을 돌았을 때 값이 INF보다 작아지게 되어 존재 여부를 판단할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TC = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bellman_ford</span>(<span class="params">n, graph, start</span>):</span><br><span class="line">  dist = [INF]*(n+<span class="number">1</span>)</span><br><span class="line">  dist[start] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> [s,e,t] <span class="keyword">in</span> graph:</span><br><span class="line">      <span class="keyword">if</span> dist[e] &gt; dist[s] + t:</span><br><span class="line">        dist[e] = dist[s] + t</span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;YES&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;NO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(TC):</span><br><span class="line">  n, m, w = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph = []</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">    s, e, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph.append([s,e,t])</span><br><span class="line">    graph.append([e,s,t])</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">    s, e, t = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    graph.append([s,e,-t])</span><br><span class="line">  <span class="built_in">print</span>(bellman_ford(n,graph, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p><del>‘Yes’ ‘No’로 적고 왜 틀렸습니다가 뜨는지 30분 삽질했다..</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1865 웜홀, BOJ 11657 타임머신&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="bellman-ford" scheme="https://oxcarxierra.github.io/tags/bellman-ford/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 9663번 N-Queen</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj-9663/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj-9663/</id>
    <published>2022-08-01T06:27:23.000Z</published>
    <updated>2022-08-07T05:07:12.367Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.<br>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p><h2 id="접근"><a href="#접근" class="headerlink" title="접근"></a>접근</h2><p>N-Queen 문제는 백트래킹을 이용하는 유명한 문제중 하나이다.<br><strong>백트래킹</strong>이란, 해를 찾는 과정에서 유망성을 판단하고(promising) 유망하지 않은 후보 해에 막히면 되돌아가서(back track) 다른 해를 찾아가는 기법을 말한다. 백트래킹을 트리 탐색 기법의 한 종류로 분류할 수는 없다. 그러나 백트래킹을 DFS와 접목하면, 모든 노드를 방문하고 검색하지 않아도 되어 이득을 볼 수 있어 많이 사용된다.</p><p>N-Queen 문제의 경우, 총 N개의 퀸을 하나씩 배치해보면서 유망성 검사(promising)을 통해 더이상 퀸을 배치할 수 없는 상황에 도달하면, 전 단계로 되돌아가 다른 경우를 시도해본다. 퀸은 <strong>같은 열, 같은 행, 같은 대각선</strong>에 다른 퀸이 위치하는지 판단함으로써 유망성 검사를 할 수 있다.<br>처음에는 퀸의 위치좌표를 저장해가면서 x,y,대각선을 비교하는 방법으로 접근했으나, 훨씬 간단한 방법을 발견할 수 있었다. <strong>각 행의 몇 번째 열에 퀸이 놓여있는지</strong>를 행렬로 저장하면, 행은 겹칠일이 없고, 열과 대각선만 비교하면 된다.</p><figure class="highlight python"><figcaption><span>promising function</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">promising</span>(<span class="params">idx</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx):</span><br><span class="line">    <span class="keyword">if</span> queen[idx] == queen[i] <span class="keyword">or</span> <span class="built_in">abs</span>(queen[idx] - queen[i]) == idx - i:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>기본적인 DFS의 틀을 따라가면서, 행렬의 길이가 N이 되었을 때(N개의 퀸을 성공적으로 배치했을 때)만 count해주면 된다.</p><h2 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h2><figure class="highlight python"><figcaption><span>BOJ 9663 N-Queen</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">queen = [<span class="number">0</span>]*(N)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">promising</span>(<span class="params">idx</span>):</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(idx):</span><br><span class="line">    <span class="keyword">if</span> queen[idx] == queen[i] <span class="keyword">or</span> <span class="built_in">abs</span>(queen[idx] - queen[i]) == idx - i:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">idx</span>):</span><br><span class="line">  <span class="keyword">global</span> count</span><br><span class="line">  <span class="keyword">if</span> idx == N:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    queen[idx] = i</span><br><span class="line">    <span class="keyword">if</span> promising(idx):</span><br><span class="line">      dfs(idx+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;h2 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h2&gt;&lt;p&gt;N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="backtracking" scheme="https://oxcarxierra.github.io/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>2022년 7월 회고록</title>
    <link href="https://oxcarxierra.github.io/Monthly-Retrospectives/2022/july_2022_review/"/>
    <id>https://oxcarxierra.github.io/Monthly-Retrospectives/2022/july_2022_review/</id>
    <published>2022-07-31T08:47:53.000Z</published>
    <updated>2022-09-01T13:24:03.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><ul><li>4월에 시작했던 USFK BUS App 프로젝트를 <strong>앱스토어에 배포 완료</strong>함으로서 일단락했다. Apple Developer Program 활성화에 걸린 시간을 제외하고는, 제출과정과 제출 이후 심사과정이 아주 빠르게 진행되어서 생각보다 빨리 마무리할 수 있었다. 앱스토어에 내 이름으로, 직접 풀 스택으로 개발한 앱이 올라와 있는 것을 보니 이렇게 뿌듯할 수가 없다. 8월에 시간이 난다면 KR중 하나인 앱 기능 확장도 진행해야겠다.</li></ul><br><ul><li><strong>2022 군장병 공개SW 온라인 해커톤</strong> 본선 진출을 위해 BOJ와 프로그래머스에서 <strong>알고리즘 공부와 PS 연습</strong>을 꾸준히 하고 있다. Class 3, 4에 선별된 문제들 위주로 7월 한달간 BOJ에서만 <strong>20일 연속 66문제</strong>를 풀었다. 티어도 7월 초에 Silver 5에서 7월 말 현재 <strong>Gold 4</strong>까지 올랐다. 그래프 이론을 하나도 모를 정도로 베이스가 없었던 것을 생각하면 꽤 빠른 속도로 많은 것을 배운 것 같다. 8월 중순에 코딩테스트가 있는데, 어느 정도 난이도로 나오는지 몰라서(후기를 찾아보면 생각보다 어려웠다는 내용 뿐이다) 일단은 난이도에 제한을 두지 않고 계속해서 PS연습을 할 계획이다.</li></ul><br><ul><li><p>또한 이론평가 대비를 위해 <strong>Dart와 Flutter 강의</strong>도 꾸준히 수강했다. 강의에서는 Windows + Android Studio로 개발을 하라고 권고하는데 나에게 익숙한 IDE인 VS Code에서도 Plugin을 잘 활용하면 충분히 효율적으로 비슷한 기능을 사용할 수 있어 좋았다. View를 구성하는 과정만 비교해보았을 땐, CSS와 비슷한 문법을 제공하는 React가 나에게는 훨씬 효율적이고 직관적으로 다가와서 아직 Flutter의 큰 장점을 느끼지 못하겠다. 기본적으로 제공하는 컴포넌트가 디자인이 잘 되어있긴 한데, 라이브러리를 활용하면 React도 충분히 구현 가능한 수준인 것 같다.</p><ul><li><span class="highlight-text success">APP 강의 수강 - Dart 언어 기초 (69%)</span></li><li><span class="highlight-text warning">APP 강의 수강 - Flutter 초급 (32%)</span></li><li><span class="highlight-text success">APP 강의 수강 - Flutter 중급 (61%)</span></li><li><span class="highlight-text danger">APP 강의 수강 - Flutter 고급 (0%)</span></li></ul></li></ul><br><ul><li>운동도 꾸준히 하고 있다. 코로나 걸렸던 기간 제외하고는 주 3일은 헬스장에 갔던 것 같다. 이렇게 시설 좋은 헬스장을 언제 또 공짜로 다녀 보겠는가!</li></ul><br><ul><li>이번 달에는 책을 한 권도 읽지 않았다. 지하철에서 책을 꺼내서 읽었던 시간에 PS에 미쳐서 BOJ을 풀어서… 다음 달에는 책 읽기를 소홀히 했던 부분을 개선해야겠다. 그리고 예선 심사에 제출해야 하는 개발계획서도 꾸준히 브레인스토밍을 해야겠다. 평가 항목중 중요도는 제일 낮지만 내 군생활 환경이 다른 만큼 오랜 시간 고민해야 하나정도 제대로 된 아이디어가 나올 것 같다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;4월에 시작했던 USFK BUS App 프로젝트를 &lt;strong&gt;앱스토어에 배포 완료&lt;/strong&gt;함으로서 일단락했다. Appl</summary>
      
    
    
    
    <category term="Monthly Retrospectives" scheme="https://oxcarxierra.github.io/categories/Monthly-Retrospectives/"/>
    
    
    <category term="retrospective" scheme="https://oxcarxierra.github.io/tags/retrospective/"/>
    
  </entry>
  
  <entry>
    <title>Floyd-Warshall 알고리즘 (최단 경로 문제)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_floyd-warshall/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_floyd-warshall/</id>
    <published>2022-07-28T01:43:12.000Z</published>
    <updated>2022-09-29T17:39:27.028Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Floyd-Warshall-알고리즘이란"><a href="#Floyd-Warshall-알고리즘이란" class="headerlink" title="Floyd-Warshall 알고리즘이란"></a>Floyd-Warshall 알고리즘이란</h2><p>Dijkstra 알고리즘이 그래프의 정해진 한 노드에서 다른 노드까지의 최단거리를 구하는 알고리즘이었다면, Floyd-Warshall 알고리즘은 출발 노드가 따로 정해져있지 않다. 따라서 V개의 노드가 있다면 V^2개의 최단경로를 결과로 얻게 된다.</p><p>이 알고리즘의 핵심은 각 노드를 돌며 <strong>이 노드를 지나는 경로가 더 짧을 경우 갱신</strong>헤주는 방식이다.</p><ol><li>최단경로를 저장할 V by V 인접행렬을 만들고, INF값으로 초기화시킨다.</li><li>입력값을 행렬에 저장한다. 대각선 원소들에는 0을 저장한다.</li><li>각 노드를 순환하며, 다른 두 노드 사이의 최단거리가 이 노드를 거쳐갈 경우에 거리가 짧아진다면 갱신한다. (min함수를 이용한다)</li></ol><h2 id="Floyd-Warshall-알고리즘의-시간복잡도"><a href="#Floyd-Warshall-알고리즘의-시간복잡도" class="headerlink" title="Floyd-Warshall 알고리즘의 시간복잡도"></a>Floyd-Warshall 알고리즘의 시간복잡도</h2><p>단순하게 생각하면, V개의 노드를 세 번 순환을 돌았으니 O(V^3)이다.</p><h2 id="BOJ-11404-플로이드"><a href="#BOJ-11404-플로이드" class="headerlink" title="BOJ 11404 플로이드"></a>BOJ 11404 플로이드</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">m = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">dist = [[INF]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">  a, b, c= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  dist[a][b] = <span class="built_in">min</span>(dist[a][b],c)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">  dist[i][i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">      dist[j][k] = <span class="built_in">min</span>(dist[j][k],dist[j][i] + dist[i][k])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> dist[z][y] == INF:</span><br><span class="line">            dist[z][y] = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(*dist[z][<span class="number">1</span>:],sep=<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p>BOJ 11404에선 입력값에 같은 간선이 들어올 수 있으므로 입력받을 때에도 min함수를 이용해 비교해주어야 한다.</p><blockquote><p>참고자료<br><a href="https://namu.wiki/w/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">https://namu.wiki/w/플로이드-워셜%20알고리즘</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 11404번 플로이드&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="floyd-warshall" scheme="https://oxcarxierra.github.io/tags/floyd-warshall/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra 알고리즘 (최단 경로 문제)</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_dijkstra/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_dijkstra/</id>
    <published>2022-07-26T13:27:45.000Z</published>
    <updated>2022-09-29T17:39:27.029Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Dijkstra-Algorithm이란"><a href="#Dijkstra-Algorithm이란" class="headerlink" title="Dijkstra Algorithm이란?"></a>Dijkstra Algorithm이란?</h2><p>그래프의 모든 단선이 음이 아닌 가중치를 가졌을 때 노드와 노드 사이의 최단경로를 구하는 알고리즘이다.</p><p>→ 다른 알고리즘으로는 플로이드-워셜 알고리즘이 있다. 이건 모든 노드쌍 사이의 최단경로 알고리즘.<br>→ 단선에 음의 가중치가 있을 땐 벨만-포드 알고리즘.</p><p>노드의 개수 V, 단선의 개수 E인 그래프에 가중치가 주어졌고, 각 노드까지의 최단경로를 저장할 distance list를 선언했다고 가정하자.</p><ol><li>출발 노드를 설정</li><li>출발 노드와 연결된 노드들의 distance 설정 (최단거리라는 보장은 없다)</li><li>방문하지 않은 노드들 중 출발 노드와 최단거리가 가장 작은 노드를 선택한다.</li><li>이 노드를 거치는 경로를 계산했을 때 더 짧은 거리가 생성된다면 distance를 고친다.</li><li>3,4과정을 모든 노드에 대해 반복한다.</li></ol><p>핵심은, 3) 방문하지 않은 노드 중 최단거리의 노드를 선택하는 과정을 반복하는 데에 있다. 문제 안의 소문제를 찾아서 해결하는 DP의 응용이기도 하다.</p><p>이 과정에서 단순 탐색을 이용하는 방법과, 우선순위 큐를 이용하는 방법이 있다.</p><h2 id="단순탐색을-이용한-Dijkstra-Algorithm"><a href="#단순탐색을-이용한-Dijkstra-Algorithm" class="headerlink" title="단순탐색을 이용한 Dijkstra Algorithm"></a>단순탐색을 이용한 Dijkstra Algorithm</h2><p>이 때는 각 노드의 방문여부를 flag로 만들어준다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">graph= [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  u, v, w= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[u].append((v,w))</span><br><span class="line"></span><br><span class="line">distance = [INF]*(V+<span class="number">1</span>)</span><br><span class="line">visited = [<span class="literal">False</span>]*(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_smallest_node</span>():</span><br><span class="line">  min_value = INF</span><br><span class="line">  index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> visited[i] <span class="keyword">and</span> distance[i] &lt; min_value:</span><br><span class="line">      index = i</span><br><span class="line">      min_value = distance[i]</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">  visited[K] = <span class="literal">True</span></span><br><span class="line">  distance[K] = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i,v) <span class="keyword">in</span> graph[K]:</span><br><span class="line">    distance[i] = v</span><br><span class="line">  <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V-<span class="number">1</span>):</span><br><span class="line">    i = get_smallest_node()</span><br><span class="line">    visited[i] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> (j,v) <span class="keyword">in</span> graph[i]:</span><br><span class="line">      <span class="keyword">if</span> distance[j] &gt; distance[i] + v:</span><br><span class="line">        distance[j] = distance[i]+ v</span><br><span class="line"></span><br><span class="line">dijkstra()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> distance[i] == INF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(distance[i])</span><br></pre></td></tr></table></figure><p>시간복잡도는 O(V^2)이다. 왜냐하면 V개의 모든 노드에 대해 3)과정을 거치며 V번의 비교를 하게 되기 때문.</p><h2 id="우선순위-큐-최소-힙-을-이용하는-Dijkstra-Algorithm"><a href="#우선순위-큐-최소-힙-을-이용하는-Dijkstra-Algorithm" class="headerlink" title="우선순위 큐(최소 힙)을 이용하는 Dijkstra Algorithm"></a>우선순위 큐(최소 힙)을 이용하는 Dijkstra Algorithm</h2><p>이 과정에서 우선순위 큐(최소 힙)을 이용한다면, 복잡도를 줄일 수 있다.<br>아래 코드는 BOJ 1753 최단경로의 답이기도 하다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">INF = <span class="built_in">int</span>(<span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">V, E = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">K = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">graph= [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(V+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(E):</span><br><span class="line">  u, v, w= <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">  graph[u].append((v,w))</span><br><span class="line"></span><br><span class="line">distance = [INF]*(V+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dijkstra</span>():</span><br><span class="line">  q = []</span><br><span class="line">  distance[K] = <span class="number">0</span></span><br><span class="line">  heapq.heappush(q, (<span class="number">0</span>, K))</span><br><span class="line">  <span class="keyword">while</span> q:</span><br><span class="line">    dist, node = heapq.heappop(q)</span><br><span class="line">    <span class="keyword">if</span> distance[node] &lt; dist:</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> (j,v) <span class="keyword">in</span> graph[node]:</span><br><span class="line">      cost = distance[node]+ v</span><br><span class="line">      <span class="keyword">if</span> distance[j] &gt; cost:</span><br><span class="line">        distance[j] = cost</span><br><span class="line">        heapq.heappush(q, (cost, j))</span><br><span class="line"></span><br><span class="line">dijkstra()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, V+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">if</span> distance[i] == INF:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(distance[i])</span><br></pre></td></tr></table></figure><p>이 과정에서는 최단거리 노드를 찾는 데에 O(VlogV)가 필요하고(V개의 노드에 대해 힙에서 추출하는 시간 logV, 각 노드가 인접한 노드를 갱신할 때 (visited를 체크하지 않으므로) 모든 간선을 확인하는 것과 같으며 갱신될 때 logV가 필요하므로 O(ElogV)가 필요하다. 결과적으론 O((E+V)logV)가 필요한 셈.</p><p>이 부분에서 헷갈린게 있었는데, 최악의 경우 E는 V^2 스케일일 때 복잡도를 비교하면 전자가 더 빠르다. 즉 그래프가 sparse할 때만 효율적이다.</p><blockquote><p>참고자료<br><a href="https://techblog-history-younghunjo1.tistory.com/248?category=1014800">https://techblog-history-younghunjo1.tistory.com/248?category=1014800</a><br>위 블로그가 정말 설명이 깔끔하게 잘 되어있다. 다른 알고리즘도 참고해 보아야겠다<br><a href="https://namu.wiki/w/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC">https://namu.wiki/w/다익스트라</a> 알고리즘</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1753번 최단경로&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="graph" scheme="https://oxcarxierra.github.io/tags/graph/"/>
    
    <category term="dijkstra algorithm" scheme="https://oxcarxierra.github.io/tags/dijkstra-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>최장 공통 부분 수열 알고리즘</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_lcs/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_lcs/</id>
    <published>2022-07-25T06:48:40.000Z</published>
    <updated>2022-09-29T17:39:26.472Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Longest-Common-Substring-최장-공통-문자열"><a href="#Longest-Common-Substring-최장-공통-문자열" class="headerlink" title="Longest Common Substring, 최장 공통 문자열"></a>Longest Common Substring, 최장 공통 문자열</h2><p>Substring인 경우 최장 공통 문자열을 찾는 다른 문제가 된다.<br><br></p><ul><li>2차원 배열을 두어서 A[i]와 B의 모든 문자열을 검토.</li><li>A[i]와 B[j]가 같다면, LCS[i][j] &#x3D; LCS[i-1][j-1]+1</li><li>다르다면, LCS[i][j] &#x3D; 0</li><li>LCS중 최댓값</li></ul><h2 id="Longest-Common-Subsequence-최장-공통-부분-수열"><a href="#Longest-Common-Subsequence-최장-공통-부분-수열" class="headerlink" title="Longest Common Subsequence, 최장 공통 부분 수열"></a>Longest Common Subsequence, 최장 공통 부분 수열</h2><p>Substring의 경우와 매우 비슷하지만, A[i]와 B[j]가 다를 경우의 취급이 다르다.<br><br></p><ul><li>A[i]와 B[j]가 같다면, LCS[i][j] &#x3D; LCS[i-1][j-1]+1</li><li>다르다면, LCS[i][j] &#x3D; max(LCS[i-1][j] ,LCS[i][j-1])<br>그 이유는.. 이해하기 오래 걸렸지만 생각해보면 당연하다.<br>A[i-1]와 B[j-1]까지 비교한 상황에서 A[i]가 추가되었을 때 새롭게 늘어나는 subsequence와 B[j]의 그것을 비교해주는 논리이다.</li><li>모두 완성한 LCS의 마지막 원소</li></ul><p>완성한 LCS의 표를 마지막 원소로부터 거꾸로 올라가면 만족하는 subsequence를 얻어낼 수도 있다. 이는 BOJ 9252 LCS2 문제이기도 하다.<br><br></p><ul><li>완성한 LCS행렬의 마지막 원소에서 출발한다.</li><li>해당 원소의 왼쪽이나 위쪽(LCS[i-1][j] or LCS[i][j-1])에 같은 값이 있다면, 그쪽으로 이동한다. (나는 왼쪽부터 탐색하도록 했다.)</li><li>없다면, LCS행렬을 완성할 때 A[i]와 B[j]가 같아서 값이 증가한 값이라고 볼 수 있다. 왼쪽대각선(LCS[i-1][j-1])으로 이동한다.</li><li>이동하면서 해당 위치의 알파벳을 다른 행렬 Sequence의 끝에 저장한다.</li><li>i나 j가 0이 되었을 경우, Sequence를 뒤집으면 최장 공통 부분 수열을 얻을 수 있다.</li></ul><h2 id="BOJ-9251-LCS"><a href="#BOJ-9251-LCS" class="headerlink" title="BOJ 9251 LCS"></a>BOJ 9251 LCS</h2><h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.</p><p>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.</p><h3 id="풀이"><a href="#풀이" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">input</span>()</span><br><span class="line">B = <span class="built_in">input</span>()</span><br><span class="line">n, m = <span class="built_in">len</span>(A),<span class="built_in">len</span>(B)</span><br><span class="line"></span><br><span class="line">LCS = [[<span class="number">0</span>]*(m+<span class="number">1</span>)<span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> A[j-<span class="number">1</span>] == B[i-<span class="number">1</span>]:</span><br><span class="line">      LCS[j][i] = LCS[j-<span class="number">1</span>][i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      LCS[j][i] = <span class="built_in">max</span>(LCS[j-<span class="number">1</span>][i], LCS[j][i-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(LCS[n][m])</span><br></pre></td></tr></table></figure><h2 id="BOJ-9252-LCS-2"><a href="#BOJ-9252-LCS-2" class="headerlink" title="BOJ 9252 LCS 2"></a>BOJ 9252 LCS 2</h2><h3 id="문제-1"><a href="#문제-1" class="headerlink" title="문제"></a>문제</h3><p>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.</p><p>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.</p><h3 id="풀이-1"><a href="#풀이-1" class="headerlink" title="풀이"></a>풀이</h3><figure class="highlight python"><figcaption><span>BOJ 9252</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">input</span>()</span><br><span class="line">b = <span class="built_in">input</span>()</span><br><span class="line">la ,lb = <span class="built_in">len</span>(a), <span class="built_in">len</span>(b)</span><br><span class="line">LCS = [[<span class="number">0</span>]*(lb+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(la+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, la+<span class="number">1</span>):</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, lb+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> a[i-<span class="number">1</span>] == b[j-<span class="number">1</span>]:</span><br><span class="line">      LCS[i][j] = LCS[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      LCS[i][j] = <span class="built_in">max</span>(LCS[i-<span class="number">1</span>][j], LCS[i][j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">sequence = []</span><br><span class="line">x,y = la, lb</span><br><span class="line"><span class="keyword">while</span> x!=<span class="number">0</span> <span class="keyword">and</span> y!= <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">if</span> LCS[x][y] == LCS[x-<span class="number">1</span>][y]:</span><br><span class="line">    x -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">elif</span> LCS[x][y] == LCS[x][y-<span class="number">1</span>]:</span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    sequence.append(a[x-<span class="number">1</span>])</span><br><span class="line">    x-=<span class="number">1</span></span><br><span class="line">    y -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(LCS[la][lb])</span><br><span class="line"><span class="built_in">print</span>(*<span class="built_in">reversed</span>(sequence), sep=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br><a href="https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence">https://velog.io/@emplam27/알고리즘-그림으로-알아보는-LCS-알고리즘-Longest-Common-Substring와-Longest-Common-Subsequence</a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 9251 LCS, BOJ 9252 LCS 2&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://oxcarxierra.github.io/tags/dp/"/>
    
    <category term="lcs" scheme="https://oxcarxierra.github.io/tags/lcs/"/>
    
  </entry>
  
  <entry>
    <title>BOJ 11053 가장 긴 증가하는 부분수열</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_11723/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_11723/</id>
    <published>2022-07-24T03:01:19.000Z</published>
    <updated>2022-09-29T17:39:27.028Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><p>처음에 알고리즘을 어떻게 짜야하지 고민하다가, 검색해본 결과 아주 유명한 dp문제였다.<br>LIS, Longest Increasing Subsequence라고도 불린다.</p><h2 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h2><p>주어진 행렬 A가 있으면, A[i]를 마지막으로 가지는 가장 긴 증가하는 부분수열의 길이를 D[i]에 할당한다.</p><p>즉, A[i]를 찾는 알고리즘은 아래와 같다.</p><ol><li>A[0] &#x3D; 0, D[0] &#x3D; 0</li><li>A[0] ~ A[i-1]중 대응하는 A[i]보다 작으면서(그래야 마지막에 올 수 있으니까), 대응하는 D중 가장 큰 값을 찾는다.</li><li>그 값에 1을 더한 값울 D[i]에 할당한다.</li><li>이렇게 D를 완성하면, D[0]~D[N]중 최댓값을 찾으면 된다.<br>O(n^2)이라 느려서, 더 좋은 방법도 존재한다.</li></ol><h2 id="BOJ-11723-가장-긴-증가하는-부분수열"><a href="#BOJ-11723-가장-긴-증가하는-부분수열" class="headerlink" title="BOJ 11723 가장 긴 증가하는 부분수열"></a>BOJ 11723 가장 긴 증가하는 부분수열</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Longest Increasing Subsequence</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">A = [<span class="number">0</span>]</span><br><span class="line">A.extend(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())))</span><br><span class="line">D = [<span class="number">0</span>]*(N+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">  max_D = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; A[i]:</span><br><span class="line">      max_D = <span class="built_in">max</span>(max_D, D[j])</span><br><span class="line">  D[i] = max_D + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(D))</span><br></pre></td></tr></table></figure><blockquote><p>참고자료<br><a href="https://namu.wiki/w/%EC%B5%9C%EC%9E%A5">https://namu.wiki/w/최장</a> 증가 부분 수열</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;p&gt;처음에 알고리즘을 어떻게 짜야하지 고민하다가, 검색해본 결과 아주 유명한 dp문제였다.&lt;br&gt;LIS, Longest Increasing Subsequence라고도 불린다.&lt;/p&gt;
&lt;h2 id=&quot;LIS&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="dp" scheme="https://oxcarxierra.github.io/tags/dp/"/>
    
    <category term="lis" scheme="https://oxcarxierra.github.io/tags/lis/"/>
    
  </entry>
  
  <entry>
    <title>탐욕법 Greedy Algorithm</title>
    <link href="https://oxcarxierra.github.io/Algorithm/algorithm/boj_1931/"/>
    <id>https://oxcarxierra.github.io/Algorithm/algorithm/boj_1931/</id>
    <published>2022-07-16T08:27:45.000Z</published>
    <updated>2022-08-07T07:42:32.335Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><!-- toc --><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><p>탐욕적 알고리즘(그리디 알고리즘)이 사용되는 경우는 두 가지가 있다.</p><ol><li>탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제</li><li>다른 방법으로 최적해를 찾기 너무 어려울 때 근사해를 구할 수 있음.</li></ol><p>탐욕적 알고리즘으로 찾은 해가 항상 최적해라는 정당성을 증명하려면</p><ol><li>탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 것. 즉, 적어도 하나의 최적해는 이 알고리즘으로 구할 수 있다는 것.(탐욕적 선택 속성, greedy choice property)</li><li>항상 최적의 선택만을 내려서 전체 문제의 최적해를 얻을 수 있음을 증명. (최적 부분 구조, optimal substructure) ⇒ 대부분은 자명</li></ol><h2 id="BOJ-1931-회의실-배정"><a href="#BOJ-1931-회의실-배정" class="headerlink" title="BOJ 1931 회의실 배정"></a>BOJ 1931 회의실 배정</h2><p>초기 시도: 재귀, 분할정복을 이용해보았지만 시간초과.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greedy</span>():</span><br><span class="line">  <span class="keyword">global</span> cnt, time</span><br><span class="line">  time_min = time[<span class="number">0</span>]</span><br><span class="line">  new_time=[]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> time:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> time_min[<span class="number">1</span>]&lt;=i[<span class="number">0</span>]:</span><br><span class="line">      new_time.append(i)</span><br><span class="line">  time=new_time</span><br><span class="line">  <span class="built_in">print</span>(time)</span><br><span class="line">  cnt += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> time:</span><br><span class="line">    greedy()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(cnt)</span><br><span class="line"></span><br><span class="line">greedy()</span><br></pre></td></tr></table></figure><p>탐욕법 이용:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">N = <span class="built_in">int</span>(sys.stdin.readline())</span><br><span class="line">time = [<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, sys.stdin.readline().split())) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">cnt = <span class="number">1</span></span><br><span class="line">time.sort(key=<span class="keyword">lambda</span> t: (t[<span class="number">1</span>],t[<span class="number">0</span>]))</span><br><span class="line">end_time = time[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">  <span class="keyword">if</span> time[i][<span class="number">0</span>] &gt;= end_time:</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    end_time=time[i][<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;BOJ 1931 회의실 배정&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://oxcarxierra.github.io/categories/Algorithm/"/>
    
    
    <category term="greedy algorithm" scheme="https://oxcarxierra.github.io/tags/greedy-algorithm/"/>
    
  </entry>
  
</feed>
